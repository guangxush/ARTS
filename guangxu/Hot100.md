| 标题 | Algorithm |
| - | - |
| [20240902](./202409/20240902.md) |[17. Letter Combinations of a Phone Number(回溯法-电话号码的字母组合)](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)|
| [20240903](./202409/20240903.md) |[22. Generate Parentheses(生成括号)](https://leetcode.com/problems/generate-parentheses/)|
| [20240904](./202409/20240904.md) |[39. Combination Sum(组合总和)](https://leetcode.com/problems/combination-sum/description)|
| [20240905](./202409/20240905.md) |[46. Permutations(排列)](https://leetcode.com/problems/permutations/description/)|
| [20240906](./202409/20240906.md) |[51. N-Queens(N皇后)](https://leetcode.com/problems/n-queens/description)|
| [20240907](./202409/20240907.md) |[78. Subsets(子集)](https://leetcode.com/problems/subsets)|
| [20240908](./202409/20240908.md) |[79. Word Search(单词查找)](https://leetcode.com/problems/word-search)|
| [20240909](./202409/20240909.md) |[131. Palindrome Partitioning(分割回文串)](https://leetcode.com/problems/palindrome-partitioning/description)|
| [20240911](./202409/20240911.md) |[4. Median of Two Sorted Arrays(二分查找-两个排序数组的中位数)](https://leetcode.com/problems/median-of-two-sorted-arrays/)|
| [20240912](./202409/20240912.md) |[33. Search in Rotated Sorted Array(旋转数组二分查找)](https://leetcode.com/problems/search-in-rotated-sorted-array)|
| [20240913](./202409/20240913.md) |[34. Find First and Last Position of Element in Sorted Array(查找排序数组中元素的第一个和最后一个位置)](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)|
| [20240914](./202409/20240914.md) |[35. Search Insert Position(寻找插入的位置)](https://leetcode.com/problems/search-insert-position/)|
| [20240915](./202409/20240915.md) |[74. Search a 2D Matrix(二维数组的查找)](https://leetcode.com/problems/search-a-2d-matrix/description/)|
| [20240916](./202409/20240916.md) |[124. Binary Tree Maximum Path Sum(二叉树的最大路径和)](https://leetcode.com/problems/binary-tree-maximum-path-sum/description)|
| [20240917](./202409/20240917.md) |[153. Find Minimum in Rotated Sorted Array(旋转排序数组中的最小值)](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)|
| [20240918](./202409/20240918.md) |[94. Binary Tree Inorder Traversal(二叉树的中序遍历)](https://leetcode.com/problems/binary-tree-inorder-traversal)|
| [20240919](./202409/20240919.md) |[98. Validate Binary Search Tree(有效的二叉搜索树)](https://leetcode.com/problems/validate-binary-search-tree)|
| [20240920](./202409/20240920.md) |[101. Symmetric Tree(对称树)](https://leetcode.com/problems/symmetric-tree/description)|
| [20240921](./202409/20240921.md) |[102. Binary Tree Level Order Traversal(二叉树的层次遍历)](https://leetcode.com/problems/binary-tree-level-order-traversal/description)|
| [20240922](./202409/20240922.md) |[104. Maximum Depth of Binary Tree(二叉树的最大深度)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description)|
| [20240923](./202409/20240923.md) |[105. Construct Binary Tree from Preorder and Inorder Traversal(根据前序和中序构造二叉树)](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)|
| [20241211](./202412/20241211.md) |[108. Convert Sorted Array to Binary Search Tree(排序数组转换成二叉搜索树)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)|
| [20240924](./202409/20240924.md) |[114. Flatten Binary Tree to Linked List(二叉树转换成单链表)](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)|
| [20240925](./202409/20240925.md) |[199. Binary Tree Right Side View(二叉树的右视图)](https://leetcode.com/problems/binary-tree-right-side-view/description)|
| [20240926](./202409/20240926.md) |[226. Invert Binary Tree(旋转二叉树)](https://leetcode.com/problems/invert-binary-tree/description/)|
| [20240927](./202409/20240927.md) |[230. Kth Smallest Element in a BST(二叉搜索树的第K个最小元素)](https://leetcode.com/problems/kth-smallest-element-in-a-bst)|
| [20240928](./202409/20240928.md) |[236. Lowest Common Ancestor of a Binary Tree(二叉树的最近公共祖先)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)|
| [20240929](./202409/20240929.md) |[437. Path Sum III(路径和3)](https://leetcode.com/problems/path-sum-iii/description)|
| [20240930](./202409/20240930.md) |[543. Diameter of Binary Tree(二叉树的直径)](https://leetcode.com/problems/diameter-of-binary-tree/)|
| [20241001](./202410/20241001.md) |[5. Longest Palindromic Substring(动态规划-最长回文子串)](https://leetcode.com/problems/longest-palindromic-substring/description)|
| [20241002](./202410/20241002.md) |[32. Longest Valid Parentheses(最长有效括号)](https://leetcode.com/problems/longest-valid-parentheses/description)|
| [20241003](./202410/20241003.md) |[62. Unique Paths(不同的路径)](https://leetcode.com/problems/unique-paths/description)|
| [20241004](./202410/20241004.md) |[64. Minimum Path Sum(最小路径和)](https://leetcode.com/problems/minimum-path-sum/description)|
| [20241005](./202410/20241005.md) |[70. Climbing Stairs(爬梯子)](https://leetcode.com/problems/climbing-stairs/description/)|
| [20241006](./202410/20241006.md) |[72. Edit Distance(编辑距离)](https://leetcode.com/problems/edit-distance/)|
| [20241007](./202410/20241007.md) |[118. Pascal's Triangle(杨辉三角)](https://leetcode.com/problems/pascals-triangle/description)|
| [20241008](./202410/20241008.md) |[139. Word Break(单词拆分)](https://leetcode.com/problems/word-break/)|
| [20241009](./202410/20241009.md) |[152. Maximum Product Subarray(乘积最大的子数组)](https://leetcode.com/problems/maximum-product-subarray/)|
| [20241010](./202410/20241010.md) |[198. House Robber(打家劫舍)](https://leetcode.com/problems/house-robber/description)|
| [20241011](./202410/20241011.md) |[279. Perfect Squares(完美正方形)](https://leetcode.com/problems/perfect-squares/description/)|
| [20241012](./202410/20241012.md) |[300. Longest Increasing Subsequence(最长递增子序列)](https://leetcode.com/problems/longest-increasing-subsequence/)|
| [20241013](./202410/20241013.md) |[322. Coin Change(零钱兑换)](https://leetcode.com/problems/coin-change)|
| [20241014](./202410/20241014.md) |[416. Partition Equal Subset Sum(分割和相等的子数组)](https://leetcode.com/problems/partition-equal-subset-sum)|
| [20241015](./202410/20241015.md) |[1143. Longest Common Subsequence(最长公共子序列)](https://leetcode.com/problems/longest-common-subsequence/)|
| [20241016](./202410/20241016.md) |[1. Two Sum(哈希-两数之和)](https://leetcode.com/problems/two-sum/description/)|
| [20241017](./202410/20241017.md) |[49. Group Anagrams(字母异位词分组)](https://leetcode.com/problems/group-anagrams/description)|
| [20241018](./202410/20241018.md) |[128. Longest Consecutive Sequence(最长连续子序列)](https://leetcode.com/problems/longest-consecutive-sequence/)|
| [20241019](./202410/20241019.md) |[560. Subarray Sum Equals K(和为K的子数组)](https://leetcode.com/problems/subarray-sum-equals-k/description/)|
| [20241020](./202410/20241020.md) |[2. Add Two Numbers(链表-两数相加)](https://leetcode.com/problems/add-two-numbers)|
| [20241021](./202410/20241021.md) |[19. Remove Nth Node From End of List(移除链表中倒数第N个元素)](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)|
| [20241022](./202410/20241022.md) |[21. Merge Two Sorted Lists(合并两个排序链表)](https://leetcode.com/problems/merge-two-sorted-lists/)|
| [20241023](./202410/20241023.md) |[23. Merge k Sorted Lists(合并K个有序链表)](https://leetcode.com/problems/merge-k-sorted-lists/)|
| [20241024](./202410/20241024.md) |[24. Swap Nodes in Pairs(两两交换链表的节点)](https://leetcode.com/problems/swap-nodes-in-pairs/)|
| [20241025](./202410/20241025.md) |[25. Reverse Nodes in k-Group(K组反转链表)](https://leetcode.com/problems/reverse-nodes-in-k-group/)|
| [20241026](./202410/20241026.md) |[138. Copy List with Random Pointer(带随机指针Copy链表)](https://leetcode.com/problems/copy-list-with-random-pointer)|
| [20241027](./202410/20241027.md) |[141. Linked List Cycle(环形链表)](https://leetcode.com/problems/linked-list-cycle/description/)|
| [20241028](./202410/20241028.md) |[142. Linked List Cycle II(环形链表2)](https://leetcode.com/problems/linked-list-cycle-ii/)|
| [20241029](./202410/20241029.md) |[146. LRU Cache(LRU缓存)](https://leetcode.com/problems/lru-cache/description/)|
| [20241030](./202410/20241030.md) |[148. Sort List(链表排序)](https://leetcode.com/problems/sort-list/)|
| [20241031](./202410/20241031.md) |[160. Intersection of Two Linked Lists(两个链表的交集)](https://leetcode.com/problems/intersection-of-two-linked-lists/)|
| [20241101](./202411/20241101.md) |[206. Reverse Linked List(反转链表)](https://leetcode.com/problems/reverse-linked-list/description/)|
| [20241102](./202411/20241102.md) |[234. Palindrome Linked List(回文链表)](https://leetcode.com/problems/palindrome-linked-list/description)|
| [20241103](./202411/20241103.md) |[200. Number of Islands(图-岛屿的数量)](https://leetcode.com/problems/number-of-islands/)|
| [20241104](./202411/20241104.md) |[207. Course Schedule(课程计划)](https://leetcode.com/problems/course-schedule/)|
| [20241105](./202411/20241105.md) |[994. Rotting Oranges(腐烂的橘子)](https://leetcode.com/problems/rotting-oranges/description/)|
| [20241106](./202411/20241106.md) |[45. Jump Game II(贪心算法-跳跃游戏2)](https://leetcode.com/problems/jump-game-ii/)|
| [20241107](./202411/20241107.md) |[55. Jump Game(跳跃游戏)](https://leetcode.com/problems/jump-game/)|
| [20241108](./202411/20241108.md) |[121. Best Time to Buy and Sell Stock(买卖股票的最佳时机)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)|
| [20241109](./202411/20241109.md) |[763. Partition Labels(划分区间)](https://leetcode.com/problems/partition-labels/description/)|
| [20241110](./202411/20241110.md) |[215. Kth Largest Element in an Array(堆-数组中第K个最大元素)](https://leetcode.com/problems/kth-largest-element-in-an-array/)|
| [20241111](./202411/20241111.md) |[295. Find Median from Data Stream(发现数据流中的中位数)](https://leetcode.com/problems/find-median-from-data-stream/)|
| [20241112](./202411/20241112.md) |[347. Top K Frequent Elements(TopK个频率的元素)](https://leetcode.com/problems/top-k-frequent-elements/description)|
| [20241113](./202411/20241113.md) |[48. Rotate Image(矩阵-旋转图像)](https://leetcode.com/problems/rotate-image/description/)|
| [20241114](./202411/20241114.md) |[54. Spiral Matrix(螺旋矩阵)](https://leetcode.com/problems/spiral-matrix/description)|
| [20241115](./202411/20241115.md) |[73. Set Matrix Zeroes(设置矩阵零)](https://leetcode.com/problems/set-matrix-zeroes/)|
| [20241116](./202411/20241116.md) |[240. Search a 2D Matrix II(二维矩阵的查找)](https://leetcode.com/problems/search-a-2d-matrix-ii)|
| [20241117](./202411/20241117.md) |[3. Longest Substring Without Repeating Characters(滑动窗口-无重复字符的最长子串)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)|
| [20241118](./202411/20241118.md) |[76. Minimum Window Substring(最小区间子串)](https://leetcode.com/problems/minimum-window-substring/description)|
| [20241119](./202411/20241119.md) |[239. Sliding Window Maximum(滑动窗口最大值)](https://leetcode.com/problems/sliding-window-maximum/)|
| [20241120](./202411/20241120.md) |[438. Find All Anagrams in a String(找出字符串中所有的变位词)](https://leetcode.com/problems/find-all-anagrams-in-a-string/)|
| [20241121](./202411/20241121.md) |[20. Valid Parentheses(栈-有效括号匹配)](https://leetcode.com/problems/valid-parentheses/)|
| [20241122](./202411/20241122.md) |[84. Largest Rectangle in Histogram(柱状图中的最大矩形)](https://leetcode.com/problems/largest-rectangle-in-histogram/)|
| [20241123](./202411/20241123.md) |[155. Min Stack(最小栈)](https://leetcode.com/problems/min-stack/description/)|
| [20241124](./202411/20241124.md) |[394. Decode String(解码字符串)](https://leetcode.com/problems/decode-string/description/)|
| [20241125](./202411/20241125.md) |[739. Daily Temperatures(每日温度)](https://leetcode.com/problems/daily-temperatures/description/)|
| [20241126](./202411/20241126.md) |[11. Container With Most Water(双指针-盛满水的最大容器)](https://leetcode.com/problems/container-with-most-water/)|
| [20241127](./202411/20241127.md) |[15. 3Sum(三数之和)](https://leetcode.com/problems/3sum/)|
| [20241128](./202411/20241128.md) |[42. Trapping Rain Water(接雨水)](https://leetcode.com/problems/trapping-rain-water/)|
| [20241129](./202411/20241129.md) |[283. Move Zeroes(移动零)](https://leetcode.com/problems/move-zeroes/)|
| [20241130](./202411/20241130.md) |[208. Implement Trie (Prefix Tree)(实现前缀树)](https://leetcode.com/problems/implement-trie-prefix-tree/)|
| [20241201](./202412/20241201.md) |[31. Next Permutation(其他-下一个排列)](https://leetcode.com/problems/next-permutation/description/)|
| [20241202](./202412/20241202.md) |[41. First Missing Positive(发现第一个缺失的正数)](https://leetcode.com/problems/first-missing-positive/)|
| [20241203](./202412/20241203.md) |[53. Maximum Subarray(最大子段和)](https://leetcode.com/problems/maximum-subarray/description/)|
| [20241204](./202412/20241204.md) |[56. Merge Intervals(区间交集)](https://leetcode.com/problems/merge-intervals/description/)|
| [20241205](./202412/20241205.md) |[75. Sort Colors(三色排序)](https://leetcode.com/problems/sort-colors/description/)|
| [20241206](./202412/20241206.md) |[136. Single Number(单一数字)](https://leetcode.com/problems/single-number/)|
| [20241207](./202412/20241207.md) |[169. Majority Element(主要元素)](https://leetcode.com/problems/majority-element)|
| [20241208](./202412/20241208.md) |[189. Rotate Array(旋转数组)](https://leetcode.com/problems/rotate-array/description/)|
| [20241209](./202412/20241209.md) |[238. Product of Array Except Self(除自身以外数组的乘积)](https://leetcode.com/problems/product-of-array-except-self)|
| [20241210](./202412/20241210.md) |[287. Find the Duplicate Number(发现重复出现的元素)](https://leetcode.com/problems/find-the-duplicate-number/)|

------

# 回溯法

## [20240902](./202409/20240902.md) |[17. Letter Combinations of a Phone Number(电话号码的字母组合)](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

```Java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> list = new LinkedList<>();
        if(digits == null || digits.length() == 0) {
            return list;
        }
        char[][] map = {{},{},{'a','b','c'},{'d','e','f'},{'g','h','i'},{'j','k','l'},{'m','n','o'},{'p','q','r','s'},{'t','u','v'},{'w','x','y','z'}};
        backtrack(digits,list,map,new StringBuilder(),0);
        return list;
    }
    private void backtrack(String digits, List<String> list, char[][] map, StringBuilder result, int start){
        if(start == digits.length()){
            list.add(new String(result));
            return;
        }
        int num = digits.charAt(start) - '0';
        for(int i = 0;i< map[num].length;i++){
            result.append(map[num][i]);
            backtrack(digits, list, map, result, start+1);
            result.deleteCharAt(result.length() - 1);
        }
    }
}
```
## [20240903](./202409/20240903.md) |[22. Generate Parentheses(生成括号)](https://leetcode.com/problems/generate-parentheses/)

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> list = new ArrayList<>();
        backtrack(list,"",0,0,n);
        return list;
    }
    public void backtrack(List<String> list, String result, int left, int right, int n){
        if(result.length() == n * 2){
            list.add(result);
            return;
        }
        if(left < n){
            backtrack(list,result+"(",left+1,right,n);
        }
        if(right < left){
            backtrack(list,result+")",left,right+1,n);
        }
    }
}
```

## [20240904](./202409/20240904.md) |[39. Combination Sum(组合总和)](https://leetcode.com/problems/combination-sum/description)


```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(candidates);
        backtrack(list, new ArrayList<>(), candidates, target, 0);
        return list;
    }

    public void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int remain, int start){
        if(remain < 0){
            return;
        }else if(remain == 0){
            list.add(new ArrayList<>(tempList));
            return;
        }else{
            for(int i = start; i<nums.length; i++){
                tempList.add(nums[i]);
                backtrack(list, tempList, nums, remain-nums[i], i);
                tempList.remove(tempList.size() - 1);
            }
        }
    }
}
```

## [20240905](./202409/20240905.md) |[46. Permutations(排列)](https://leetcode.com/problems/permutations/description/)


```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> lists = new ArrayList<List<Integer>>();
        backtrack(nums, 0, lists);
        return lists;
    }

    public void backtrack(int[] nums, int start, List<List<Integer>> lists){
        if(start == nums.length){
            List<Integer> temp = new ArrayList<>();
            for(int i = 0; i<nums.length; i++){
                temp.add(nums[i]);
            }
            lists.add(temp);
        }else{
            for(int i=start; i<nums.length; i++){
                swap(nums, i, start);
                backtrack(nums, start + 1, lists);
                swap(nums, i, start);
            }
        }
    }

    public static void swap(int[] nums, int start, int end){
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
    }
}
```

## [20240906](./202409/20240906.md) |[51. N-Queens(N皇后)](https://leetcode.com/problems/n-queens/description)


```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        char[][] board = new char[n][n];
        for(int i = 0; i < n; i++)
            for(int j = 0; j < n; j++)
                board[i][j] = '.';
        List<List<String>> res = new ArrayList<List<String>>();
        backtrack(board, 0, res);
        return res;
    }

    private void backtrack(char[][] board, int colIndex, List<List<String>> res) {
        if(colIndex == board.length) {
            res.add(construct(board));
            return;
        }

        for(int i = 0; i < board.length; i++) {
            if(validate(board, i, colIndex)) {
                board[i][colIndex] = 'Q';
                backtrack(board, colIndex + 1, res);
                board[i][colIndex] = '.';
            }
        }
    }

    private boolean validate(char[][] board, int x, int y) {
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < y; j++) {
                if(board[i][j] == 'Q' && (x + j == y + i || x + y == i + j || x == i))
                    return false;
            }
        }

        return true;
    }

    private List<String> construct(char[][] board) {
        List<String> res = new LinkedList<String>();
        for(int i = 0; i < board.length; i++) {
            String s = new String(board[i]);
            res.add(s);
        }
        return res;
    }
}
```

## [20240907](./202409/20240907.md) |[78. Subsets(子集)](https://leetcode.com/problems/subsets)

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(nums);
        backtrack(list, new ArrayList<>(), nums, 0);
        return list;
    }

    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start){
        list.add(new ArrayList<>(tempList));
        for(int i=start;i<nums.length;i++){
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, i+1);
            tempList.remove(tempList.size()-1);
        }
    }
}
```

## [20240908](./202409/20240908.md) |[79. Word Search(单词查找)](https://leetcode.com/problems/word-search)
```java
class Solution {
    int[][] dirs={{1,0},{-1,0},{0,1},{0,-1}};
    public boolean exist(char[][] board, String word) {
        if (board==null ||board.length==0||board[0].length==0) return false;
        int m=board.length,n=board[0].length;
        boolean[][] visited=new boolean[m][n];
        for (int i=0;i< m;i++){
            for (int j=0;j<n;j++){               
                if (dfs(board,visited,i,j,0,word)){
                    return true;
                }              
            }
        }
        return false;
    }
    private boolean dfs(char[][] board, boolean[][] visited, int x, int y, int i, String word){         
        int m=board.length,n=board[0].length;   
        if (i==word.length()) return true;

        if(x<0||x>=m||y<0||y>=n) return false;
        if(visited[x][y]) return false;
        if(board[x][y]!=word.charAt(i)) return false;

        visited[x][y]=true;
        for (int[] dir: dirs){
            int x1=x+dir[0], y1=y+dir[1];
            if (dfs(board, visited, x1, y1, i+1, word)){
                return true;
            }
        }
        visited[x][y]=false;
        return false;                                                                          
    }
}
```

## [20240909](./202409/20240909.md) |[131. Palindrome Partitioning(分割回文串)](https://leetcode.com/problems/palindrome-partitioning/description)

```java
public class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> res=new ArrayList<List<String>>();
        if(s.length()==0)return res;
        recur(res,new ArrayList<String>(),s);
        return res;
    }

    public void recur(List<List<String>> res,List<String> temp, String s){
        if(s.length()==0){
            res.add(new ArrayList<String>(temp));
            return;
        }
        for(int i=0;i<s.length();i++){
            if(isPalin(s.substring(0,i+1))){
                temp.add(s.substring(0,i+1));
                recur(res,temp,s.substring(i+1));
                temp.remove(temp.size()-1);
            }
        }
    }

    public boolean isPalin(String s){
        for(int i=0;i<s.length()/2;i++){
            if(s.charAt(i)!=s.charAt(s.length()-1-i))return false;
        }
        return true;
    }
}
```

# 二分查找

## [20240911](./202409/20240911.md) |[4. Median of Two Sorted Arrays(两个排序数组的中位数)](https://leetcode.com/problems/median-of-two-sorted-arrays/)


```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        int l = (m+n+1)/2;
        int r = (m+n+2)/2;
        return (getKth(nums1,0,nums2,0,l)+getKth(nums1,0,nums2,0,r))/2.0;
    }

    public double getKth(int[] A, int aStart, int[] B, int bStart, int k){
        if(aStart>A.length-1){
            return B[bStart+k-1];
        }
        if(bStart>B.length-1){
            return A[aStart+k-1];
        }
        if(k==1){
            return Math.min(A[aStart],B[bStart]);
        }
        int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE;
        if(aStart+k/2-1<A.length){
            aMid = A[aStart+k/2-1];
        }
        if(bStart+k/2-1<B.length){
            bMid = B[bStart+k/2-1];   
        }
        if(aMid<bMid){
            return getKth(A, aStart+k/2,B,bStart,k-k/2);
        }else{
            return getKth(A,aStart,B,bStart+k/2, k-k/2);
        }
    }
}
```

## [20240912](./202409/20240912.md) |[33. Search in Rotated Sorted Array(旋转数组二分查找)](https://leetcode.com/problems/search-in-rotated-sorted-array)


```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right-left)/2;
            if(nums[mid] == target){
                return mid;
            }
            if(nums[mid] < nums[right]){
                if(nums[mid] < target && target <= nums[right]){
                    left = mid + 1;
                }else{
                    right = mid - 1;
                }
            }else{
                if(nums[left] <= target && target < nums[mid]){
                    right = mid -1;
                }else{
                    left = mid + 1;
                }
            }
        }
        return -1;
    }
}
```

## [20240913](./202409/20240913.md) |[34. Find First and Last Position of Element in Sorted Array(查找排序数组中元素的第一个和最后一个位置)](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] res = new int[] { -1, -1 };
        if (nums == null || nums.length == 0) {
            return res;
        }
        int start = 0, end = nums.length - 1;
        while (nums[start] < nums[end]) {
            int mid = start + (end - start) / 2;
            if (nums[mid] < target) {
                start = mid + 1;
            } else if (nums[mid] > target) {
                end = mid - 1;
            } else {
                if (nums[start] < target) {
                    start++;
                }
                if (nums[end] > target) {
                    end--;
                }
            }
        }
        if (nums[start] == target) {
            res[0] = start;
            res[1] = end;
        }
        return res;
    }
}
```

## [20240914](./202409/20240914.md) |[35. Search Insert Position(寻找插入的位置)](https://leetcode.com/problems/search-insert-position/)

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length-1;
        while(left<=right){
             int mid = left + (right - left)/2;
             if(nums[mid] == target){
                 right = mid -1;
             }else if(nums[mid] < target){
                 left = mid +1;
             }else{
                 right = mid -1;
             }
        }
        return left;
    }
}
```

## [20240915](./202409/20240915.md) |[74. Search a 2D Matrix(二维数组的查找)](https://leetcode.com/problems/search-a-2d-matrix/description/)


```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int i = 0;
        int j = matrix[0].length-1;
        while(i>=0 && i<matrix.length && j>=0 && j<matrix[0].length){
            if(matrix[i][j] == target){
                return true;
            }else if(matrix[i][j] < target){
                i++;
            }else if(matrix[i][j] > target){
                j--;
            }
        }
        return false;
    }
}
```


## [20240916](./202409/20240916.md) |[124. Binary Tree Maximum Path Sum(二叉树的最大路径和)](https://leetcode.com/problems/binary-tree-maximum-path-sum/description)

```java
class Solution {

    private int maxValue = Integer.MIN_VALUE;;

    public int maxPathSum(TreeNode root){
        maxPathDown(root);
        return maxValue;
    }

    private int maxPathDown(TreeNode node) {
        if(node == null){
            return 0;
        }
        int left = Math.max(0, maxPathDown(node.left));
        int right = Math.max(0, maxPathDown(node.right));
        maxValue = Math.max(maxValue, left + right + node.val);
        return Math.max(left, right) + node.val;
    }
}
```

## [20240917](./202409/20240917.md) |[153. Find Minimum in Rotated Sorted Array(旋转排序数组中的最小值)](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

```java
class Solution {
    public int findMin(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        int left = 0, right = nums.length - 1;
        if (nums[right] > nums[0]) {
            return nums[0];
        }
        while (right >= left) {
            int mid = left + (right - left)/2;
            if(nums[mid] > nums[mid+1]){
                return nums[mid+1];
            }
            if(nums[mid-1] > nums[mid]){
                return nums[mid];
            }
            if(nums[0] < nums[mid]){
                left = mid + 1;
            }else{
                right = mid -1;
            }
        }
        return Integer.MAX_VALUE;
    }
}
```
# 二叉树
## [20240918](./202409/20240918.md) |[94. Binary Tree Inorder Traversal(二叉树的中序遍历)](https://leetcode.com/problems/binary-tree-inorder-traversal)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            while(root != null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            result.add(root.val);
            root = root.right;
        }
        return result;
    }

    public void inorder(TreeNode root, List<Integer> result){
        if(root == null){
            return;
        }
        inorder(root.left, result);
        result.add(root.val);
        inorder(root.right, result);
    }
}
```

前序遍历

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        if(root == null){
            return new ArrayList<>();
        }
        stack.push(root);
        while(!stack.isEmpty()){
            root = stack.pop();
            result.add(root.val);
            if(root.right != null){
                stack.push(root.right);
            }
            if(root.left != null){
                stack.push(root.left);
            }
        }
        return result;
    }

    public void preOrder(List<Integer> result, TreeNode root){
        if(root == null){
            return;
        }
        result.add(root.val);
        preOrder(result, root.left);
        preOrder(result, root.right);
    }
}
```

后序遍历

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> stack = new Stack<>();
        if(root == null){
            return new LinkedList<>();
        }
        stack.push(root);
        while(!stack.isEmpty()){
            root = stack.pop();
            result.add(0, root.val);
            if(root.left != null){
                stack.push(root.left);
            }
            if(root.right != null){
                stack.push(root.right);
            }
        }
        return result;
    }

    public void postOrder(List<Integer> result, TreeNode root){
        if(root == null){
            return;
        }
        postOrder(result, root.left);
        postOrder(result, root.right);
        result.add(root.val);
    }
}
```
## [20240919](./202409/20240919.md) |[98. Validate Binary Search Tree(有效的二叉搜索树)](https://leetcode.com/problems/validate-binary-search-tree)


```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null){
            return true;
        }
        return dfs(root,Long.MIN_VALUE,Long.MAX_VALUE);
    }

    boolean dfs(TreeNode root,long min,long max){
        // 当前节点为空直接返回true
        if(root == null){
            return true;
        }
        // 当前节点比min或者left节点小，或者当前节点比right节点大，返回false
        if(root.val<=min||root.val>=max){
            return false;
        }
        // 递归执行(left，min, 根结点) &&(right，根结点, max)
        return dfs(root.left,min,(int)root.val)&&
            dfs(root.right,(int)root.val,max);
    }
}
```

## [20240920](./202409/20240920.md) |[101. Symmetric Tree(对称树)](https://leetcode.com/problems/symmetric-tree/description)

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null){
            return true;
        }
        if(root.left==null && root.right==null){
            return true;
        }
        return isSamed(root.left, root.right);
    }
    public boolean isSamed(TreeNode left, TreeNode right){
        if(left == null && right == null){
            return true;
        }
        if(left == null && right != null){
            return false;
        }
        if(left != null && right == null){
            return false;
        }
        if(left.val != right.val){
            return false;
        }
        return isSamed(left.left, right.right) && isSamed(left.right, right.left);
    }
}
```
## [20240921](./202409/20240921.md) |[102. Binary Tree Level Order Traversal(二叉树的层次遍历)](https://leetcode.com/problems/binary-tree-level-order-traversal/description)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> lists = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList();
        if(root==null){
            return lists;
        }
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i=0;i<size;i++){
                root = queue.poll();
                if(root.left != null){
                    queue.add(root.left);
                }
                if(root.right != null){
                    queue.add(root.right);
                }
                list.add(root.val);
            }
            lists.add(list);
        }
        return lists;
    }
}
```
## [20240922](./202409/20240922.md) |[104. Maximum Depth of Binary Tree(二叉树的最大深度)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description)

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) +1;
    }
}
```
## [20240923](./202409/20240923.md) |[105. Construct Binary Tree from Preorder and Inorder Traversal(根据前序和中序构造二叉树)](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || inorder == null || preorder.length == 0 || inorder.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[0]);
        for (int i = 0; i < inorder.length; i++) {
            if (preorder[0] == inorder[i]) {
                root.left = buildTree(Arrays.copyOfRange(preorder, 1, i + 1),
                        Arrays.copyOfRange(inorder, 0, i));
                root.right = buildTree(Arrays.copyOfRange(preorder, i + 1, preorder.length),
                        Arrays.copyOfRange(inorder, i + 1, inorder.length));
            }
        }
        return root;
    }
}
```

中序和后序

```Java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if(inorder==null||postorder==null||inorder.length==0||postorder.length==0){
            return null;
        }
        TreeNode treeNode = new TreeNode(postorder[postorder.length-1]);
        for(int i = 0; i<inorder.length; i++){
            if(inorder[i] == postorder[postorder.length-1]){
                treeNode.left = buildTree(Arrays.copyOfRange(inorder, 0, i), Arrays.copyOfRange(postorder, 0, i));
                treeNode.right = buildTree(Arrays.copyOfRange(inorder, i+1, inorder.length), Arrays.copyOfRange(postorder, i, postorder.length-1));
            }
        }
        return treeNode;
    }
}
```

## [20241211](./202412/20241211.md) |[108. Convert Sorted Array to Binary Search Tree(排序数组转换成二叉搜索树)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)

```Java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
         return buildTree(nums, 0 , nums.length-1);
    }
    public TreeNode buildTree(int[] nums, int low, int high){
        if(low > high){
            return null;
        }
        int mid = low + (high-low)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildTree(nums, low, mid-1);
        root.right = buildTree(nums, mid+1, high);
        return root;
    }
}
```

## [20240924](./202409/20240924.md) |[114. Flatten Binary Tree to Linked List(二叉树转换成单链表)](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)

```java
class Solution {
    public void flatten(TreeNode root) {
        while(root!=null){
            if(root.left!=null){
                TreeNode cur = root.left;
                while(cur.right!=null){
                    cur = cur.right;
                }
                cur.right = root.right;
                root.right = root.left;
                root.left = null;
            }
            root = root.right;
        }
    }
}
```
## [20240925](./202409/20240925.md) |[199. Binary Tree Right Side View(二叉树的右视图)](https://leetcode.com/problems/binary-tree-right-side-view/description)

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null){
          return list;
        }
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i=0; i<size; i++){
                TreeNode node = queue.poll();
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                if(i == size-1){
                    list.add(node.val);
                }
            }
        }
        return list;
    }
}
```
## [20240926](./202409/20240926.md) |[226. Invert Binary Tree(旋转二叉树)](https://leetcode.com/problems/invert-binary-tree/description/)

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null){
            return root;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```
## [20240927](./202409/20240927.md) |[230. Kth Smallest Element in a BST(二叉搜索树的第K个最小元素)](https://leetcode.com/problems/kth-smallest-element-in-a-bst)

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        while(true){
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            if(stack.isEmpty()){
                break;
            }
            root = stack.pop();
            if(--k==0){
                return root.val;
            }
            root = root.right;
        }
        return 0;
    }
}
```

中序遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            while(root != null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            result.add(root.val);
            root = root.right;
        }
        return result;
    }

    public void inorder(TreeNode root, List<Integer> result){
        if(root == null){
            return;
        }
        inorder(root.left, result);
        result.add(root.val);
        inorder(root.right, result);
    }
}
```
## [20240928](./202409/20240928.md) |[236. Lowest Common Ancestor of a Binary Tree(二叉树的最近公共祖先)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null){
            return null;
        }
        if(root.val==p.val || root.val==q.val){
            return root;
        }
        TreeNode lca1 = lowestCommonAncestor(root.left, p, q);
        TreeNode lca2 = lowestCommonAncestor(root.right, p, q);
        if(lca1!=null && lca2!=null){
            return root;
        }
        if(lca1 !=null){
            return lca1;
        }else{
            return lca2;
        }
    }
}
```
如果 p 和 q 分别位于当前节点的左右两侧，则当前节点就是它们的最低公共祖先。
如果 p 和 q 都位于左子树或右子树，则返回相应子树中找到的节点
## [20240929](./202409/20240929.md) |[437. Path Sum III(路径和3)](https://leetcode.com/problems/path-sum-iii/description)

```java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return 0;
        }
        return dfs(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);
    }

    public int dfs(TreeNode root, int sum) {
        int res = 0;
        if(root == null){
            return res;
        }
        if(sum == root.val){
            res ++;
        }
        res += dfs(root.left, sum-root.val);
        res += dfs(root.right, sum-root.val);
        return res;
    }
}
```
## [20240930](./202409/20240930.md) |[543. Diameter of Binary Tree(二叉树的直径)](https://leetcode.com/problems/diameter-of-binary-tree/)

```java
class Solution {
    private int max = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        nodes(root);
        return max;
    }

    private int nodes(TreeNode root){
        if(root == null){
            return 0;
        }
        int len1 = nodes(root.left);
        int len2 = nodes(root.right);
        max = Math.max(max, len1+len2);
        return len1 > len2 ? len1 + 1 : len2 + 1;
    }
}
```
# 动态规划

## [20241001](./202410/20241001.md) |[5. Longest Palindromic Substring(最长回文子串)](https://leetcode.com/problems/longest-palindromic-substring/description)

```java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }
        int len = s.length();
        String ans = "";
        int max = 0;
        boolean[][] dp = new boolean[len][len];
        for (int j = 0; j < len; j++) {
            for (int i = 0; i < len; i++) {
                boolean judge = s.charAt(i) == s.charAt(j);
                dp[i][j] = j - i > 2 ? dp[i + 1][j - 1] && judge : judge;
                if (dp[i][j] && j - i + 1> max) {
                    ans = s.substring(i, j + 1);
                    max = j - i + 1;
                }
            }
        }
        return ans;
    }
}
```
## [20241002](./202410/20241002.md) |[32. Longest Valid Parentheses(最长有效括号)](https://leetcode.com/problems/longest-valid-parentheses/description)

```java
class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        int maxLen = 0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='('){
                stack.push(i);
            }else{
                // 留一个哨兵index = -1，每一个多余的左括号'('的下标, 或者栈为空时右括号')'的下标，都成了新的哨兵
                stack.pop();
                // 如果栈为空，说明右括号多了，那么右括号的index作为新的哨兵
                if(stack.isEmpty()){
                    stack.push(i);
                }
                maxLen = Math.max(maxLen, i - stack.peek());
            }
        }
        return maxLen;
    }
}
```
## [20241003](./202410/20241003.md) |[62. Unique Paths(动态规划-不同的路径)](https://leetcode.com/problems/unique-paths/description)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        dp[1][1] = 1;
        for (int i = 2; i <= m; i++) {
            dp[i][1] = dp[i - 1][1];
        }
        for (int j = 2; j <= n; j++) {
            dp[1][j] = dp[1][j - 1];
        }
        for (int i = 2; i <= m; i++) {
            for (int j = 2; j <= n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
}
```
## [20241004](./202410/20241004.md) |[64. Minimum Path Sum(最小路径和)](https://leetcode.com/problems/minimum-path-sum/description)

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 1; i < m; i++) {
            grid[i][0] += grid[i - 1][0];
        }
        for (int j = 1; j < n; j++) {
            grid[0][j] += grid[0][j - 1];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                grid[i][j] += Math.min(grid[i][j - 1], grid[i - 1][j]);
            }
        }
        return grid[m - 1][n - 1];
    }
}
```
## [20241005](./202410/20241005.md) |[70. Climbing Stairs(爬梯子)](https://leetcode.com/problems/climbing-stairs/description/)

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 1) {
            return 1;
        }
        int[] dp = new int[n];
        dp[0] = 1;
        dp[1] = 2;
        for(int i=2; i<n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n-1];
    }
}
```
## [20241006](./202410/20241006.md) |[72. Edit Distance(编辑距离)](https://leetcode.com/problems/edit-distance/)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        int[][] dp = new int[len1+1][len2+1];
        for(int i=0;i<=len1;i++){
            dp[i][0] = i;
        }
        for(int j=0;j<=len2;j++){
            dp[0][j] = j;
        }
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                if(word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]))+1;
                }
            }
        }
        return dp[len1][len2];
    }
}
```
## [20241007](./202410/20241007.md) |[118. Pascal's Triangle(杨辉三角)](https://leetcode.com/problems/pascals-triangle/description)

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> lists= new ArrayList<>();
        if(numRows==0) {
            return lists;
        }
        if(numRows>=1) {
            List<Integer> list = new ArrayList<>();
            list.add(1);
            lists.add(list);
        }
        if(numRows>=2) {
            List<Integer> list = new ArrayList<>();
            list.add(1);
            list.add(1);
            lists.add(list);
        }
        if(numRows>=3){
            for(int j =3;j<=numRows;j++){
                List<Integer> list = new ArrayList<>();
                List<Integer> pre = lists.get(lists.size()-1);
                list.add(1);
                for(int i=0; i<pre.size()-1; i++){
                    int num = pre.get(i) + pre.get(i+1);
                    list.add(num);
                }
                list.add(1);
                lists.add(list);
            }
        }
        return lists;
    }
}
```
## [20241008](./202410/20241008.md) |[139. Word Break(单词拆分)](https://leetcode.com/problems/word-break/)

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] T = new boolean[s.length() + 1];
        Set<String> set = new HashSet<>();
        for (String word : wordDict) {
            set.add(word);
        }
        T[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if(T[j] && set.contains(s.substring(j, i))) {
                    T[i] = true;
                    break;
                }
            }
        }
        return T[s.length()];
    }
}
```
## [20241009](./202410/20241009.md) |[152. Maximum Product Subarray(乘积最大的子数组)](https://leetcode.com/problems/maximum-product-subarray/)

```java
class Solution {
    public int maxProduct(int[] nums) {
        int ans = Integer.MIN_VALUE;
        int currProd = 1;

        for (int i = 0; i < nums.length; i++) {
            currProd *= nums[i];
            ans = Math.max(ans, currProd);
            currProd = currProd == 0 ? 1 : currProd;
        }

        currProd = 1;
        for (int j = nums.length - 1; j >= 0; j--) {
            currProd *= nums[j];
            ans = Math.max(ans, currProd);
            currProd = currProd == 0 ? 1 : currProd;
        }
        return ans;
    }
}
```
## [20241010](./202410/20241010.md) |[198. House Robber(打家劫舍)](https://leetcode.com/problems/house-robber/description)

```java
class Solution {
    public int rob(int[] nums) {
        if(nums==null || nums.length==0){
            return 0;
        }
        int[] dp = new int[nums.length+1];
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i=1;i<nums.length;i++){
            // 下一家可以偷，dp[i-1]+nums[i]
            // 下一家不可以偷，dp[i]
            dp[i+1] = Math.max(dp[i], nums[i]+dp[i-1]);
        }
        return dp[nums.length];
    }
}
```
## [20241011](./202410/20241011.md) |[279. Perfect Squares(完美正方形)](https://leetcode.com/problems/perfect-squares/description/)

```java
class Solution {
    public int numSquares(int n) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[n + 1];
        // 初始化
        for (int j = 0; j <= n; j++) {
            dp[j] = max;
        }
        // 当和为0时，组合的个数为0
        dp[0] = 0;
        // 遍历背包
        for (int j = 1; j <= n; j++) {
            // 遍历物品
            for (int i = 1; i * i <= j; i++) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}
```
## [20241012](./202410/20241012.md) |[300. Longest Increasing Subsequence(最长递增子序列)](https://leetcode.com/problems/longest-increasing-subsequence/)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int maxLen = 1;
        int[] dp = new int[nums.length];
        for(int i=0; i< nums.length;i++){
            dp[i] = 1;
            for(int j=0;j<i;j++){
                if(nums[j] < nums[i]){
                    dp[i] = Math.max(dp[j]+1, dp[i]);
                }
            }
            if(dp[i] > maxLen){
                maxLen = dp[i];
            }
        }
        return maxLen;
    }
}
```
## [20241013](./202410/20241013.md) |[322. Coin Change(零钱兑换)](https://leetcode.com/problems/coin-change)

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if (coins == null || coins.length == 0 || amount <= 0) {
            return 0;
        }
        int[] dp = new int[amount + 1];
        for (int i = 1; i <= amount; i++) {
            dp[i] = Integer.MAX_VALUE;
            for (int coin : coins) {
                if (i >= coin && dp[i - coin] != Integer.MAX_VALUE) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```
## [20241014](./202410/20241014.md) |[416. Partition Equal Subset Sum(分割和相等的子数组)](https://leetcode.com/problems/partition-equal-subset-sum)

```java
class Solution {
    public boolean canPartition(int[] nums) {
        if (nums == null || nums.length == 0) {
            return true;
        }
        int volumn = 0;
        for (int num : nums) {
            volumn += num;
        }
        if (volumn % 2 != 0) {
            return false;
        }
        volumn /= 2;
        boolean[] dp = new boolean[volumn + 1];
        dp[0] = true;
        for (int i = 1; i <= nums.length; i++) {
            for (int j = volumn; j >= nums[i-1]; j--) {
                dp[j] = dp[j] || dp[j - nums[i-1]];
            }
        }
        return dp[volumn];
    }
}
```
## [20241015](./202410/20241015.md) |[1143. Longest Common Subsequence(最长公共子序列)](https://leetcode.com/problems/longest-common-subsequence/)

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int len1 = text1.length();
        int len2 = text2.length();

        int[][] dp = new int[len1+1][len2+1];
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[len1][len2];
    }
}
```
# 哈希

## [20241016](./202410/20241016.md) |[1. Two Sum(两数之和)](https://leetcode.com/problems/two-sum/description/)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0; i<nums.length; i++){
            if(map.containsKey(target-nums[i])){
                return new int[]{map.get(target-nums[i]), i};
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("no solution!");
    }
}
```

## [20241017](./202410/20241017.md) |[49. Group Anagrams(字母异位词分组)](https://leetcode.com/problems/group-anagrams/description)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        if (strs == null || strs.length == 0) {
            return new ArrayList<>();
        }
        Map<String, List<String>> map = new HashMap<>();
        for (S s : strs) {
            char[] ca = new char[26];
            for (char c : s.toCharArray()){
                ca[c - 'a']++;
            }
            String keyStr = String.valueOf(ca);
            if (!map.containsKey(keyStr)) {
                map.put(keyStr, new ArrayList<>());
            }
            map.get(keyStr).add(s);
        }
        return new ArrayList<>(map.values());
    }
}
```
## [20241018](./202410/20241018.md) |[128. Longest Consecutive Sequence(最长连续子序列)](https://leetcode.com/problems/longest-consecutive-sequence/)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        int res = 0;
        // 使用map存储当前元素n的最大序列长度sum
        Map<Integer, Integer> map = new HashMap<>();
        for (int n : nums) {
            // 重复元素直接跳过
            if(map.containsKey(n)){
                continue;
            }
            // 相邻左侧节点计算左侧的最大长度(没有相邻左侧节点直接设置为0)
            int left = map.getOrDefault(n-1, 0);
            // 相邻右侧节点计算右侧最大长度
            int right = map.getOrDefault(n+1, 0);
            // 计算当前左右节点累加之后的长度sum，并保存到n中
            int sum = left + right + 1;
            map.put(n, sum);

            // 求res当前最大值
            res = Math.max(res, sum);

            // 扩大n两侧的数字范围
            // n左侧left个节点，更新为sum
            map.put(n-left, sum);
            // n右侧right个节点，更新为sum
            map.put(n+right, sum);
        }
        return res;
    }
}
```
## [20241019](./202410/20241019.md) |[560. Subarray Sum Equals K(和为K的子数组)](https://leetcode.com/problems/subarray-sum-equals-k/description/)

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int sum = 0, result = 0;
        Map<Integer, Integer> preSum = new HashMap<>();
        preSum.put(0, 1);

        for(int i=0;i<nums.length;i++){
            sum += nums[i];
            if(preSum.containsKey(sum - k)){
                result += preSum.get(sum - k);
            }
            // map[sum-k]表示在i位置之前，有多少前缀和为sum-k的子数组
            preSum.put(sum, preSum.getOrDefault(sum, 0) + 1);
        }
        return result;
    }
}
```
# 链表
## [20241020](./202410/20241020.md) |[2. Add Two Numbers(链表-两数相加)](https://leetcode.com/problems/add-two-numbers)

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1==null||l2==null) return null;
        int value1,value2=0;
        ListNode pre = new ListNode(0);
        ListNode result = pre;
        while(l1!=null&&l2!=null){
            value1 = (l1.val+l2.val+value2)%10;
            value2 = (l1.val+l2.val+value2)/10;
            pre.next = new ListNode(value1);
            pre = pre.next;
            l1 = l1.next;
            l2 = l2.next;
            if(l1 == null && l2 == null){
                break;
            }
            if(l1 == null && l2 != null){
                l1 = new ListNode(0);
            }
            if(l1 != null && l2 == null){
                l2 = new ListNode(0);
            }
        }
        if(value2>0){
            pre.next = new ListNode(value2);
        }
        return result.next;
    }
}
```
## [20241021](./202410/20241021.md) |[19. Remove Nth Node From End of List(移除链表中倒数第N个元素)](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head;
        ListNode res = new ListNode(0);
        res.next = head;
        ListNode slow = res;
        while (fast != null) {
            fast = fast.next;
            if (n-- <= 0) {
                slow = slow.next;
            }
        }
        slow.next = slow.next.next;
        return res.next;
    }
}
```
## [20241022](./202410/20241022.md) |[21. Merge Two Sorted Lists(合并两个排序链表)](https://leetcode.com/problems/merge-two-sorted-lists/)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null){
            return l2;
        }else if(l2 == null){
            return l1;
        }else if(l1.val < l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```

## [20241023](./202410/20241023.md) |[23. Merge k Sorted Lists(合并K个有序链表)](https://leetcode.com/problems/merge-k-sorted-lists/)

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return partition(lists,0,lists.length-1);
    }
    public ListNode partition(ListNode[] lists, int s ,int e){
        if(s==e){
            return lists[s];
        }
        if(s<e){
            int q = (s+e)/2;
            ListNode l1 = partition(lists, s ,q);
            ListNode l2 = partition(lists, q+1, e);
            return merge(l1,l2);
        }else{
            return null;
        }
    }
    public static ListNode merge(ListNode l1, ListNode l2){
        if(l1==null) return l2;
        if(l2==null) return l1;
        if(l1.val<l2.val){
            l1.next = merge(l1.next,l2);
            return l1;
        }else{
            l2.next = merge(l1,l2.next);
            return l2;
        }
    }
}
```
## [20241024](./202410/20241024.md) |[24. Swap Nodes in Pairs(两两交换链表的节点)](https://leetcode.com/problems/swap-nodes-in-pairs/)
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }
        ListNode next = head.next;
        head.next = swapPairs(head.next.next);
        next.next = head;
        return next;
    }
}
```
## [20241025](./202410/20241025.md) |[25. Reverse Nodes in k-Group(K组反转链表)](https://leetcode.com/problems/reverse-nodes-in-k-group/)

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode pre = dummy;
        ListNode now = head;
        int count = 0;
        while(now != null){
            ListNode next = now.next;
            count++;
            if(count == k){
                pre = reverse(pre, next);
                count = 0;
            }
            now = next;
        }
        return dummy.next;
    }

    private ListNode reverse(ListNode pre, ListNode end){
        if(pre == null || pre.next == null){
            return pre;
        }
        ListNode head = pre.next;
        ListNode now = pre.next.next;
        while(now != end){
            ListNode next = now.next;
            now.next = pre.next;
            pre.next = now;
            now = next;
        }
        head.next = end;
        return head;
    }
}
```
## [20241026](./202410/20241026.md) |[138. Copy List with Random Pointer(带随机指针Copy链表)](https://leetcode.com/problems/copy-list-with-random-pointer)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null){
            return null;
        }
        Map<Node, Node> clone = new HashMap<>();
        Node current = head;
        while(current != null){
            Node temp = new Node(current.val);
            clone.put(current, temp);
            current = current.next;
        }
        current = head;
        while(current != null){
            Node temp = clone.get(current);
            temp.next = clone.get(current.next);
            temp.random = clone.get(current.random);
            current = current.next;
        }
        return clone.get(head);
    }
}
```
## [20241027](./202410/20241027.md) |[141. Linked List Cycle(环形链表)](https://leetcode.com/problems/linked-list-cycle/description/)

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head ==null || head.next==null){
            return false;
        }
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow){
                return true;
            }
        }
        return false;
    }
}
```
## [20241028](./202410/20241028.md) |[142. Linked List Cycle II(环形链表2)](https://leetcode.com/problems/linked-list-cycle-ii/)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head==null||head.next==null){
            return null;
        }
        ListNode fast = head;
        ListNode slow = head;
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            if(fast == slow){
                break;
            }
        }
        if(fast == null || fast.next == null){
            return null;
        }
        fast = head;
        while(fast != slow){
            fast = fast.next;
            slow = slow.next;
        }

        return fast;
    }
}
```
## [20241029](./202410/20241029.md) |[146. LRU Cache(LRU缓存)](https://leetcode.com/problems/lru-cache/description/)

```java
import java.util.Hashtable;
class LRUCache {

    // 定义一个内部类，存储LRU节点
    class DLinkedNode {
      // key
      int key;
      // value
      int value;
      // 前一个节点
      DLinkedNode pre;
      // 后一个节点
      DLinkedNode post;
    }

    /**
     * Always add the new node right after head;
     */
    private void addNode(DLinkedNode node) {
       node.pre = head;
       node.post = head.post;
       head.post.pre = node;
       head.post = node;
    }

    /**
     * Remove an existing node from the linked list.
     */
    private void removeNode(DLinkedNode node){
       DLinkedNode pre = node.pre;
       DLinkedNode post = node.post;
       pre.post = post;
       post.pre = pre;
    }

    /**
     * Move certain node in between to the head.
     */
    private void moveToHead(DLinkedNode node){
      this.removeNode(node);
      this.addNode(node);
    }

    // pop the current tail.
    private DLinkedNode popTail(){
       DLinkedNode res = tail.pre;
       this.removeNode(res);
       return res;
    }

    private Hashtable<Integer, DLinkedNode> cache = new Hashtable<Integer, DLinkedNode>();
    private int count;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.count = 0;
        this.capacity = capacity;

        head = new DLinkedNode();
        head.pre = null;

        tail = new DLinkedNode();
        tail.post = null;

        head.post = tail;
        tail.pre = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if(node == null){
            // should raise exception here.
            return -1;
        }
        // move the accessed node to the head;
        this.moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if(node == null){
          DLinkedNode newNode = new DLinkedNode();
          newNode.key = key;
          newNode.value = value;
          this.cache.put(key, newNode);
          this.addNode(newNode);
          ++count;

          if(count > capacity){
            // pop the tail
            DLinkedNode tail = this.popTail();
            this.cache.remove(tail.key);
            --count;
          }
       }else{
          // update the value.
          node.value = value;
          this.moveToHead(node);
       }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```
## [20241030](./202410/20241030.md) |[148. Sort List(链表排序)](https://leetcode.com/problems/sort-list/)

```java
import java.util.Collections;

class Solution {
    public ListNode sortList(ListNode head) {
        ListNode sorted = null;
        ListNode   = null;
        List<ListNode> list = new ArrayList<>();
        while(head!=null){
            list.add(new ListNode(head.val));
            head = head.next;
        }

        Collections.sort(list, new Comparator<ListNode>(){
            @Override
            public int compare(ListNode o1, ListNode o2){
                return o1.val-o2.val;
            }
        });

        for(ListNode node:list){
            if(sorted==null){
                sorted = node;
                sRef = sorted;
            }else{
                sRef.next = node;
                sRef = sRef.next;
            }
        }
        return sorted;
    }
}
```

## [20241031](./202410/20241031.md) |[160. Intersection of Two Linked Lists(两个链表的交集)](https://leetcode.com/problems/intersection-of-two-linked-lists/)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        //boundary check
        if(headA == null || headB == null) return null;

        ListNode a = headA;
        ListNode b = headB;

        //if a & b have different len, then we will stop the loop after second iteration
        while( a != b){
            //for the end of first iteration, we just reset the pointer to the head of another linkedlist
            a = a == null? headB : a.next;
            b = b == null? headA : b.next;    
        }

        return a;
    }
}
```
## [20241101](./202411/20241101.md) |[206. Reverse Linked List(反转链表)](https://leetcode.com/problems/reverse-linked-list/description/)

```java
class Solution {
    public ListNode reverseList(ListNode head){
        if(head == null || head.next == null){
            return head;
        }
        ListNode pre = null;
        ListNode now = head;
        while(now != null){
            ListNode next = now.next;
            now.next = pre;
            pre = now;
            now = next;
        }
        return pre;
    }
}
```
## [20241102](./202411/20241102.md) |[234. Palindrome Linked List(回文链表)](https://leetcode.com/problems/palindrome-linked-list/description)

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head, slow = head;
        while(fast!=null && fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
        }
        // odd nodes: let right half smaller
        if (fast != null) {
            slow = slow.next;
        }
        slow = reverse(slow);
        fast = head;
        while(slow != null){
            if(slow.val != fast.val){
                return false;
            }
            slow = slow.next;
            fast = fast.next;
        }
        return true;
    }
    private ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode now = head;
        while(now != null){
            ListNode next = now.next;
            now.next = pre;
            pre = now;
            now = next;
        }
        return pre;
    }
}
```

# 图

## [20241103](./202411/20241103.md) |[200. Number of Islands(图-岛屿的数量)](https://leetcode.com/problems/number-of-islands/)

```java
class Solution {
    private final char LAND = '1';
    private final char WATER = '0';
    private char[][] arr;
    public int numIslands(char[][] grid) {
        arr = grid;
        int nums = 0;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == LAND){
                    nums++;
                    dfs(i,j);
                }
            }
        }
        return nums;
    }
    private void dfs(int rows, int cols){
        // check if current rows is out of bound
        if(rows<0||rows>arr.length-1){
            return;
        }
        // check if current cols is out of bound
        if(cols<0||cols>arr[0].length-1){
            return;
        }
        // WATER or LAND
        if(arr[rows][cols]==WATER){
            return;
        }
        arr[rows][cols] = WATER;
        dfs(rows+1, cols);
        dfs(rows-1, cols);
        dfs(rows, cols+1);
        dfs(rows, cols-1);
    }
}
```

## [20241104](./202411/20241104.md) |[207. Course Schedule(课程计划)](https://leetcode.com/problems/course-schedule/)

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if(numCourses <= 0)
        	return false;
        Queue<Integer> queue = new LinkedList<Integer>();
        int[] inDegree = new int[numCourses];
        for(int i = 0; i < prerequisites.length; i++) inDegree[prerequisites[i][0]]++;
        for(int i = 0; i < numCourses; i++){
        	if(inDegree[i] == 0){
        		queue.offer(i); // find the start courses
        	}
        }
        // begin traverse
        while(!queue.isEmpty()){
        	int startCourse = queue.poll();
        	for(int i = 0; i < prerequisites.length; i++){
        		if(startCourse == prerequisites[i][1]){
        			if(--inDegree[prerequisites[i][0]] == 0){
        				queue.offer(prerequisites[i][0]);
        			}
        		}
        	}
        }
        for(int i =0; i < numCourses; i++){
        	if(inDegree[i] !=0) return false;
        }
        return true;
    }
}
```
## [20241105](./202411/20241105.md) |[994. Rotting Oranges(腐烂的橘子)](https://leetcode.com/problems/rotting-oranges/description/)

```java
class Solution {
    public int orangesRotting(int[][] grid) {
      if(grid == null || grid.length == 0) return 0;
        int rows = grid.length;
        int cols = grid[0].length;
        Queue<int[]> queue = new LinkedList<>();
        int count_fresh = 0;
        //Put the position of all rotten oranges in queue
        //count the number of fresh oranges
        for(int i = 0 ; i < rows ; i++) {
            for(int j = 0 ; j < cols ; j++) {
                if(grid[i][j] == 2) {
                    queue.offer(new int[]{i , j});
                }
                else if(grid[i][j] == 1) {
                    count_fresh++;
                }
            }
        }
        //if count of fresh oranges is zero --> return 0
        if(count_fresh == 0) return 0;
        int count = 0;
        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};
        //bfs starting from initially rotten oranges
        while(!queue.isEmpty()) {
            ++count;
            int size = queue.size();
            for(int i = 0 ; i < size ; i++) {
                int[] point = queue.poll();
                for(int dir[] : dirs) {
                    int x = point[0] + dir[0];
                    int y = point[1] + dir[1];
                    //if x or y is out of bound
                    //or the orange at (x , y) is already rotten
                    //or the cell at (x , y) is empty
                        //we do nothing
                    if(x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2) continue;
                    //mark the orange at (x , y) as rotten
                    grid[x][y] = 2;
                    //put the new rotten orange at (x , y) in queue
                    queue.offer(new int[]{x , y});
                    //decrease the count of fresh oranges by 1
                    count_fresh--;
                }
            }
        }
        return count_fresh == 0 ? count-1 : -1;  
    }
}
```
# 贪心算法

## [20241106](./202411/20241106.md) |[45. Jump Game II(贪心算法-跳跃游戏2)](https://leetcode.com/problems/jump-game-ii/)

```java
class Solution {
    public int jump(int[] nums) {
        int result = 0, curMax = 0, max = 0;
        for (int i = 0; i < nums.length - 1; i++) {
            max = Math.max(max, i + nums[i]);
            if(i == curMax){
                result ++;
                curMax = max;
            }
        }
        return result;
    }
}
```
## [20241107](./202411/20241107.md) |[55. Jump Game(跳跃游戏)](https://leetcode.com/problems/jump-game/)

```java
class Solution {
    public boolean canJump(int[] nums) {
        int last = nums.length-1;
        for(int i=last; i>=0; i--){
            if(nums[i] + i >= last){
                last = i;
            }
        }
        return last==0;
    }
}
```
## [20241108](./202411/20241108.md) |[121. Best Time to Buy and Sell Stock(买卖股票的最佳时机)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0){
            return 0;
        }
        int global = 0;
        int min = prices[0];
        for(int i = 1; i < prices.length; i++){
            min = Math.min(min, prices[i]);
            if(prices[i] > min){
                global = Math.max(global, prices[i] - min);
            }
        }
        return global;
    }
}
```
## [20241109](./202411/20241109.md) |[763. Partition Labels(划分区间)](https://leetcode.com/problems/partition-labels/description/)

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> list = new LinkedList<>();
        int[] edge = new int[26];
        char[] chars = S.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            edge[chars[i] - 'a'] = i;
        }
        int idx = 0;
        int last = -1;
        for (int i = 0; i < chars.length; i++) {
            idx = Math.max(idx,edge[chars[i] - 'a']);
            if (i == idx) {
                list.add(i - last);
                last = i;
            }
        }
        return list;
    }
}
```

# 堆
## [20241110](./202411/20241110.md) |[215. Kth Largest Element in an Array(数组中第K个最大元素)](https://leetcode.com/problems/kth-largest-element-in-an-array/)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int n = nums.length, low = 0, high = n-1;
        while(low<=high){
           int x = partition(nums, low, high);
           if(n-x == k){
               return nums[x];
           }else if(n-x < k){
               high = x-1;
           }else{
               low = x+1;
           }
        }
        return low;
    }

    private int partition(int[] nums, int low, int high){
        int i = low;
        int j = high;
        int povit = nums[i];
        while(i < j){
            while(i < j && povit < nums[j]){
                j--;
            }
            if(i < j){
                nums[i] = nums[j];
                nums[j] = povit;
                i++;
            }
            while(i < j && povit > nums[i]){
                i++;
            }
            if(i < j){
                nums[j] = nums[i];
                nums[i] = povit;
                j--;
            }
        }
        return i;
    }
}
```

## [20241111](./202411/20241111.md) |[295. Find Median from Data Stream(发现数据流中的中位数)](https://leetcode.com/problems/find-median-from-data-stream/)


```java
class MedianFinder {

    List<Integer> list;

    public MedianFinder() {
        this.list = new ArrayList<Integer>();
    }

    public void addNum(int num) {
        if(list.size() == 0){
            list.add(0, num);  
        }else{
            int i=0;
            while(list.get(i) <= num && i<list.size()-1) i++;
            //*****The reason why I didn't traversed till the last index was to escape from IndexOutOfBounds Error*****
            if(list.get(i) <= num){
                list.add(i+1, num);
            }else{
                list.add(i, num);
            }
        }
    }

    public double findMedian() {
        int n = list.size();
        if(n == 0) return 0;
        if(n%2 == 1) return list.get(n/2);
        return (double)((list.get(n/2) + list.get(n/2 - 1)))/2;
    }
}
```
## [20241112](./202411/20241112.md) |[347. Top K Frequent Elements(TopK个频率的元素)](https://leetcode.com/problems/top-k-frequent-elements/description)

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        List<Integer>[] bucket = new List[nums.length + 1];
        Map<Integer, Integer> frequencyMap = new HashMap<Integer, Integer>();

        for (int n : nums) {
            frequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);
        }

        for (int key : frequencyMap.keySet()) {
            int frequency = frequencyMap.get(key);
            if (bucket[frequency] == null) {
                bucket[frequency] = new ArrayList<>();
            }
            bucket[frequency].add(key);
        }

        List<Integer> res = new ArrayList<>();
        for (int pos = bucket.length - 1; pos >= 0 && res.size() < k; pos--) {
            if (bucket[pos] != null) {
                res.addAll(bucket[pos]);
            }
        }

        int[] result = new int[res.size()];
        for(int i=0; i<res.size();i++){
            result[i] = res.get(i);
        }
        return result;
    }
}
```
# 矩阵
## [20241113](./202411/20241113.md) |[48. Rotate Image(旋转图像)](https://leetcode.com/problems/rotate-image/description/)

```java
class Solution {
    public void rotate(int[][] matrix) {
        for(int i = 0; i<matrix.length; i++){
            for(int j = i; j<matrix[0].length; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        for(int i =0 ; i<matrix.length; i++){
            for(int j = 0; j<matrix.length/2; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.length-1-j];
                matrix[i][matrix.length-1-j] = temp;
            }
        }
    }
}
```
## [20241114](./202411/20241114.md) |[54. Spiral Matrix(螺旋矩阵)](https://leetcode.com/problems/spiral-matrix/description)

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<Integer>();
        if(matrix.length==0){
            return res;
        }
        int rowBegin = 0;
        int rowEnd = matrix.length-1;
        int colBegin = 0;
        int colEnd = matrix[0].length - 1;
        while (rowBegin <= rowEnd && colBegin <= colEnd){
            // Traverse Right
            for (int j = colBegin; j <= colEnd; j ++) {
                res.add(matrix[rowBegin][j]);
            }
            rowBegin++;

            // Traverse Down
            for (int j = rowBegin; j <= rowEnd; j ++) {
                res.add(matrix[j][colEnd]);
            }
            colEnd--;

            if (rowBegin <= rowEnd) {
                // Traverse Left
                for (int j = colEnd; j >= colBegin; j --) {
                    res.add(matrix[rowEnd][j]);
                }
            }
            rowEnd--;

            if (colBegin <= colEnd) {
                // Traver Up
                for (int j = rowEnd; j >= rowBegin; j --) {
                    res.add(matrix[j][colBegin]);
                }
            }
            colBegin++;
        }
        return res;
    }
}
```
## [20241115](./202411/20241115.md) |[73. Set Matrix Zeroes(设置矩阵零)](https://leetcode.com/problems/set-matrix-zeroes/)

```java
class Solution {
    public void setZeroes(int[][] matrix) {
         if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;
         int m = matrix.length, n = matrix[0].length;
        // 第一行和第一列是否存在0
         boolean row = false, col = false;
        // 设置开始的行和列是0，并且标记行列为true
         for (int i = 0; i < m; i++){
             for (int j = 0; j < n; j++){
                 if (matrix[i][j] == 0) {
                     matrix[0][j] = 0;
                     matrix[i][0] = 0;
                     if (i == 0) row = true;
                     if (j == 0) col = true;
                 }
             }
         }
         // 设置行为0
         for (int i = 1; i < m; i++){
             if (matrix[i][0] == 0){
                 for (int j = 1; j < n;j++)
                     matrix[i][j] = 0;
             }
         }
         // 设置列为0
         for (int j = 1; j < n; j++){
             if (matrix[0][j] == 0){
                 for (int i = 1; i < m; i++)
                     matrix[i][j] = 0;
             }
         }
         if (row){
             for (int j = 0; j < n; j++)
                 matrix[0][j] = 0;
         }
         if (col){
             for(int i = 0; i < m; i++)
                 matrix[i][0] = 0;
         }
    }
}
```
## [20241116](./202411/20241116.md) |[240. Search a 2D Matrix II(二维矩阵的查找)](https://leetcode.com/problems/search-a-2d-matrix-ii)

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0){
            return false;
        }
        int left = 0;
        int right = matrix[0].length - 1;
        while(left<matrix.length && right>=0){
            if(matrix[left][right] == target){
                return true;
            }else if(matrix[left][right] < target){
                left++;
            }else{
                right--;
            }
        }
        return false;
    }
}
```
# 滑动窗口
## [20241117](./202411/20241117.md) |[3. Longest Substring Without Repeating Characters(无重复字符的最长子串)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s==null||s.length()==0){
            return 0;
        }
        int max = 0;
        Map<Character, Integer> map = new HashMap<>();
        int j = 0;
        for(int i=0;i<s.length();i++){
            if(map.containsKey(s.charAt(i))){
                j = Math.max(j, map.get(s.charAt(i)) + 1);
            }
            map.put(s.charAt(i), i);
            max = Math.max(max, i-j+1);
        }
        return max;
    }
}
```
## [20241118](./202411/20241118.md) |[76. Minimum Window Substring(最小区间子串)](https://leetcode.com/problems/minimum-window-substring/description)

```java
class Solution {
    public String minWindow(String s, String t) {
        // 特殊情况直接返回
        if(s == null || t == null || s.length() == 0 || t.length() == 0 || s.length() < t.length()) {
            return "";
        }

        // 构造模型
        int minLeft = 0;
        int minRight = 0;
        int min = s.length();
        boolean flag = false;

        Map<Character, Integer> map = new HashMap<>();
        int count = t.length(); // 记录t中需要匹配的字符数
        for(char c : t.toCharArray()){
           map.put(c, map.getOrDefault(c, 0) + 1);   
        }

        // 滑动窗口解决问题
        int i = 0;
        int j = 0;
        while(j < s.length()){
            char c = s.charAt(j);
            if(map.containsKey(c)){
                map.put(c, map.get(c) - 1);
                // 如果仍然有未匹配的字符，count-1
                if(map.get(c) >= 0) count--;
            }

            // 如果发现了一个子串
            while(count == 0 && i <= j){
                // 更新全局最小值
                flag = true;
                int curLen = j + 1 - i;
                if(curLen <= min){
                    minLeft = i;
                    minRight = j;
                    min = curLen;
                }

                // 收缩左侧滑动窗口
                char leftC = s.charAt(i);
                if(map.containsKey(leftC)){
                    map.put(leftC, map.get(leftC) + 1);
                    if(map.get(leftC) >= 1) count++;
                }
                i++;
            }
            j++;
        }

        return flag == true ? s.substring(minLeft, minRight + 1): "";
    }
}
```
## [20241119](./202411/20241119.md) |[239. Sliding Window Maximum(滑动窗口最大值)](https://leetcode.com/problems/sliding-window-maximum/)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
      if(nums == null || nums.length < 2) return nums;
        // 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序
        LinkedList<Integer> queue = new LinkedList();
        // 结果数组
        int[] result = new int[nums.length-k+1];
        // 遍历nums数组
        for(int i = 0;i < nums.length;i++){
            // 保证从大到小 如果前面数小则需要依次弹出，直至满足要求
            while(!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]){
                queue.pollLast();
            }
            // 添加当前值对应的数组下标
            queue.addLast(i);
            // 判断当前队列中队首的值是否有效
            if(queue.peek() <= i-k){
                queue.poll();   
            }
            // 当窗口长度为k时 保存当前窗口中最大值
            if(i+1 >= k){
                result[i+1-k] = nums[queue.peek()];
            }
        }
        return result;
    }
}
```
## [20241120](./202411/20241120.md) |[438. Find All Anagrams in a String(找出字符串中所有的变位词)](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        ArrayList<Integer> result = new ArrayList<>();
        if(s==null||p==null) return result;
        int left =0,right =0,count =p.length();
        int[] map = new int[256];
        char[] sc = s.toCharArray();
        for(char c:p.toCharArray()) map[c]++;
        while(right<s.length()) {
        	if(map[sc[right++]]-->=1)count--;
        	if(count==0)result.add(left);
        	if(right-left==p.length()&&map[sc[left++]]++>=0) count++;
        }
        return result;
    }
}
```
# 栈
## [20241121](./202411/20241121.md) |[20. Valid Parentheses(有效括号匹配)](https://leetcode.com/problems/valid-parentheses/)

```java
class Solution {
    public boolean isValid(String s) {
        if(s==null||s.length()==0){
            return true;
        }
        Stack<Character> stack = new Stack<>();
        for(char c: s.toCharArray()){
            if(c == '('){
                stack.push(')');
            }else if(c == '['){
                stack.push(']');
            }else if(c == '{'){
                stack.push('}');
            }else if(stack.isEmpty() || c != stack.pop()){
                return false;
            }
        }
        return stack.isEmpty();
    }
}
```
## [20241122](./202411/20241122.md) |[84. Largest Rectangle in Histogram(柱状图中的最大矩形)](https://leetcode.com/problems/largest-rectangle-in-histogram/)

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int size = heights.length;
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        int max = 0;
        for (int i = 0; i < size; ++i){
            while (stack.peek() != -1 && heights[i] < heights[stack.peek()]){
                int h = heights[stack.pop()];
                int w = i - stack.peek() - 1;
                max = Math.max(max, w * h);
            }
            stack.push(i);
        }

        while (stack.peek() != -1){
            int h = heights[stack.pop()];
            int w = size - stack.peek() - 1;
            max = Math.max(max, w * h);
        }
        return max;
    }
}
```
## [20241123](./202411/20241123.md) |[155. Min Stack(最小栈)](https://leetcode.com/problems/min-stack/description/)

```java
class MinStack {

    private Stack<Integer> stack = new Stack<>();
    private Stack<Integer> minStack = new Stack<>();

    /** initialize your data structure here. */
    public MinStack() {

    }

    public void push(int val) {
        if(minStack.isEmpty() || val<= minStack.peek()){
            minStack.push(val);
        }
        stack.push(val);
    }

    public void pop() {
       if(stack.peek().equals(minStack.peek())){
           minStack.pop();
       }
        stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```
## [20241124](./202411/20241124.md) |[394. Decode String(解码字符串)](https://leetcode.com/problems/decode-string/description/)

```java
class Solution {
    public String decodeString(String s) {
        String res = "";
        Stack<Integer> countStack = new Stack<>();
        Stack<String> resStack  = new Stack<>();
        int index = 0;
        while (index < s.length()) {
            if(Character.isDigit(s.charAt(index))){
                int count = 0;
                while(Character.isDigit(s.charAt(index))){
                    count = count * 10 + (s.charAt(index) - '0');
                    index++;
                }
                countStack.push(count);
            }else if(s.charAt(index) == '['){
                resStack.push(res);
                res = "";
                index++;
            }else if(s.charAt(index) == ']'){
                StringBuilder temp = new StringBuilder(resStack.pop());
                int repeatTimes = countStack.pop();
                while(repeatTimes-->0){
                    temp.append(res);
                }
                res = temp.toString();
                index++;
            }else{
                res += s.charAt(index++);
            }
        }
        return res;
    }
}
```
## [20241125](./202411/20241125.md) |[739. Daily Temperatures(每日温度)](https://leetcode.com/problems/daily-temperatures/description/)

```java
class Solution {
    public int[] dailyTemperatures(int[] T) {
        int[] result = new int[T.length];
        Stack<Integer> stack = new Stack<>();
        for(int i = 0 ; i<T.length; i++){
            while(!stack.isEmpty() && T[stack.peek()] < T[i]){
                result[stack.peek()] = i - stack.pop();
            }
            stack.push(i);
        }
        return result;
    }
}
```
# 双指针
## [20241126](./202411/20241126.md) |[11. Container With Most Water(盛满水的最大容器)](https://leetcode.com/problems/container-with-most-water/)

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int max = 0;
        while(left < right){
            int w = right - left;
            int h = Math.min(height[left], height[right]);
            int area = w * h;
            max = Math.max(area, max);
            if(height[left] < height[right]){
                left ++;
            }else if(height[left] > height[right]){
                right--;
            }else{
                left ++;
                right--;
            }
        }
        return max;
    }
}
```
## [20241127](./202411/20241127.md) |[15. 3Sum(三数之和)](https://leetcode.com/problems/3sum/)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            // 重复元素不在计算
            if(i>0 && nums[i]==nums[i-1]){
                continue;
            }
            for(int j=i+1, k=nums.length-1;j<k;){
                if(nums[i]+nums[j]+nums[k]==0){
                    list.add(Arrays.asList(nums[i],nums[j],nums[k]));
                    j++;
                    k--;
                    while(j<k&&nums[j-1]==nums[j]){
                        j++;
                    }
                    while(j<k&&nums[k+1]==nums[k]){
                        k--;
                    }
                }else if(nums[i]+nums[j]+nums[k]<0){
                        j++;
                }else{
                        k--;
                }
            }
        }
        return list;
    }
}
```
## [20241128](./202411/20241128.md) |[42. Trapping Rain Water(接雨水)](https://leetcode.com/problems/trapping-rain-water/)
```java
class Solution {
    public int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int res = 0, maxleft = 0, maxright = 0;
        while (left <= right) {
            if(height[left] <= height[right]){
                if(height[left] > maxleft){
                    maxleft = height[left];
                }else{
                    res += maxleft - height[left];
                }
                left++;
            }else{
                if(height[right] > maxright){
                    maxright = height[right];
                }else{
                    res += maxright - height[right];
                }
                right--;
            }
        }
        return res;
    }
}
```
## [20241129](./202411/20241129.md) |[283. Move Zeroes(移动零)](https://leetcode.com/problems/move-zeroes/)
```java
class Solution {
    public void moveZeroes(int[] nums) {
        int snowBallSize = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i] == 0){
                snowBallSize ++;
            }else{
                int temp = nums[i];
                nums[i-snowBallSize] = temp;
                nums[i] = 0;
            }
        }
    }
}
```
## [20241130](./202411/20241130.md) |[208. Implement Trie (Prefix Tree)(实现前缀树)](https://leetcode.com/problems/implement-trie-prefix-tree/)

```java
class Trie {

    TrieNode root;

    /** Initialize your data structure here. */
    public Trie() {
        root = new TrieNode();
    }

    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode temp = root;
        for(char c:word.toCharArray()){
            int i = c-'a';
            if(temp.children[i]==null){
                TrieNode newNode=new TrieNode();
                temp.children[i]=newNode;
            }
            temp=temp.children[i];
        }
        temp.end=true;
    }

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode temp= root;
        for(char c: word.toCharArray()){
             int i=c-'a';
             if(temp.children[i]==null){
                 return false;
             }
             temp=temp.children[i];       
        }
        return temp.end;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        TrieNode temp= root;
        for(char c: prefix.toCharArray()){
             int i=c-'a';
             if(temp.children[i]==null){
                 return false;
             }
             temp=temp.children[i];   
        }
        return temp!=null;
    }

    static class TrieNode{
        TrieNode[] children=new TrieNode[26];
        boolean end = false;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```
# 其他
## [20241201](./202412/20241201.md) |[31. Next Permutation(下一个排列)](https://leetcode.com/problems/next-permutation/description/)

```java
class Solution {
    public void nextPermutation(int[] nums) {
        if(nums == null || nums.length <= 1){
            return;
        }
        int i = nums.length - 2;
        while(i >= 0 && nums[i] >= nums[i + 1]) i--; // Find 1st id i that breaks descending order
        if(i >= 0) {                                 // If not entirely descending
            int j = nums.length - 1;                 // Start from the end
            while(nums[j] <= nums[i]) j--;           // Find rightmost first larger id j
            swap(nums, i, j);                        // Switch i and j
        }
        reverse(nums, i + 1, nums.length - 1);       // Reverse the descending sequence
    }

    public void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    public void reverse(int[] nums, int i, int j) {
        while(i < j){
          swap(nums, i++, j--);
        }
    }
}
```
## [20241202](./202412/20241202.md) |[41. First Missing Positive(发现第一个缺失的正数)](https://leetcode.com/problems/first-missing-positive/)
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for(int i = 0; i < n; i++) {
            while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])
                swap(nums, i, nums[i] - 1);
        }
        for(int i = 0; i < n; i++)
            if(nums[i] != i + 1)
                return i + 1;
        return n + 1;
    }
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```
## [20241203](./202412/20241203.md) |[53. Maximum Subarray(最大子段和)](https://leetcode.com/problems/maximum-subarray/description/)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums==null||nums.length==0){
            return 0;
        }
        int sum = nums[0];
        int max = sum;
        for(int i = 1;i<nums.length;i++){
            if(sum + nums[i] < nums[i]){
                sum = nums[i];
            }else{
                sum += nums[i];
            }
            max = Math.max(max, sum);
        }
        return max;
    }
}
```
## [20241204](./202412/20241204.md) |[56. Merge Intervals(区间交集)](https://leetcode.com/problems/merge-intervals/description/)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length <= 1)
			return intervals;

		// Sort by ascending starting point
		Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));

		List<int[]> result = new ArrayList<>();
		int[] newInterval = intervals[0];
		result.add(newInterval);
		for (int[] interval : intervals) {
			if (interval[0] <= newInterval[1]) // Overlapping intervals, move the end if needed
				newInterval[1] = Math.max(newInterval[1], interval[1]);
			else {                             // Disjoint intervals, add the new interval to the list
				newInterval = interval;
				result.add(newInterval);
			}
		}

		return result.toArray(new int[result.size()][]);
    }
}
```
## [20241205](./202412/20241205.md) |[75. Sort Colors(三色排序)](https://leetcode.com/problems/sort-colors/description/)

```java
class Solution {
    public void sortColors(int[] nums) {
        int len = nums.length;
        if(len < 2){
            return;
        }

        int left = 0;
        int right = len - 1;
        int current = 0;
        while(current <= right) {
            if(nums[current] == 0){
                swap(nums, left, current);
                left++;
                current++;
            }else if(nums[current] == 1) {
                current++;
            }else {
                swap(nums, right, current);
                right--;
            }
        }
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```
## [20241206](./202412/20241206.md) |[136. Single Number(单一数字)](https://leetcode.com/problems/single-number/)
```java
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for(int i=0; i<nums.length; i++){
            result ^= nums[i];
        }
        return result;
    }
}
```
## [20241207](./202412/20241207.md) |[169. Majority Element(主要元素)](https://leetcode.com/problems/majority-element)

```java
class Solution {

    public int majorityElement(int[] nums) {
        quickSort(nums, 0, nums.length-1);
        return nums[nums.length/2];
    }

    public int majorityElement3(int[] nums) {
        int count = 0;
        Integer candidate = null;
        for(int num : nums){
            if(count == 0){
                candidate = num;
            }
            count += (num==candidate) ? 1 : -1;
        }
        return candidate;
    }

    public int majorityElement2(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        int result = -1;
        for(int i=0;i<nums.length;i++){
            map.put(nums[i], map.containsKey(nums[i])? map.get(nums[i])+ 1 : 0);
            if(map.get(nums[i]) >= nums.length/2){
                return nums[i];
            }
        }
        return result;
    }

    public void quickSort(int[] nums, int begin, int end){
        if(begin < end){
            int pivot = nums[begin];
            int i = begin;
            int j = end;
            while(i < j){
                while(i<j && pivot < nums[j]){
                    j--;
                }
                if(i<j){
                    nums[i] = nums[j];
                    nums[j] = pivot;
                    i++;
                }
                while(i<j && nums[i] < pivot){
                    i++;
                }
                if(i<j){
                    nums[j] = nums[i];
                    nums[i] = pivot;
                    j--;
                }
            }
            quickSort(nums, begin, i-1);
            quickSort(nums, i+1, end);
        }
    }
}
```
## [20241208](./202412/20241208.md) |[189. Rotate Array(旋转数组)](https://leetcode.com/problems/rotate-array/description/)

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums, 0, nums.length-1);
        reverse(nums, 0, k-1);
        reverse(nums, k, nums.length-1);
    }

    private void reverse(int[] nums, int begin, int end){
        while(begin < end){
            int temp = nums[begin];
            nums[begin] = nums[end];
            nums[end] = temp;
            begin ++;
            end --;
        }
    }

}
```
## [20241209](./202412/20241209.md) |[238. Product of Array Except Self(除自身以外数组的乘积)](https://leetcode.com/problems/product-of-array-except-self)
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] leftProducts = new int[n];
        int[] rightProducts = new int[n];
        int[] result = new int[n];

        // Calculate left products
        leftProducts[0] = 1;
        for (int i = 1; i < n; i++) {
            leftProducts[i] = leftProducts[i - 1] * nums[i - 1];
        }

        // Calculate right products
        rightProducts[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            rightProducts[i] = rightProducts[i + 1] * nums[i + 1];
        }

        // Calculate the final result
        for (int i = 0; i < n; i++) {
            result[i] = leftProducts[i] * rightProducts[i];
        }

        return result;
    }
}
```
## [20241210](./202412/20241210.md) |[287. Find the Duplicate Number(发现重复出现的元素)](https://leetcode.com/problems/find-the-duplicate-number/)
```java
class Solution {
    public int findDuplicate(int[] nums) {
        int[] duplicate = new int[nums.length];
        for(int i = 0; i< nums.length;i++){
            duplicate[nums[i]] ++;
        }
        for(int i = 0; i< duplicate.length;i++){
            if(duplicate[i] > 1){
                return i;
            }
        }
        return -1;
    }
}
```
