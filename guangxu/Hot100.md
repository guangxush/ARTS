| 标题 | Algorithm |
| - | - |
| [20240902](./202409/20240902.md) |[17. Letter Combinations of a Phone Number(回溯法-电话号码的字母组合)](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)|
| [20240903](./202409/20240903.md) |[22. Generate Parentheses(合法括号)](https://leetcode.com/problems/generate-parentheses/)|
| [20240904](./202409/20240904.md) |[39. Combination Sum(组合总和)](https://leetcode.com/problems/combination-sum/description)|
| [20240905](./202409/20240905.md) |[46. Permutations(排列)](https://leetcode.com/problems/permutations/description/)|
| [20240906](./202409/20240906.md) |[51. N-Queens(N皇后)](https://leetcode.com/problems/n-queens/description)|
| [20240907](./202409/20240907.md) |[78. Subsets(子集)](https://leetcode.com/problems/subsets)|
| [20240908](./202409/20240908.md) |[79. Word Search(单词查找)](https://leetcode.com/problems/word-search)|
| [20240909](./202409/20240909.md) |[131. Palindrome Partitioning(分割回文串)](https://leetcode.com/problems/palindrome-partitioning/description)|
| [20240911](./202409/20240911.md) |[4. Median of Two Sorted Arrays(二分查找-两个排序数组的中位数)](https://leetcode.com/problems/median-of-two-sorted-arrays/)|
| [20240912](./202409/20240912.md) |[33. Search in Rotated Sorted Array(旋转数组二分查找)](https://leetcode.com/problems/search-in-rotated-sorted-array)|
| [20240913](./202409/20240913.md) |[34. Find First and Last Position of Element in Sorted Array(查找排序数组中元素的第一个和最后一个位置)](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)|
| [20240914](./202409/20240914.md) |[35. Search Insert Position(寻找插入的位置)](https://leetcode.com/problems/search-insert-position/)|
| [20240915](./202409/20240915.md) |[74. Search a 2D Matrix(二维数组的查找)](https://leetcode.com/problems/search-a-2d-matrix/description/)|
| [20240916](./202409/20240916.md) |[124. Binary Tree Maximum Path Sum(二叉树的最大路径和)](https://leetcode.com/problems/binary-tree-maximum-path-sum/description)|
| [20240917](./202409/20240917.md) |[153. Find Minimum in Rotated Sorted Array(旋转排序数组中的最小值)](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)|
| [20240918](./202409/20240918.md) |[94. Binary Tree Inorder Traversal(二叉树的中序遍历)](https://leetcode.com/problems/binary-tree-inorder-traversal)|
| [20240919](./202409/20240919.md) |[98. Validate Binary Search Tree(有效的二叉搜索树)](https://leetcode.com/problems/validate-binary-search-tree)|
| [20240920](./202409/20240920.md) |[101. Symmetric Tree(对称树)](https://leetcode.com/problems/symmetric-tree/description)|
| [20240921](./202409/20240921.md) |[102. Binary Tree Level Order Traversal(二叉树的层次遍历)](https://leetcode.com/problems/binary-tree-level-order-traversal/description)|
| [20240922](./202409/20240922.md) |[104. Maximum Depth of Binary Tree(二叉树的最大深度)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description)|
| [20240923](./202409/20240923.md) |[105. Construct Binary Tree from Preorder and Inorder Traversal(根据前序和中序构造二叉树)](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)|
| [20241211](./202412/20241211.md) |[108. Convert Sorted Array to Binary Search Tree(排序数组转换成二叉搜索树)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)|
| [20240924](./202409/20240924.md) |[114. Flatten Binary Tree to Linked List(二叉树转换成单链表)](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)|
| [20240925](./202409/20240925.md) |[199. Binary Tree Right Side View(二叉树的右视图)](https://leetcode.com/problems/binary-tree-right-side-view/description)|
| [20240926](./202409/20240926.md) |[226. Invert Binary Tree(旋转二叉树)](https://leetcode.com/problems/invert-binary-tree/description/)|
| [20240927](./202409/20240927.md) |[230. Kth Smallest Element in a BST(二叉搜索树的第K个最小元素)](https://leetcode.com/problems/kth-smallest-element-in-a-bst)|
| [20240928](./202409/20240928.md) |[236. Lowest Common Ancestor of a Binary Tree(二叉树的最近公共祖先)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)|
| [20240929](./202409/20240929.md) |[437. Path Sum III(路径和3)](https://leetcode.com/problems/path-sum-iii/description)|
| [20240930](./202409/20240930.md) |[543. Diameter of Binary Tree(二叉树的直径)](https://leetcode.com/problems/diameter-of-binary-tree/)|
| [20241001](./202410/20241001.md) |[5. Longest Palindromic Substring(动态规划-最长回文子串)](https://leetcode.com/problems/longest-palindromic-substring/description)|
| [20241002](./202410/20241002.md) |[32. Longest Valid Parentheses(最长有效括号)](https://leetcode.com/problems/longest-valid-parentheses/description)|
| [20241003](./202410/20241003.md) |[62. Unique Paths(不同的路径)](https://leetcode.com/problems/unique-paths/description)|
| [20241004](./202410/20241004.md) |[64. Minimum Path Sum(最小路径和)](https://leetcode.com/problems/minimum-path-sum/description)|
| [20241005](./202410/20241005.md) |[70. Climbing Stairs(爬梯子)](https://leetcode.com/problems/climbing-stairs/description/)|
| [20241006](./202410/20241006.md) |[72. Edit Distance(编辑距离)](https://leetcode.com/problems/edit-distance/)|
| [20241007](./202410/20241007.md) |[118. Pascal's Triangle(杨辉三角)](https://leetcode.com/problems/pascals-triangle/description)|
| [20241008](./202410/20241008.md) |[139. Word Break(单词拆分)](https://leetcode.com/problems/word-break/)|
| [20241009](./202410/20241009.md) |[152. Maximum Product Subarray(乘积最大的子数组)](https://leetcode.com/problems/maximum-product-subarray/)|
| [20241010](./202410/20241010.md) |[198. House Robber(打家劫舍)](https://leetcode.com/problems/house-robber/description)|
| [20241011](./202410/20241011.md) |[279. Perfect Squares(完美正方形)](https://leetcode.com/problems/perfect-squares/description/)|
| [20241012](./202410/20241012.md) |[300. Longest Increasing Subsequence(最长递增子序列)](https://leetcode.com/problems/longest-increasing-subsequence/)|
| [20241013](./202410/20241013.md) |[322. Coin Change(零钱兑换)](https://leetcode.com/problems/coin-change)|
| [20241014](./202410/20241014.md) |[416. Partition Equal Subset Sum(分割和相等的子数组)](https://leetcode.com/problems/partition-equal-subset-sum)|
| [20241015](./202410/20241015.md) |[1143. Longest Common Subsequence(最长公共子序列)](https://leetcode.com/problems/longest-common-subsequence/)|
| [20241016](./202410/20241016.md) |[1. Two Sum(哈希-两数之和)](https://leetcode.com/problems/two-sum/description/)|
| [20241017](./202410/20241017.md) |[49. Group Anagrams(字母异位词分组)](https://leetcode.com/problems/group-anagrams/description)|
| [20241018](./202410/20241018.md) |[128. Longest Consecutive Sequence(最长连续子序列)](https://leetcode.com/problems/longest-consecutive-sequence/)|
| [20241019](./202410/20241019.md) |[560. Subarray Sum Equals K(和为K的子数组)](https://leetcode.com/problems/subarray-sum-equals-k/description/)|
| [20241020](./202410/20241020.md) |[2. Add Two Numbers(链表-两数相加)](https://leetcode.com/problems/add-two-numbers)|
| [20241021](./202410/20241021.md) |[19. Remove Nth Node From End of List(移除链表中倒数第N个元素)](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)|
| [20241022](./202410/20241022.md) |[21. Merge Two Sorted Lists(合并两个排序链表)](https://leetcode.com/problems/merge-two-sorted-lists/)|
| [20241023](./202410/20241023.md) |[23. Merge k Sorted Lists(合并K个有序链表)](https://leetcode.com/problems/merge-k-sorted-lists/)|
| [20241024](./202410/20241024.md) |[24. Swap Nodes in Pairs(两两交换链表的节点)](https://leetcode.com/problems/swap-nodes-in-pairs/)|
| [20241025](./202410/20241025.md) |[25. Reverse Nodes in k-Group(K组反转链表)](https://leetcode.com/problems/reverse-nodes-in-k-group/)|
| [20241026](./202410/20241026.md) |[138. Copy List with Random Pointer(带随机指针Copy链表)](https://leetcode.com/problems/copy-list-with-random-pointer)|
| [20241027](./202410/20241027.md) |[141. Linked List Cycle(环形链表)](https://leetcode.com/problems/linked-list-cycle/description/)|
| [20241028](./202410/20241028.md) |[142. Linked List Cycle II(环形链表2)](https://leetcode.com/problems/linked-list-cycle-ii/)|
| [20241029](./202410/20241029.md) |[146. LRU Cache(LRU缓存)](https://leetcode.com/problems/lru-cache/description/)|
| [20241030](./202410/20241030.md) |[148. Sort List(链表排序)](https://leetcode.com/problems/sort-list/)|
| [20241031](./202410/20241031.md) |[160. Intersection of Two Linked Lists(两个链表的交集)](https://leetcode.com/problems/intersection-of-two-linked-lists/)|
| [20241101](./202411/20241101.md) |[206. Reverse Linked List(反转链表)](https://leetcode.com/problems/reverse-linked-list/description/)|
| [20241102](./202411/20241102.md) |[234. Palindrome Linked List(回文链表)](https://leetcode.com/problems/palindrome-linked-list/description)|
| [20241103](./202411/20241103.md) |[200. Number of Islands(图-岛屿的数量)](https://leetcode.com/problems/number-of-islands/)|
| [20241104](./202411/20241104.md) |[207. Course Schedule(课程计划)](https://leetcode.com/problems/course-schedule/)|
| [20241105](./202411/20241105.md) |[994. Rotting Oranges(腐烂的橘子)](https://leetcode.com/problems/rotting-oranges/description/)|
| [20241106](./202411/20241106.md) |[45. Jump Game II(贪心算法-跳跃游戏2)](https://leetcode.com/problems/jump-game-ii/)|
| [20241107](./202411/20241107.md) |[55. Jump Game(跳跃游戏)](https://leetcode.com/problems/jump-game/)|
| [20241108](./202411/20241108.md) |[121. Best Time to Buy and Sell Stock(买卖股票的最佳时机)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)|
| [20241109](./202411/20241109.md) |[763. Partition Labels(划分区间)](https://leetcode.com/problems/partition-labels/description/)|
| [20241110](./202411/20241110.md) |[215. Kth Largest Element in an Array(堆-数组中第K个最大元素)](https://leetcode.com/problems/kth-largest-element-in-an-array/)|
| [20241111](./202411/20241111.md) |[295. Find Median from Data Stream(发现数据流中的中位数)](https://leetcode.com/problems/find-median-from-data-stream/)|
| [20241112](./202411/20241112.md) |[347. Top K Frequent Elements(TopK个频率的元素)](https://leetcode.com/problems/top-k-frequent-elements/description)|
| [20241113](./202411/20241113.md) |[48. Rotate Image(矩阵-旋转图像)](https://leetcode.com/problems/rotate-image/description/)|
| [20241114](./202411/20241114.md) |[54. Spiral Matrix(螺旋矩阵)](https://leetcode.com/problems/spiral-matrix/description)|
| [20241115](./202411/20241115.md) |[73. Set Matrix Zeroes(设置矩阵零)](https://leetcode.com/problems/set-matrix-zeroes/)|
| [20241116](./202411/20241116.md) |[240. Search a 2D Matrix II(二维矩阵的查找)](https://leetcode.com/problems/search-a-2d-matrix-ii)|
| [20241117](./202411/20241117.md) |[3. Longest Substring Without Repeating Characters(滑动窗口-无重复字符的最长子串)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)|
| [20241118](./202411/20241118.md) |[76. Minimum Window Substring(最小区间子串)](https://leetcode.com/problems/minimum-window-substring/description)|
| [20241119](./202411/20241119.md) |[239. Sliding Window Maximum(滑动窗口最大值)](https://leetcode.com/problems/sliding-window-maximum/)|
| [20241120](./202411/20241120.md) |[438. Find All Anagrams in a String(找出字符串中所有的变位词)](https://leetcode.com/problems/find-all-anagrams-in-a-string/)|
| [20241121](./202411/20241121.md) |[20. Valid Parentheses(栈-有效括号匹配)](https://leetcode.com/problems/valid-parentheses/)|
| [20241122](./202411/20241122.md) |[84. Largest Rectangle in Histogram(柱状图中的最大矩形)](https://leetcode.com/problems/largest-rectangle-in-histogram/)|
| [20241123](./202411/20241123.md) |[155. Min Stack(最小栈)](https://leetcode.com/problems/min-stack/description/)|
| [20241124](./202411/20241124.md) |[394. Decode String(解码字符串)](https://leetcode.com/problems/decode-string/description/)|
| [20241125](./202411/20241125.md) |[739. Daily Temperatures(每日温度)](https://leetcode.com/problems/daily-temperatures/description/)|
| [20241126](./202411/20241126.md) |[11. Container With Most Water(双指针-盛满水的最大容器)](https://leetcode.com/problems/container-with-most-water/)|
| [20241127](./202411/20241127.md) |[15. 3Sum(三数之和)](https://leetcode.com/problems/3sum/)|
| [20241128](./202411/20241128.md) |[42. Trapping Rain Water(接雨水)](https://leetcode.com/problems/trapping-rain-water/)|
| [20241129](./202411/20241129.md) |[283. Move Zeroes(移动零)](https://leetcode.com/problems/move-zeroes/)|
| [20241130](./202411/20241130.md) |[208. Implement Trie (Prefix Tree)(实现前缀树)](https://leetcode.com/problems/implement-trie-prefix-tree/)|
| [20241201](./202412/20241201.md) |[31. Next Permutation(其他-下一个排列)](https://leetcode.com/problems/next-permutation/description/)|
| [20241202](./202412/20241202.md) |[41. First Missing Positive(发现第一个缺失的正数)](https://leetcode.com/problems/first-missing-positive/)|
| [20241203](./202412/20241203.md) |[53. Maximum Subarray(最大子段和)](https://leetcode.com/problems/maximum-subarray/description/)|
| [20241204](./202412/20241204.md) |[56. Merge Intervals(区间交集)](https://leetcode.com/problems/merge-intervals/description/)|
| [20241205](./202412/20241205.md) |[75. Sort Colors(三色排序)](https://leetcode.com/problems/sort-colors/description/)|
| [20241206](./202412/20241206.md) |[136. Single Number(单一数字)](https://leetcode.com/problems/single-number/)|
| [20241207](./202412/20241207.md) |[169. Majority Element(主要元素)](https://leetcode.com/problems/majority-element)|
| [20241208](./202412/20241208.md) |[189. Rotate Array(旋转数组)](https://leetcode.com/problems/rotate-array/description/)|
| [20241209](./202412/20241209.md) |[238. Product of Array Except Self(除自身以外数组的乘积)](https://leetcode.com/problems/product-of-array-except-self)|
| [20241210](./202412/20241210.md) |[287. Find the Duplicate Number(发现重复出现的元素)](https://leetcode.com/problems/find-the-duplicate-number/)|

------

# 回溯法

## [20240902](./202409/20240902.md) |[17. Letter Combinations of a Phone Number(电话号码的字母组合)](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

解决思路
```
数字映射先记牢，回溯递归三步走；选择递归再撤销，终止条件添结果。
示例：输入 "23"
      2
    / | \
   a  b  c
  /|\ /|\ /|\
 3(d e f)...
根到叶子路径：ad, ae, af, bd, be, bf, cd, ce, cf。
回溯三步曲：
1. 选择：将当前字母加入组合（append）。
2. 递归：处理下一个数字（start+1）。
3. 撤销：移除最后添加的字母（deleteCharAt），尝试其他可能。
```
答案
```Java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> list = new LinkedList<>();
        if(digits == null || digits.length() == 0) {
            return list;
        }
        char[][] map = {{},{},{'a','b','c'},{'d','e','f'},{'g','h','i'},{'j','k','l'},{'m','n','o'},{'p','q','r','s'},{'t','u','v'},{'w','x','y','z'}};
        backtrack(digits,list,map,new StringBuilder(),0);
        return list;
    }
    private void backtrack(String digits, List<String> list, char[][] map, StringBuilder result, int start){
        if(start == digits.length()){
            list.add(new String(result));
            return;
        }
        int num = digits.charAt(start) - '0';
        for(int i = 0; i < map[num].length; i++){
            result.append(map[num][i]);
            backtrack(digits, list, map, result, start+1);
            result.deleteCharAt(result.length() - 1);
        }
    }
}
```

框架
```
回溯框架：
private void backtrack(参数) {
    // 终止条件：组合长度等于输入数字长度
    if (start == digits.length()) {
        list.add(result.toString());
        return;
    }
    // 遍历当前数字对应的所有字母
    int num = digits.charAt(start) - '0';
    for (int i = 0; i < map[num].length; i++) {
        result.append(map[num][i]);        // 选择当前字母
        backtrack(start + 1);               // 递归处理下一个数字
        result.deleteCharAt(result.length() - 1); // 回溯，撤销选择
    }
}
```

## [20240903](./202409/20240903.md) |[22. Generate Parentheses(合法括号)](https://leetcode.com/problems/generate-parentheses/)

解决思路
```
1. 如果左括号数量未达n，添加左括号并递归。
2. 如果右括号数量少于左括号，添加右括号并递归。
3. 当字符串长度等于2n时，添加到结果列表。
优先填充左括号，动态平衡右括号
```
答案
```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> list = new ArrayList<>();
        backtrack(list,"",0,0,n);
        return list;
    }
    public void backtrack(List<String> list, String result, int left, int right, int n){
        if(result.length() == n * 2){
            list.add(result);
            return;
        }
        if(left < n){
            backtrack(list,result+"(",left+1,right,n);
        }
        if(right < left){
            backtrack(list,result+")",left,right+1,n);
        }
    }
}
```

## [20240904](./202409/20240904.md) |[39. Combination Sum(组合总和)](https://leetcode.com/problems/combination-sum/description)

解决思路
```
(1) 类比排列组合问题‌
● ‌组合总和‌：允许重复 → 递归传 i。
● ‌组合总和II‌（不可重复）→ 递归传 i+1，并跳过重复元素。
● ‌子集问题‌ → 无目标和限制，直接收集所有路径。
‌(2) 模板化代码‌
将代码分为三大块：
1. ‌预处理‌：排序。
2. ‌回溯入口‌：初始化并启动递归。
3. ‌回溯核心‌：
  ○ 终止条件（记录结果或返回）。
  ○ 循环遍历候选元素，做选择 → 递归 → 撤销选择。
```
答案
```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        // 1. 排序（便于剪枝和去重）
        Arrays.sort(candidates);

        // 2. 初始化结果容器
        List<List<Integer>> res = new ArrayList<>();

        // 3. 启动回溯
        backtrack(res, new ArrayList<>(), candidates, target, 0);
        return res;
    }

    private void backtrack(List<List<Integer>> res, List<Integer> path, int[] nums, int remain, int start) {
        // 终止条件
        if (remain < 0)
            return;
        if (remain == 0) {
            res.add(new ArrayList<>(path));
            return;
        }

        // 遍历选择
        for (int i = start; i < nums.length; i++) {
            // 剪枝优化：提前终止无效分支（需先排序）
            if (nums[i] > remain)
                break;
            // 做选择
            path.add(nums[i]);
            // 递归（允许重复，故传i而非i+1）
            backtrack(res, path, nums, remain - nums[i], i);
            // 撤销选择
            path.remove(path.size() - 1);
        }
    }
}
```

## [20240905](./202409/20240905.md) |[46. Permutations(排列)](https://leetcode.com/problems/permutations/description/)

解决思路
```
● 时间复杂度：O(N×N!)O(N×N!)，共有 N!N! 种排列，每次生成需 O(N)O(N) 时间复制数组。
● 空间复杂度：O(N)O(N) 递归栈深度，结果存储为 O(N×N!)O(N×N!)。
```

答案
```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(nums, 0, result);
        return result;
    }

    private void backtrack(int[] nums, int start, List<List<Integer>> result) {
        // 终止条件：所有位置已固定，保存当前排列
        if (start == nums.length) {
            List<Integer> permutation = new ArrayList<>();
            for (int num : nums) permutation.add(num);
            result.add(permutation);
            return;
        }
        // 从当前start位置开始，尝试每个可能的元素
        for (int i = start; i < nums.length; i++) {
            swap(nums, i, start);      // 将i位置元素固定到start位置
            backtrack(nums, start + 1, result); // 递归处理下一个位置
            swap(nums, i, start);      // 回溯：恢复数组状态
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## [20240906](./202409/20240906.md) |[51. N-Queens(N皇后)](https://leetcode.com/problems/n-queens/description)

解决思路
```
1. 初始化棋盘‌：必须用'.'填充所有位置。
2. ‌逐列放置‌：每次递归处理下一列（colIndex + 1），而非逐行。
3. ‌验证范围‌：只需检查当前列左侧的已放置皇后。
4. ‌回溯撤销操作‌：递归返回后必须恢复棋盘状态。
```

答案
```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        char[][] board = new char[n][n];
        for (int i = 0; i < n; i++)
            Arrays.fill(board[i], '.'); // 初始化棋盘为全空
        List<List<String>> res = new ArrayList<>();
        backtrack(board, 0, res); // 从第0列开始回溯
        return res;
    }

    private void backtrack(char[][] board, int colIndex, List<List<String>> res) {
        if (colIndex == board.length) { // 终止条件：所有列已放置皇后
            res.add(construct(board)); // 记录合法解
            return;
        }
        for (int row = 0; row < board.length; row++) { // 尝试在当前列的每一行放置皇后
            if (validate(board, row, colIndex)) { // 验证当前位置是否合法
                board[row][colIndex] = 'Q'; // 放置皇后
                backtrack(board, colIndex + 1, res); // 递归处理下一列
                board[row][colIndex] = '.'; // 回溯：撤销当前选择
            }
        }
    }

    private boolean validate(char[][] board, int x, int y) {
        for (int i = 0; i < board.length; i++) { // 遍历所有行
            for (int j = 0; j < y; j++) { // 遍历已处理的列（j < y）
                if (board[i][j] == 'Q') {
                    // 检查行冲突（x == i）或对角线冲突
                    // 1. 同一行‌：x == i（已有皇后在第i行）。
                    // 2. 左上对角线‌：x - y == i - j（从左上到右下的斜线）
                    // 3. 右上对角线‌：x + y == i + j（从右上到左下的斜线）
                    if (x == i || x + y == i + j || x - y == i - j) {
                        return false; // 冲突：当前位置不可放置
                    }
                }
            }
        }
        return true; // 无冲突：当前位置合法
    }

    private List<String> construct(char[][] board) {
        List<String> res = new LinkedList<String>();
        for (char[] row : board) {
            res.add(new String(row)); // 将每一行转换为字符串
        }
        return res;
    }
}
```

## [20240907](./202409/20240907.md) |[78. Subsets(子集)](https://leetcode.com/problems/subsets)

解决思路
```
排序数组（虽然当前题目可能不需要，但如果有重复元素时需要）。
初始空集：首次进入 backtrack 时，path 为空，直接添加到结果。
遍历起始点：循环从 start 开始，避免重复组合（如 [1,2] 和 [2,1]）。
路径保存：必须通过 new ArrayList<>(path) 创建副本，防止后续修改影响结果。
递归与回溯：递归后需移除最后一个元素，恢复状态以尝试其他分支。
```
答案
```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(nums);
        backtrack(list, new ArrayList<>(), nums, 0);
        return list;
    }

    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start){
        list.add(new ArrayList<>(tempList));
        for(int i=start;i<nums.length;i++){
            tempList.add(nums[i]);
            backtrack(list, tempList, nums, i+1);
            tempList.remove(tempList.size()-1);
        }
    }
}
```

## [20240908](./202409/20240908.md) |[79. Word Search(单词查找)](https://leetcode.com/problems/word-search)
解决思路
```
1. 终止条件‌：处理成功或失败的情况。
2. ‌剪枝‌：越界、已访问、字符不匹配直接返回。
3. ‌标记访问‌：visited[x][y] = true。
4. ‌递归方向‌：循环四个方向，递归尝试。
5. ‌回溯‌：撤销访问标记。
```
答案
```java
class Solution {
    int[][] dirs = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };

    public boolean exist(char[][] board, String word) {
        if (board == null || board.length == 0 || board[0].length == 0)
            return false;
        int m = board.length, n = board[0].length;
        boolean[][] visited = new boolean[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(board, visited, i, j, 0, word)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean dfs(char[][] board, boolean[][] visited, int x, int y, int index, String word) {
        // 终止条件
        if (index == word.length())
            return true; // 所有字符匹配完成
        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length)
            return false; // 越界
        if (visited[x][y] || board[x][y] != word.charAt(index))
            return false; // 已访问或字符不匹配

        // 标记已访问
        visited[x][y] = true;

        // 递归四个方向
        for (int[] dir : dirs) {
            int x1 = x + dir[0], y1 = y + dir[1];
            if (dfs(board, visited, x1, y1, index + 1, word)) {
                return true;
            }
        }

        // 回溯：撤销标记
        visited[x][y] = false;
        return false;
    }
}
```

## [20240909](./202409/20240909.md) |[131. Palindrome Partitioning(分割回文串)](https://leetcode.com/problems/palindrome-partitioning/description)

解决思路
```
回溯算法‌（DFS + 剪枝），每次分割需保证当前子串是回文。
```

答案
```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<>();
        if (s.length() == 0) {
            return res;
        }
        backtrack(res, new ArrayList<>(), s);
        return res;
    }

    public void backtrack(List<List<String>> res, List<String> path, String s) {
        if (s.isEmpty()) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < s.length(); i++) {
            // 遍历所有分割点
            String sub = s.substring(0, i + 1);
            if (isPalindrome(sub)) {
                // 剪枝：当前子串是回文
                path.add(sub);
                // 递归剩余部分
                backtrack(res, path, s.substring(i + 1));
                // 撤销选择
                path.remove(path.size() - 1);
            }
        }
    }

    private boolean isPalindrome(String s) {
        for (int i = 0; i < s.length() / 2; i++) {
            if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {
                return false;
            }
        }
        return true;
    }
}
```

# 二分查找

## [20240911](./202409/20240911.md) |[4. Median of Two Sorted Arrays(两个排序数组的中位数)](https://leetcode.com/problems/median-of-two-sorted-arrays/)

思路
```
目标：找到合并后的有序数组的中位数。
关键思想：中位数是第 k 小的数（或两个数的平均），而无需实际合并数组。
策略：通过比较两个数组的中间值，每次排除一定不可能包含第k小元素的部分，逐步缩小搜索范围。
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
● 一定中位：计算中位数的两个位置 l 和 r。
● 二找k：递归寻找第 k 小元素。
● 三比：比较两个数组的第 k/2 个元素。
● 四排：排除较小元素所在数组的前 k/2 个元素。
● 五递归：调整起始位置和 k 值，递归求解。
问题转化：将中位数问题转化为寻找两个有序数组中第 k 小的数。
递归函数 getKth 逻辑：
1. 边界处理：
  ○ 如果数组 A 的起始位置已越界（aStart >= A.length），则第 k 小元素必然在数组 B 中，直接返回 B[bStart + k - 1]。
  ○ 同理，若 B 越界，返回 A[aStart + k - 1]。
  ○ 如果 k==1，直接返回 A[aStart] 和 B[bStart] 中的较小者。
2. 计算中间值：
  ○ 分别在 A 和 B 中找第 k/2 个元素（若越界则设为极大值 Integer.MAX_VALUE）。
3. 排除不可能的部分：
  ○ 比较 A 和 B 的中间值 aMid 和 bMid。
  ○ 若 aMid < bMid：说明 A 的前 k/2 个元素不可能包含第 k 小的数（因为它们比 aMid 还小，而 aMid 已经小于 bMid，最多只能排到第 k-1 小）。因此，排除 A 的前 k/2 个元素，将 aStart 移动到 aStart + k/2，并递归寻找剩余的第 k - k/2 小元素。
  ○ 若 bMid ≤ aMid：同理，排除 B 的前 k/2 个元素，继续递归。
```
代码
```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        int l = (m + n + 1) / 2; // 左中位数位置
        int r = (m + n + 2) / 2; // 右中位数位置
        // 平均处理奇偶情况
        return (getKth(nums1, 0, nums2, 0, l) + getKth(nums1, 0, nums2, 0, r)) / 2.0;
    }

    // 寻找两个数组中第k小的元素
    private int getKth(int[] A, int aStart, int[] B, int bStart, int k) {
        // 边界处理：当某个数组已全排除
        if (aStart >= A.length) return B[bStart + k - 1];
        if (bStart >= B.length) return A[aStart + k - 1];
        // 递归终止：k=1时直接比较当前最小
        if (k == 1) return Math.min(A[aStart], B[bStart]);

        // 计算两个数组的第k/2个元素（处理越界）
        int aMid = (aStart + k/2 - 1 < A.length) ? A[aStart + k/2 - 1] : Integer.MAX_VALUE;
        int bMid = (bStart + k/2 - 1 < B.length) ? B[bStart + k/2 - 1] : Integer.MAX_VALUE;

        // 排除较小者的前k/2个元素
        if (aMid < bMid) {
            return getKth(A, aStart + k/2, B, bStart, k - k/2);
        } else {
            return getKth(A, aStart, B, bStart + k/2, k - k/2);
        }
    }
}
```

## [20240912](./202409/20240912.md) |[33. Search in Rotated Sorted Array(旋转数组二分查找)](https://leetcode.com/problems/search-in-rotated-sorted-array)


```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right-left)/2;
            if(nums[mid] == target){
                return mid;
            }
            if(nums[mid] < nums[right]){ // 右半有序
                if(nums[mid] < target && target <= nums[right]){
                    left = mid + 1; // 向右搜
                }else{
                    right = mid - 1;// 向左搜
                }
            }else{  // 左半有序
                if(nums[left] <= target && target < nums[mid]){
                    right = mid -1;// 向左搜
                }else{
                    left = mid + 1; // 向右搜
                }
            }
        }
        return -1;
    }
}
```

## [20240913](./202409/20240913.md) |[34. Find First and Last Position of Element in Sorted Array(查找排序数组中元素的第一个和最后一个位置)](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)

方法
```
1. 初始化res为[-1,-1]，处理空数组的情况。
2. 初始化start和end为数组的首尾索引。
3. 进入循环，条件是nums[start] < nums[end]。这个条件可能用于在数组中存在多个target时继续调整范围。
4. 计算mid，判断mid处的值与target的大小关系：
  ○ 如果mid值小于target，说明target在右半部分，移动start到mid+1。
  ○ 如果mid值大于target，说明target在左半部分，移动end到mid-1。
  ○ 如果等于target，则调整start和end：
    ■ 如果start处的元素小于target，start右移。
    ■ 如果end处的元素大于target，end左移。
5. 循环结束后，检查start处的元素是否等于target，如果是，则设置res的左右边界为start和end。
6. 返回res。
```
代码
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] res = new int[] { -1, -1 };
        if (nums == null || nums.length == 0) {
            return res;
        }
        int start = 0, end = nums.length - 1;
        while (nums[start] < nums[end]) {
            int mid = start + (end - start) / 2;
            if (nums[mid] < target) {
                start = mid + 1;
            } else if (nums[mid] > target) {
                end = mid - 1;
            } else {
                if (nums[start] < target) {
                    start++;
                }
                if (nums[end] > target) {
                    end--;
                }
            }
        }
        if (nums[start] == target) {
            res[0] = start;
            res[1] = end;
        }
        return res;
    }
}
```

## [20240914](./202409/20240914.md) |[35. Search Insert Position(寻找插入的位置)](https://leetcode.com/problems/search-insert-position/)

```
二分找左界，等于也左移，返回左指针。
● 循环条件：left <= right
● 计算mid
● 如果mid的值等于target，则调整right=mid-1，继续找左半部分
● 如果mid的值小于target，调整left=mid+1
● 如果mid的值大于target，调整right=mid-1
● 最后返回left的位置
```
代码
```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;  // 防止溢出
            if (nums[mid] == target) {
                right = mid - 1;  // 向左收缩，找更左的相同值（若存在）
            } else if (nums[mid] < target) {
                left = mid + 1;    // 目标在右半部分
            } else {
                right = mid - 1;   // 目标在左半部分
            }
        }
        return left;  // 最终 left 指向第一个 >= target 的位置
    }
}
```

## [20240915](./202409/20240915.md) |[74. Search a 2D Matrix(二维数组的查找)](https://leetcode.com/problems/search-a-2d-matrix/description/)


```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int i = 0;
        int j = matrix[0].length-1;
        while(i>=0 && i<matrix.length && j>=0 && j<matrix[0].length){
            if(matrix[i][j] == target){
                return true;
            }else if(matrix[i][j] < target){
                i++;
            }else if(matrix[i][j] > target){
                j--;
            }
        }
        return false;
    }
}
```


## [20240916](./202409/20240916.md) |[124. Binary Tree Maximum Path Sum(二叉树的最大路径和)](https://leetcode.com/problems/binary-tree-maximum-path-sum/description)

```
1. 递归后序遍历：从叶子节点向上计算每个节点的贡献值。
2. 贡献值定义：节点值 + 左右子树中较大的非负贡献值（若子树贡献为负则舍弃）。
3. 全局最大值更新：对于每个节点，计算其作为根节点的路径和（左贡献 + 右贡献 + 节点值），更新全局最大值。
```
代码
```java
class Solution {

    private int maxValue = Integer.MIN_VALUE;;

    public int maxPathSum(TreeNode root){
        maxPathDown(root);
        return maxValue;
    }

    private int maxPathDown(TreeNode node) {
        if(node == null){
            return 0;
        }
        int left = Math.max(0, maxPathDown(node.left));
        int right = Math.max(0, maxPathDown(node.right));
        maxValue = Math.max(maxValue, left + right + node.val);
        return Math.max(left, right) + node.val;
    }
}
```

## [20240917](./202409/20240917.md) |[153. Find Minimum in Rotated Sorted Array(旋转排序数组中的最小值)](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

```
1. 先判单元素和未旋转‌：直接返回首元素。
2. ‌二分查找找断点‌：检查 mid 与相邻元素。
3. ‌左半有序向右找‌：若 mid 值≥首元素，向右搜索。
4. ‌右半有序向左找‌：否则向左搜索。
```
代码
```java
class Solution {
    public int findMin(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        int left = 0, right = nums.length - 1;
        if (nums[right] > nums[0]) {
            return nums[0];
        }
        while (right >= left) {
            int mid = left + (right - left)/2;
            if(nums[mid] > nums[mid+1]){
                return nums[mid+1];
            }
            if(nums[mid-1] > nums[mid]){
                return nums[mid];
            }
            if(nums[0] < nums[mid]){
                left = mid + 1;
            }else{
                right = mid -1;
            }
        }
        return Integer.MAX_VALUE;
    }
}
```
# 二叉树
## [20240918](./202409/20240918.md) |[94. Binary Tree Inorder Traversal(二叉树的中序遍历)](https://leetcode.com/problems/binary-tree-inorder-traversal)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            while(root != null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            result.add(root.val);
            root = root.right;
        }
        return result;
    }

    public void inorder(TreeNode root, List<Integer> result){
        if(root == null){
            return;
        }
        inorder(root.left, result);
        result.add(root.val);
        inorder(root.right, result);
    }
}
```

前序遍历

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        if(root == null){
            return new ArrayList<>();
        }
        stack.push(root);
        while(!stack.isEmpty()){
            root = stack.pop();
            result.add(root.val);
            if(root.right != null){
                stack.push(root.right);
            }
            if(root.left != null){
                stack.push(root.left);
            }
        }
        return result;
    }

    public void preOrder(List<Integer> result, TreeNode root){
        if(root == null){
            return;
        }
        result.add(root.val);
        preOrder(result, root.left);
        preOrder(result, root.right);
    }
}
```

后序遍历

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> stack = new Stack<>();
        if(root == null){
            return new LinkedList<>();
        }
        stack.push(root);
        while(!stack.isEmpty()){
            root = stack.pop();
            result.add(0, root.val);
            if(root.left != null){
                stack.push(root.left);
            }
            if(root.right != null){
                stack.push(root.right);
            }
        }
        return result;
    }

    public void postOrder(List<Integer> result, TreeNode root){
        if(root == null){
            return;
        }
        postOrder(result, root.left);
        postOrder(result, root.right);
        result.add(root.val);
    }
}
```
## [20240919](./202409/20240919.md) |[98. Validate Binary Search Tree(有效的二叉搜索树)](https://leetcode.com/problems/validate-binary-search-tree)

```
● ‌左子树递归‌：dfs(root.left, min, root.val)
左子节点的合法区间是 (min < left.val < root.val)。
  ○ min 继承父节点的下限，保证左子树所有节点值大于父节点的下限。
  ○ root.val 作为新的上限，保证左子树所有节点值小于当前节点值。
● ‌右子树递归‌：dfs(root.right, root.val, max)
右子节点的合法区间是 (root.val < right.val < max)。
  ○ root.val 作为新的下限，保证右子树所有节点值大于当前节点值。
  ○ max 继承父节点的上限，保证右子树所有节点值小于父节点的上限。
```
代码
```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null){
            return true;
        }
        return dfs(root,Long.MIN_VALUE,Long.MAX_VALUE);
    }

    boolean dfs(TreeNode root,long min,long max){
        // 当前节点为空直接返回true
        if(root == null){
            return true;
        }
        // 当前节点比min或者left节点小，或者当前节点比right节点大，返回false
        if(root.val<=min||root.val>=max){
            return false;
        }
        // 递归执行(left，min, 根结点) &&(right，根结点, max)
        return dfs(root.left,min,(int)root.val)&&
            dfs(root.right,(int)root.val,max);
    }
}
```

## [20240920](./202409/20240920.md) |[101. Symmetric Tree(对称树)](https://leetcode.com/problems/symmetric-tree/description)

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null){
            return true;
        }
        if(root.left==null && root.right==null){
            return true;
        }
        return isSamed(root.left, root.right);
    }
    public boolean isSamed(TreeNode left, TreeNode right){
        if(left == null && right == null){
            return true;
        }
        if(left == null && right != null){
            return false;
        }
        if(left != null && right == null){
            return false;
        }
        if(left.val != right.val){
            return false;
        }
        return isSamed(left.left, right.right) && isSamed(left.right, right.left);
    }
}
```

## [20240921](./202409/20240921.md) |[102. Binary Tree Level Order Traversal(二叉树的层次遍历)](https://leetcode.com/problems/binary-tree-level-order-traversal/description)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> lists = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList();
        if(root==null){
            return lists;
        }
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i=0;i<size;i++){
                root = queue.poll();
                if(root.left != null){
                    queue.add(root.left);
                }
                if(root.right != null){
                    queue.add(root.right);
                }
                list.add(root.val);
            }
            lists.add(list);
        }
        return lists;
    }
}
```
## [20240922](./202409/20240922.md) |[104. Maximum Depth of Binary Tree(二叉树的最大深度)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description)

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) +1;
    }
}
```
## [20240923](./202409/20240923.md) |[105. Construct Binary Tree from Preorder and Inorder Traversal(根据前序和中序构造二叉树)](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || inorder == null || preorder.length == 0 || inorder.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[0]);
        for (int i = 0; i < inorder.length; i++) {
            if (preorder[0] == inorder[i]) {
                root.left = buildTree(Arrays.copyOfRange(preorder, 1, i + 1),
                        Arrays.copyOfRange(inorder, 0, i));
                root.right = buildTree(Arrays.copyOfRange(preorder, i + 1, preorder.length),
                        Arrays.copyOfRange(inorder, i + 1, inorder.length));
            }
        }
        return root;
    }
}
```

中序和后序

```Java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if(inorder==null||postorder==null||inorder.length==0||postorder.length==0){
            return null;
        }
        TreeNode treeNode = new TreeNode(postorder[postorder.length-1]);
        for(int i = 0; i<inorder.length; i++){
            if(inorder[i] == postorder[postorder.length-1]){
                treeNode.left = buildTree(Arrays.copyOfRange(inorder, 0, i), Arrays.copyOfRange(postorder, 0, i));
                treeNode.right = buildTree(Arrays.copyOfRange(inorder, i+1, inorder.length), Arrays.copyOfRange(postorder, i, postorder.length-1));
            }
        }
        return treeNode;
    }
}
```

## [20241211](./202412/20241211.md) |[108. Convert Sorted Array to Binary Search Tree(排序数组转换成二叉搜索树)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)

```
1. 中间为根，左右分治‌：中间元素作为根，递归处理左右子数组。
2. ‌终止空数组，返回null‌：当 low > high 时，子数组为空。
3. ‌防溢取中值，索引要精准‌：用 mid = low + (high - low)/2 而非 (low + high)/2 避免整数溢出。
```
代码
```Java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
         return buildTree(nums, 0 , nums.length-1);
    }
    public TreeNode buildTree(int[] nums, int low, int high){
        if(low > high){
            return null;
        }
        int mid = low + (high-low)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildTree(nums, low, mid-1);
        root.right = buildTree(nums, mid+1, high);
        return root;
    }
}
```

## [20240924](./202409/20240924.md) |[114. Flatten Binary Tree to Linked List(二叉树转换成单链表)](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)

```
1. 找到左子树的最右节点（即左子树最后一个被访问的节点）。
2. 将原右子树接到最右节点的右指针。
3. 将左子树移到右子树位置，左指针置空。
4. 向右子节点移动，重复上述过程。
把左子树的最右节点连接到根的右节点，再把根的右子树连接改成左子树，根移动到右节点，依次循环到null也就是右子树的底部
简单方式：前序遍历
```
代码
```java
class Solution {
    public void flatten(TreeNode root) {
        while (root != null) {
            if (root.left != null) { // 左子树存在才处理
                TreeNode cur = root.left;
                while (cur.right != null) { // 找到左子树的最右节点
                    cur = cur.right;
                }
                cur.right = root.right; // 原右子树接到最右节点
                root.right = root.left; // 左子树变为右子树
                root.left = null; // 左指针置空
            }
            root = root.right; // 移动到下一个节点
        }
    }
}

class Solution {
    public void flatten(TreeNode root) {
        List<TreeNode> list = new ArrayList<TreeNode>();
        preorderTraversal(root, list);
        int size = list.size();
        for (int i = 1; i < size; i++) {
            TreeNode prev = list.get(i - 1), curr = list.get(i);
            prev.left = null;
            prev.right = curr;
        }
    }

    public void preorderTraversal(TreeNode root, List<TreeNode> list) {
        if (root != null) {
            list.add(root);
            preorderTraversal(root.left, list);
            preorderTraversal(root.right, list);
        }
    }
}
```
## [20240925](./202409/20240925.md) |[199. Binary Tree Right Side View(二叉树的右视图)](https://leetcode.com/problems/binary-tree-right-side-view/description)

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null){
          return list;
        }
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i=0; i<size; i++){
                TreeNode node = queue.poll();
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                if(i == size-1){
                    list.add(node.val);
                }
            }
        }
        return list;
    }
}
```
## [20240926](./202409/20240926.md) |[226. Invert Binary Tree(旋转二叉树)](https://leetcode.com/problems/invert-binary-tree/description/)

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null){
            return root;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```
## [20240927](./202409/20240927.md) |[230. Kth Smallest Element in a BST(二叉搜索树的第K个最小元素)](https://leetcode.com/problems/kth-smallest-element-in-a-bst)

```
BST中序遍历是升序
‌栈存左子尽，弹出判k值‌
左尽则退栈，右转再左压‌
中序迭代法，k减到零停‌
```
代码
```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        while(true){
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            if(stack.isEmpty()){
                break;
            }
            root = stack.pop();
            if(--k==0){
                return root.val;
            }
            root = root.right;
        }
        return 0;
    }
}
```

中序遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            while(root != null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            result.add(root.val);
            root = root.right;
        }
        return result;
    }

    public void inorder(TreeNode root, List<Integer> result){
        if(root == null){
            return;
        }
        inorder(root.left, result);
        result.add(root.val);
        inorder(root.right, result);
    }
}
```
## [20240928](./202409/20240928.md) |[236. Lowest Common Ancestor of a Binary Tree(二叉树的最近公共祖先)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

```
if (lca1 != null && lca2 != null)‌ 表示 p 和 q 分别位于当前节点的左右子树中，当前节点是它们的 LCA。
递归设计‌：通过分解问题（左右子树）和合并结果（判断 LCA 位置），高效定位最近公共祖先。
● 递归终止条件：处理空节点或找到目标节点。
● 左右子树递归：分解问题到左右子树。
● 结果合并逻辑：
  ○ 左右均非空 → 当前为 LCA。
  ○ 一侧非空 → 返回该侧结果，继续传递可能的 LCA。
```
代码
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null){
            return null;
        }
        if(root.val==p.val || root.val==q.val){
            return root;
        }
        TreeNode lca1 = lowestCommonAncestor(root.left, p, q);
        TreeNode lca2 = lowestCommonAncestor(root.right, p, q);
        if(lca1!=null && lca2!=null){
            return root;
        }
        if(lca1 !=null){
            return lca1;
        }else{
            return lca2;
        }
    }
}
```
如果 p 和 q 分别位于当前节点的左右两侧，则当前节点就是它们的最低公共祖先。
如果 p 和 q 都位于左子树或右子树，则返回相应子树中找到的节点

## [20240929](./202409/20240929.md) |[437. Path Sum III(路径和3)](https://leetcode.com/problems/path-sum-iii/description)

```
● 双重递归结构：
  ○ 外层 pathSum：负责广度遍历：确保每个节点都有机会成为路径起点。
  ○ 内层 helper：负责深度遍历：从当前起点向下延伸，统计所有可能的路径。
● 路径和累加：helper 函数通过参数 currentSum 传递累计和，确保路径连续。
● 终止条件处理：节点为空时直接返回，避免空指针异常。
● 结果累加方式：主函数将当前节点、左子树、右子树的结果相加，覆盖所有可能的路径起点。
```
代码
```java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) return 0;
        // 当前节点为起点的路径数 + 左子树路径数 + 右子树路径数
        return helper(root, targetSum, 0)
            + pathSum(root.left, targetSum)
            + pathSum(root.right, targetSum);
    }

    // 计算从 root 出发的路径和等于 targetSum 的数量
    private int helper(TreeNode root, int targetSum, long currentSum) {
        if (root == null) return 0;
        currentSum += root.val; // 累加当前节点的值
        int count = 0;
        if (currentSum == targetSum) count++; // 找到一条路径
        // 继续递归左右子树，保持当前路径和
        count += helper(root.left, targetSum, currentSum);
        count += helper(root.right, targetSum, currentSum);
        return count;
    }
}
```

## [20240930](./202409/20240930.md) |[543. Diameter of Binary Tree(二叉树的直径)](https://leetcode.com/problems/diameter-of-binary-tree/)

```
1. 定义一个全局变量max来记录当前找到的最大直径。
2. 主函数调用递归函数，并返回max。
3. 递归函数的作用是返回当前子树的深度，同时更新max。
4. 递归函数中，先递归处理左右子树，得到它们的深度。
5. 计算当前节点的左右子树深度之和，并更新max。
6. 返回当前子树的深度，即左右子树深度的较大者加1。
```
代码
```java
class Solution {
    private int max = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        nodes(root);
        return max;
    }

    // 注意这个是计算节点数，要注意返回的直径是边数
    private int nodes(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int len1 = nodes(root.left);
        int len2 = nodes(root.right);
        max = Math.max(max, len1 + len2);
        return Math.max(len1, len2) + 1;
    }
}
```
# 动态规划

## [20241001](./202410/20241001.md) |[5. Longest Palindromic Substring(最长回文子串)](https://leetcode.com/problems/longest-palindromic-substring/description)

```
1. 定义状态‌：dp[i][j] 表示子串 s[i..j] 是否为回文。
2. ‌转移方程‌：
  ○ 若 s[i] != s[j] → dp[i][j] = false。
  ○ 若 s[i] == s[j]：
    ■ 子串长度 ≤ 2 → 必为回文。
    ■ 否则 → dp[i][j] = dp[i+1][j-1]（取决于中间部分）。
3. ‌填充顺序‌：按子串的结束位置 j 遍历，i 从 0 到 j（保证子问题已计算）。
```
代码
```java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }
        int len = s.length();
        String ans = "";
        int max = 0;
        boolean[][] dp = new boolean[len][len];
        for (int j = 0; j < len; j++) {
            for (int i = 0; i < len; i++) {
                boolean judge = s.charAt(i) == s.charAt(j);
                dp[i][j] = j - i > 2 ? dp[i + 1][j - 1] && judge : judge;
                if (dp[i][j] && j - i + 1> max) {
                    ans = s.substring(i, j + 1);
                    max = j - i + 1;
                }
            }
        }
        return ans;
    }
}
```
## [20241002](./202410/20241002.md) |[32. Longest Valid Parentheses(最长有效括号)](https://leetcode.com/problems/longest-valid-parentheses/description)

```java
class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        int maxLen = 0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='('){
                stack.push(i);
            }else{
                // 留一个哨兵index = -1，每一个多余的左括号'('的下标, 或者栈为空时右括号')'的下标，都成了新的哨兵
                stack.pop();
                // 如果栈为空，说明右括号多了，那么右括号的index作为新的哨兵
                if(stack.isEmpty()){
                    stack.push(i);
                }
                maxLen = Math.max(maxLen, i - stack.peek());
            }
        }
        return maxLen;
    }
}
```
## [20241003](./202410/20241003.md) |[62. Unique Paths(动态规划-不同的路径)](https://leetcode.com/problems/unique-paths/description)

```
dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
```
代码
```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        dp[1][1] = 1;
        for (int i = 2; i <= m; i++) {
            dp[i][1] = dp[i - 1][1];
        }
        for (int j = 2; j <= n; j++) {
            dp[1][j] = dp[1][j - 1];
        }
        for (int i = 2; i <= m; i++) {
            for (int j = 2; j <= n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
}
```
## [20241004](./202410/20241004.md) |[64. Minimum Path Sum(最小路径和)](https://leetcode.com/problems/minimum-path-sum/description)

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 1; i < m; i++) {
            grid[i][0] += grid[i - 1][0];
        }
        for (int j = 1; j < n; j++) {
            grid[0][j] += grid[0][j - 1];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                grid[i][j] += Math.min(grid[i][j - 1], grid[i - 1][j]);
            }
        }
        return grid[m - 1][n - 1];
    }
}
```
## [20241005](./202410/20241005.md) |[70. Climbing Stairs(爬梯子)](https://leetcode.com/problems/climbing-stairs/description/)

```
dp[i] = dp[i-1] + dp[i-2];
```
代码
```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 1) {
            return 1;
        }
        int[] dp = new int[n];
        dp[0] = 1;
        dp[1] = 2;
        for(int i=2; i<n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n-1];
    }
}
```
## [20241006](./202410/20241006.md) |[72. Edit Distance(编辑距离)](https://leetcode.com/problems/edit-distance/)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        int[][] dp = new int[len1+1][len2+1];
        for(int i=0;i<=len1;i++){
            dp[i][0] = i;
        }
        for(int j=0;j<=len2;j++){
            dp[0][j] = j;
        }
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                if(word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]))+1;
                }
            }
        }
        return dp[len1][len2];
    }
}
```
## [20241007](./202410/20241007.md) |[118. Pascal's Triangle(杨辉三角)](https://leetcode.com/problems/pascals-triangle/description)

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> lists= new ArrayList<>();
        if(numRows==0) {
            return lists;
        }
        if(numRows>=1) {
            List<Integer> list = new ArrayList<>();
            list.add(1);
            lists.add(list);
        }
        if(numRows>=2) {
            List<Integer> list = new ArrayList<>();
            list.add(1);
            list.add(1);
            lists.add(list);
        }
        if(numRows>=3){
            for(int j =3;j<=numRows;j++){
                List<Integer> list = new ArrayList<>();
                List<Integer> pre = lists.get(lists.size()-1);
                list.add(1);
                for(int i=0; i<pre.size()-1; i++){
                    int num = pre.get(i) + pre.get(i+1);
                    list.add(num);
                }
                list.add(1);
                lists.add(list);
            }
        }
        return lists;
    }
}
```
## [20241008](./202410/20241008.md) |[139. Word Break(单词拆分)](https://leetcode.com/problems/word-break/)

```
● 动态规划数组T，T[i]表示前i个字符是否可以拆分。
● 初始条件T=true。
● 每个i都检查所有可能的j分割点，如果T[j]为true且j到i的子串在字典中，则T[i]为true。
● 最终检查T[s.length()]是否为true。
```
代码
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] T = new boolean[s.length() + 1];
        Set<String> set = new HashSet<>();
        for (String word : wordDict) {
            set.add(word);
        }
        T[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if(T[j] && set.contains(s.substring(j, i))) {
                    T[i] = true;
                    break;
                }
            }
        }
        return T[s.length()];
    }
}
```
## [20241009](./202410/20241009.md) |[152. Maximum Product Subarray(乘积最大的子数组)](https://leetcode.com/problems/maximum-product-subarray/)

```
求数组中‌乘积最大的连续子数组‌，需处理负数、零的干扰。
● 零会截断乘积，重置后相当于从零的下一个位置重新开始计算。
● 若子数组包含奇数个负数，最大值可能在反向遍历中出现（例如 [2, -3, 2]）
```
代码
```java
class Solution {
    public int maxProduct(int[] nums) {
        int ans = Integer.MIN_VALUE;
        int currProd = 1;

        for (int i = 0; i < nums.length; i++) {
            currProd *= nums[i];
            ans = Math.max(ans, currProd);
            currProd = currProd == 0 ? 1 : currProd;
        }

        currProd = 1;
        for (int j = nums.length - 1; j >= 0; j--) {
            currProd *= nums[j];
            ans = Math.max(ans, currProd);
            currProd = currProd == 0 ? 1 : currProd;
        }
        return ans;
    }
}
```
## [20241010](./202410/20241010.md) |[198. House Robber(打家劫舍)](https://leetcode.com/problems/house-robber/description)

```
 dp[i + 1] = Math.max(nums[i] + dp[i - 1], dp[i]);
```
代码
```java
class Solution {
    public int rob(int[] nums) {
        if(nums==null || nums.length==0){
            return 0;
        }
        int[] dp = new int[nums.length+1];
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i=1;i<nums.length;i++){
            // 下一家可以偷，dp[i-1]+nums[i]
            // 下一家不可以偷，dp[i]
            dp[i+1] = Math.max(dp[i], nums[i]+dp[i-1]);
        }
        return dp[nums.length];
    }
}
```
## [20241011](./202410/20241011.md) |[279. Perfect Squares(完美正方形)](https://leetcode.com/problems/perfect-squares/description/)

```
“平方数作物品，完全背包求最小；遍历j从1到n，i方不超j；状态转移取最小，初始零其余最大。
● 外层循环：遍历所有可能的和 j（从1到n）。
● 内层循环：遍历所有可能的平方数 i*i（i 从1到 √j）。
● 状态转移：dp[j] = min(dp[j], dp[j - i*i] + 1)，即尝试将 i*i 加入组合。
```
代码
```java
class Solution {
    public int numSquares(int n) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[n + 1];
        // 初始化
        for (int j = 0; j <= n; j++) {
            dp[j] = max;
        }
        // 当和为0时，组合的个数为0
        dp[0] = 0;
        // 遍历背包
        for (int j = 1; j <= n; j++) {
            // 遍历物品
            for (int i = 1; i * i <= j; i++) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}
```

## [20241012](./202410/20241012.md) |[300. Longest Increasing Subsequence(最长递增子序列)](https://leetcode.com/problems/longest-increasing-subsequence/)

```
dp[i] = Math.max(dp[j]+1, dp[i]);
```
代码
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int maxLen = 1;
        int[] dp = new int[nums.length];
        for(int i=0; i< nums.length;i++){
            dp[i] = 1;
            for(int j=0;j<i;j++){
                if(nums[j] < nums[i]){
                    dp[i] = Math.max(dp[j]+1, dp[i]);
                }
            }
            if(dp[i] > maxLen){
                maxLen = dp[i];
            }
        }
        return maxLen;
    }
}
```
## [20241013](./202410/20241013.md) |[322. Coin Change(零钱兑换)](https://leetcode.com/problems/coin-change)

```
dp[i] = Math.min(dp[i], dp[i - coin] + 1);
```
代码
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if (coins == null || coins.length == 0 || amount <= 0) {
            return 0;
        }
        int[] dp = new int[amount + 1];
        for (int i = 1; i <= amount; i++) {
            dp[i] = Integer.MAX_VALUE;
            for (int coin : coins) {
                if (i >= coin && dp[i - coin] != Integer.MAX_VALUE) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```
## [20241014](./202410/20241014.md) |[416. Partition Equal Subset Sum(分割和相等的子数组)](https://leetcode.com/problems/partition-equal-subset-sum)

```
总和需偶，半值目标，背包问题，逆序更新。
1. 初始化总和检查‌：总和必须是偶数，否则直接false。
2. ‌目标值volumn‌：总和的一半。
3. ‌dp数组的定义‌：dp[j]表示能否组成和为j的子集。
4. ‌状态转移方程‌：dp[j] = dp[j] || dp[j - nums[i-1]]，即当前元素是否被包含在内。
5. ‌遍历顺序‌：外层循环遍历每个元素，内层循环逆序更新dp数组(0-1背包逆序走，完全背包正序流。)，避免重复使用元素。
```
代码
```java
class Solution {
    public boolean canPartition(int[] nums) {
        if (nums == null || nums.length == 0) {
            return true;
        }
        int volumn = 0;
        for (int num : nums) {
            volumn += num;
        }
        if (volumn % 2 != 0) {
            return false;
        }
        volumn /= 2;
        boolean[] dp = new boolean[volumn + 1];
        dp[0] = true;
        for (int i = 1; i <= nums.length; i++) {
            for (int j = volumn; j >= nums[i-1]; j--) {
                dp[j] = dp[j] || dp[j - nums[i-1]];
            }
        }
        return dp[volumn];
    }
}
```
## [20241015](./202410/20241015.md) |[1143. Longest Common Subsequence(最长公共子序列)](https://leetcode.com/problems/longest-common-subsequence/)

```
dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
```
代码
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int len1 = text1.length();
        int len2 = text2.length();

        int[][] dp = new int[len1+1][len2+1];
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[len1][len2];
    }
}
```
# 哈希

## [20241016](./202410/20241016.md) |[1. Two Sum(两数之和)](https://leetcode.com/problems/two-sum/description/)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0; i<nums.length; i++){
            if(map.containsKey(target-nums[i])){
                return new int[]{map.get(target-nums[i]), i};
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("no solution!");
    }
}
```

## [20241017](./202410/20241017.md) |[49. Group Anagrams(字母异位词分组)](https://leetcode.com/problems/group-anagrams/description)

```
通过Hash的方式按照顺序构建一个26位数组，存储每一个字符的count，如果数组相同，那么认为是异位字母词
```
代码
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        if (strs == null || strs.length == 0) {
            return new ArrayList<>();
        }
        Map<String, List<String>> map = new HashMap<>();
        for (S s : strs) {
            char[] ca = new char[26];
            for (char c : s.toCharArray()){
                ca[c - 'a']++;
            }
            String keyStr = String.valueOf(ca);
            if (!map.containsKey(keyStr)) {
                map.put(keyStr, new ArrayList<>());
            }
            map.get(keyStr).add(s);
        }
        return new ArrayList<>(map.values());
    }
}
```
## [20241018](./202410/20241018.md) |[128. Longest Consecutive Sequence(最长连续子序列)](https://leetcode.com/problems/longest-consecutive-sequence/)

```
使用map，其中key是数字，value是该数字所在连续区间的长度。只维护区间的左右端点的长度，中间数字的长度无需更新。(查左右，算总和，更端点，中间无需动) 哈希表操作 O(1)
1. 初始化：创建一个哈希表map和结果res。
2. 遍历数组中的每个数字n：
- 如果n已经在map中存在，跳过。
- 否则，获取n左边（n-1）和右边（n+1）的长度left和right。
- 计算sum = left + right + 1。
- 将sum存入map中n的位置，并更新res。
- 最后，更新n-left和n+right的位置的值为sum。
```
代码
```java
class Solution {
    public int longestConsecutive(int[] nums) {
        int res = 0;
        // 使用map存储当前元素n的最大序列长度sum
        Map<Integer, Integer> map = new HashMap<>();
        for (int n : nums) {
            // 重复元素直接跳过
            if(map.containsKey(n)){
                continue;
            }
            // 相邻左侧节点计算左侧的最大长度(没有相邻左侧节点直接设置为0)
            int left = map.getOrDefault(n-1, 0);
            // 相邻右侧节点计算右侧最大长度
            int right = map.getOrDefault(n+1, 0);
            // 计算当前左右节点累加之后的长度sum，并保存到n中
            int sum = left + right + 1;
            map.put(n, sum);

            // 求res当前最大值
            res = Math.max(res, sum);

            // 扩大n两侧的数字范围
            // n左侧left个节点，更新为sum
            map.put(n-left, sum);
            // n右侧right个节点，更新为sum
            map.put(n+right, sum);
        }
        return res;
    }
}
```
## [20241019](./202410/20241019.md) |[560. Subarray Sum Equals K(和为K的子数组)](https://leetcode.com/problems/subarray-sum-equals-k/description/)

```
1. 初始化preSum哈希表，放入(0,1)。
2. 遍历数组，计算累加和sum。
3. 每次计算sum后，先检查是否存在sum - k在哈希表中，存在的话就加到结果。
4. 然后将当前的sum存入哈希表，次数加一。
前缀和+哈希表：若当前前缀和为sum，且存在某个历史前缀和sum_j满足sum - sum_j = k，则子数组(j, i]的和为k
```
代码
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int sum = 0, result = 0;
        Map<Integer, Integer> preSum = new HashMap<>();
        preSum.put(0, 1);

        for(int i=0;i<nums.length;i++){
            sum += nums[i];
            if(preSum.containsKey(sum - k)){
                result += preSum.get(sum - k);
            }
            // map[sum-k]表示在i位置之前，有多少前缀和为sum-k的子数组
            preSum.put(sum, preSum.getOrDefault(sum, 0) + 1);
        }
        return result;
    }
}
```

# 链表
## [20241020](./202410/20241020.md) |[2. Add Two Numbers(链表-两数相加)](https://leetcode.com/problems/add-two-numbers)

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1==null||l2==null) return null;
        int value1,value2=0;
        ListNode pre = new ListNode(0);
        ListNode result = pre;
        while(l1!=null&&l2!=null){
            value1 = (l1.val+l2.val+value2)%10;
            value2 = (l1.val+l2.val+value2)/10;
            pre.next = new ListNode(value1);
            pre = pre.next;
            l1 = l1.next;
            l2 = l2.next;
            if(l1 == null && l2 == null){
                break;
            }
            if(l1 == null && l2 != null){
                l1 = new ListNode(0);
            }
            if(l1 != null && l2 == null){
                l2 = new ListNode(0);
            }
        }
        if(value2>0){
            pre.next = new ListNode(value2);
        }
        return result.next;
    }
}
```
## [20241021](./202410/20241021.md) |[19. Remove Nth Node From End of List(移除链表中倒数第N个元素)](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head;
        ListNode res = new ListNode(0);
        res.next = head;
        ListNode slow = res;
        while (fast != null) {
            fast = fast.next;
            if (n-- <= 0) {
                slow = slow.next;
            }
        }
        slow.next = slow.next.next;
        return res.next;
    }
}
```
## [20241022](./202410/20241022.md) |[21. Merge Two Sorted Lists(合并两个排序链表)](https://leetcode.com/problems/merge-two-sorted-lists/)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null){
            return l2;
        }else if(l2 == null){
            return l1;
        }else if(l1.val < l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```

## [20241023](./202410/20241023.md) |[23. Merge k Sorted Lists(合并K个有序链表)](https://leetcode.com/problems/merge-k-sorted-lists/)

```
分治+合并，共三个函数
● 分治终止条件‌：当start == end时，直接返回当前链表（无需合并）。
● ‌分割方式‌：取中点mid，递归处理左右区间。
● ‌合并结果‌：将左右区间的结果通过merge函数合并。
```
代码
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return partition(lists,0,lists.length-1);
    }
    public ListNode partition(ListNode[] lists, int s ,int e){
        if(s==e){
            return lists[s];
        }
        if(s<e){
            int q = (s+e)/2;
            ListNode l1 = partition(lists, s ,q);
            ListNode l2 = partition(lists, q+1, e);
            return merge(l1,l2);
        }else{
            return null;
        }
    }
    public static ListNode merge(ListNode l1, ListNode l2){
        if(l1==null) return l2;
        if(l2==null) return l1;
        if(l1.val<l2.val){
            l1.next = merge(l1.next,l2);
            return l1;
        }else{
            l2.next = merge(l1,l2.next);
            return l2;
        }
    }
}
```

## [20241024](./202410/20241024.md) |[24. Swap Nodes in Pairs(两两交换链表的节点)](https://leetcode.com/problems/swap-nodes-in-pairs/)
```java
// 递归
class Solution {
    public ListNode swapPairs(ListNode head) {
        // 终止条件：无节点或单节点
        if (head == null || head.next == null) {
            return head;
        }

        // 记录第二个节点
        ListNode next = head.next;
        // 第一个节点的next指向递归处理后的剩余链表
        head.next = swapPairs(head.next.next);
        // 第二个节点的next指向第一个节点，完成交换
        next.next = head;

        // 返回新的头节点（原来的第二个节点）
        return next;
    }
}

// 非递归
public ListNode swapPairs(ListNode head) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode pre = dummy;
    while (pre.next != null && pre.next.next != null) {
        ListNode first = pre.next;
        ListNode second = first.next;
        // 调整指针
        pre.next = second;
        first.next = second.next;
        second.next = first;
        pre = first;
    }
    return dummy.next;
}
```

## [20241025](./202410/20241025.md) |[25. Reverse Nodes in k-Group(K组反转链表)](https://leetcode.com/problems/reverse-nodes-in-k-group/)

```
1. 哑节点（Dummy Node）：简化头节点处理，避免边界问题。
2. 分段处理：每k个节点为一组，找到组边界后进行反转。
3. 指针更新：反转后更新前驱节点，连接后续链表。
以 1 -> 2 -> 3 -> 4 -> 5, k=2 为例：
1. 初始状态：dummy -> 1 -> 2 -> 3 -> 4 -> 5，pre = dummy，curr = 1。
2. 遍历到第2个节点：触发反转 reverse(dummy, 3)。
  ○ 反转过程：将 1 -> 2 反转为 2 -> 1，并连接后续 3。
  ○ 结果：dummy -> 2 -> 1 -> 3 -> 4 -> 5，pre 更新为 1。
3. 继续遍历：curr = 3，遍历到第4个节点时触发反转 reverse(1, 5)。
  ○ 反转过程：将 3 -> 4 反转为 4 -> 3，并连接后续 5。
  ○ 结果：dummy -> 2 -> 1 -> 4 -> 3 -> 5，pre 更新为 3。
4. 最终链表：2 -> 1 -> 4 -> 3 -> 5。
```
代码
```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || k == 1) return head;
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode pre = dummy; // 当前组的前驱节点
        ListNode curr = head;
        int count = 0;

        while (curr != null) {
            count++;
            if (count % k == 0) { // 找到k个节点，开始反转
                pre = reverse(pre, curr.next); // 反转并更新pre
                curr = pre.next; // curr移动到下一组的起点
            } else {
                curr = curr.next;
            }
        }
        return dummy.next;
    }

    // 反转从 pre.next 到 end 之间的节点，返回反转后的最后一个节点（即原来的第一个节点）
    private ListNode reverse(ListNode pre, ListNode end) {
        ListNode last = pre.next;  // last 是当前组的第一个节点（反转后成为最后一个节点）
        ListNode curr = last.next; // curr 从第二个节点开始操作
        while (curr != end) {      // 遍历到 end 停止
            ListNode next = curr.next;  // 保存下一个待处理节点
            curr.next = pre.next;  // 头插：将 curr 插入到 pre 后
            pre.next = curr;       // 更新 pre 的 next
            curr = next;           // 移动 curr 到下一个节点
        }
        last.next = end;  // 将反转后的最后一个节点（原第一个节点）连接到 end
        return last;      // 返回反转后的最后一个节点，作为下一组的前驱
    }
}
```
## [20241026](./202410/20241026.md) |[138. Copy List with Random Pointer(带随机指针Copy链表)](https://leetcode.com/problems/copy-list-with-random-pointer)

```
一判空，二哈希，三次遍历连指针
```
代码
```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null){
            return null;
        }
        // 1. 创建哈希表存储原节点与拷贝节点的映射
        Map<Node, Node> clone = new HashMap<>();
        Node current = head;

        // 2. 第一次遍历：创建所有新节点
        while(current != null){
            Node temp = new Node(current.val);
            clone.put(current, temp);
            current = current.next;
        }

        // 3. 第二次遍历：连接拷贝节点的next和random
        current = head;
        while(current != null){
            Node temp = clone.get(current);
            // 取原节点的next对应的拷贝节点
            temp.next = clone.get(current.next);
            // 取原节点的random对应的拷贝节点
            temp.random = clone.get(current.random);
            current = current.next;
        }
        // 4. 返回新链表的头节点
        return clone.get(head);
    }
}
```

## [20241027](./202410/20241027.md) |[141. Linked List Cycle(环形链表)](https://leetcode.com/problems/linked-list-cycle/description/)

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head ==null || head.next==null){
            return false;
        }
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow){
                return true;
            }
        }
        return false;
    }
}
```
## [20241028](./202410/20241028.md) |[142. Linked List Cycle II(环形链表2)](https://leetcode.com/problems/linked-list-cycle-ii/)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head==null||head.next==null){
            return null;
        }
        ListNode fast = head;
        ListNode slow = head;
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            if(fast == slow){
                break;
            }
        }
        if(fast == null || fast.next == null){
            return null;
        }
        fast = head;
        while(fast != slow){
            fast = fast.next;
            slow = slow.next;
        }

        return fast;
    }
}
```
## [20241029](./202410/20241029.md) |[146. LRU Cache(LRU缓存)](https://leetcode.com/problems/lru-cache/description/)

```java
import java.util.Hashtable;
class LRUCache {

    // 定义一个内部类，存储LRU节点
    class DLinkedNode {
      // key
      int key;
      // value
      int value;
      // 前一个节点
      DLinkedNode pre;
      // 后一个节点
      DLinkedNode post;
    }

    /**
     * Always add the new node right after head;
     */
    private void addNode(DLinkedNode node) {
       node.pre = head;
       node.post = head.post;
       head.post.pre = node;
       head.post = node;
    }

    /**
     * Remove an existing node from the linked list.
     */
    private void removeNode(DLinkedNode node){
       DLinkedNode pre = node.pre;
       DLinkedNode post = node.post;
       pre.post = post;
       post.pre = pre;
    }

    /**
     * Move certain node in between to the head.
     */
    private void moveToHead(DLinkedNode node){
      this.removeNode(node);
      this.addNode(node);
    }

    // pop the current tail.
    private DLinkedNode popTail(){
       DLinkedNode res = tail.pre;
       this.removeNode(res);
       return res;
    }

    private Hashtable<Integer, DLinkedNode> cache = new Hashtable<Integer, DLinkedNode>();
    private int count;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.count = 0;
        this.capacity = capacity;

        head = new DLinkedNode();
        head.pre = null;

        tail = new DLinkedNode();
        tail.post = null;

        head.post = tail;
        tail.pre = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if(node == null){
            // should raise exception here.
            return -1;
        }
        // move the accessed node to the head;
        this.moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if(node == null){
          DLinkedNode newNode = new DLinkedNode();
          newNode.key = key;
          newNode.value = value;
          this.cache.put(key, newNode);
          this.addNode(newNode);
          ++count;

          if(count > capacity){
            // pop the tail
            DLinkedNode tail = this.popTail();
            this.cache.remove(tail.key);
            --count;
          }
       }else{
          // update the value.
          node.value = value;
          this.moveToHead(node);
       }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```
简单版本
```java
class LRUCache {

    private LinkedHashMap<Integer, Integer> cache;
    private int capacity;

    public LRUCache(int capacity) {
        cache = new LinkedHashMap<>(capacity);
        this.capacity = capacity;
    }

    public int get(int key) {
        // 没有直接返回-1
        if (!cache.containsKey(key)) {
            return -1;
        }
        // 有的话先删除再放在列表尾部
        int res = cache.get(key);
        cache.remove(key);
        cache.put(key, res);
        return res;
    }

    public void put(int key, int value) {
        if(cache.containsKey(key)){
            cache.remove(key);
        }
        // 元素已满删除链表头部
        if(capacity == cache.size()){
            Set<Integer> keySet = cache.keySet();
            Iterator<Integer> iterator = keySet.iterator();
            cache.remove(iterator.next());
        }
        // 放在链表尾部
        cache.put(key, value);
    }
}

```
## [20241030](./202410/20241030.md) |[148. Sort List(链表排序)](https://leetcode.com/problems/sort-list/)

```java
import java.util.Collections;

class Solution {
    public ListNode sortList(ListNode head) {
        // 1. 链表转列表（存储新节点）
        List<ListNode> list = new ArrayList<>();
        while (head != null) {
            list.add(new ListNode(head.val)); // 复制节点值
            head = head.next;
        }

        // 2. 按节点值排序列表
        Collections.sort(list, new Comparator<ListNode>() {
            @Override
            public int compare(ListNode o1, ListNode o2) {
                return o1.val - o2.val; // 升序排序
            }
        });

        // 3. 列表转链表
        ListNode dummy = new ListNode(-1); // 哑节点简化操作
        ListNode current = dummy;
        for (ListNode node : list) {
            current.next = node;
            current = current.next;
        }
        return dummy.next;
    }
}
```

## [20241031](./202410/20241031.md) |[160. Intersection of Two Linked Lists(两个链表的交集)](https://leetcode.com/problems/intersection-of-two-linked-lists/)

```
路径拼接算法
1. 相交链表‌：
  ○ 链表 A: 1 -> 2 -> 3 -> 4
  ○ 链表 B: 5 -> 3 -> 4
  ○ 相交节点为 3。
  ○ 指针 a 路径：1→2→3→4→5→3
  ○ 指针 b 路径：5→3→4→1→2→3
  ○ 两指针在 3 处相遇。
2. ‌不相交链表‌：
  ○ 链表 A: 1 -> 2
  ○ 链表 B: 3 -> 4 -> 5
  ○ 指针 a 路径：1→2→3→4→5→null
  ○ 指针 b 路径：3→4→5→1→2→null
  ○ 两指针同时到达 null。
```
代码
```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        //boundary check
        if(headA == null || headB == null) return null;

        ListNode a = headA;
        ListNode b = headB;

        //if a & b have different len, then we will stop the loop after second iteration
        while( a != b){
            //for the end of first iteration, we just reset the pointer to the head of another linkedlist
            a = a == null? headB : a.next;
            b = b == null? headA : b.next;    
        }

        return a;
    }
}
```
## [20241101](./202411/20241101.md) |[206. Reverse Linked List(反转链表)](https://leetcode.com/problems/reverse-linked-list/description/)

```java
class Solution {
    public ListNode reverseList(ListNode head){
        if(head == null || head.next == null){
            return head;
        }
        ListNode pre = null;
        ListNode now = head;
        while(now != null){
            ListNode next = now.next;
            now.next = pre;
            pre = now;
            now = next;
        }
        return pre;
    }
}
```
## [20241102](./202411/20241102.md) |[234. Palindrome Linked List(回文链表)](https://leetcode.com/problems/palindrome-linked-list/description)

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head, slow = head;
        while(fast!=null && fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
        }
        // odd nodes: let right half smaller
        if (fast != null) {
            slow = slow.next;
        }
        slow = reverse(slow);
        fast = head;
        while(slow != null){
            if(slow.val != fast.val){
                return false;
            }
            slow = slow.next;
            fast = fast.next;
        }
        return true;
    }
    private ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode now = head;
        while(now != null){
            ListNode next = now.next;
            now.next = pre;
            pre = now;
            now = next;
        }
        return pre;
    }
}
```

# 图

## [20241103](./202411/20241103.md) |[200. Number of Islands(图-岛屿的数量)](https://leetcode.com/problems/number-of-islands/)

```
1. 遍历网格中的每一个格子。
2. 当发现一个未被访问的陆地（即'1'），计数器加一。
3. 使用DFS或BFS标记所有相连的陆地为已访问（这里用DFS，并直接修改为'0'）。
4. 在DFS中，检查边界条件，确保不会越界。
5. 对当前格子的四个方向进行递归处理。
```
代码
```java
class Solution {
    private final char LAND = '1';
    private final char WATER = '0';
    private char[][] arr;
    public int numIslands(char[][] grid) {
        arr = grid;
        int nums = 0;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == LAND){
                    nums++;
                    dfs(i,j);
                }
            }
        }
        return nums;
    }
    private void dfs(int rows, int cols){
        // check if current rows is out of bound
        if(rows<0||rows>arr.length-1){
            return;
        }
        // check if current cols is out of bound
        if(cols<0||cols>arr[0].length-1){
            return;
        }
        // WATER or LAND
        if(arr[rows][cols]==WATER){
            return;
        }
        arr[rows][cols] = WATER;
        dfs(rows+1, cols);
        dfs(rows-1, cols);
        dfs(rows, cols+1);
        dfs(rows, cols-1);
    }
}
```

## [20241104](./202411/20241104.md) |[207. Course Schedule(课程计划)](https://leetcode.com/problems/course-schedule/)

```
1. 入度数组‌（inDegree）：
表示每个课程需要的前置课程数量。例如，inDegree = 2 表示课程 3 有 2 个前置课程。
2. ‌队列初始化‌：
入度为 0 的课程可以直接学习，作为拓扑排序的起点。
3. ‌拓扑排序过程‌：
  ○ 每次从队列中取出一个课程，表示已经学完该课程。
  ○ 遍历所有依赖该课程的后续课程，减少它们的入度。
  ○ 如果某个后续课程的入度变为 0，说明它的前置条件已满足，可以加入队列。
4. ‌环的检测‌：
如果最终存在入度非零的课程，说明这些课程无法完成（存在环）。
```
代码
```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if (numCourses <= 0)
            return false;

        // 初始化数据结构
        int[] inDegree = new int[numCourses]; // 课程入度表
        Map<Integer, List<Integer>> adjacency = new HashMap<>(); // 邻接表
        Queue<Integer> queue = new LinkedList<Integer>(); // 拓扑排序队列

        // 一次性构建入度表和邻接表
        for (int[] edge : prerequisites) {
            int prev = edge[1]; // 前置课程
            int now = edge[0]; // 当前课程
            inDegree[now]++; // 后置课程入度+1
            adjacency.computeIfAbsent(prev, k -> new ArrayList<>()).add(now);
        }

        // 初始化队列：入度为0的课程可以直接学习
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }

        // 拓扑排序处理
        while (!queue.isEmpty()) {
            int current = queue.poll();
            // 通过邻接表快速获取后续课程（复杂度O(1)）
            List<Integer> nextCourses = adjacency.getOrDefault(current, new ArrayList<>());
            for (int next : nextCourses) {
                // 入度减为0则加入队列
                if (--inDegree[next] == 0) {
                    queue.offer(next);
                }
            }
        }

        // 检测是否有未完成的课程
        for (int degree : inDegree) {
            if (degree != 0)
                return false;
        }

        return true;
    }
}
```
## [20241105](./202411/20241105.md) |[994. Rotting Oranges(腐烂的橘子)](https://leetcode.com/problems/rotting-oranges/description/)

```
1. 初始化检查
  ○ 网格为空或没有新鲜橘子时，直接返回 0。
2. 队列初始化
  ○ 遍历网格，将所有初始腐烂橘子的坐标加入队列，并统计新鲜橘子数量 count_fresh。
3. 方向数组
  ○ 定义四个方向的偏移量 dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}}。
4. BFS 逐层处理
  ○ 循环处理队列中的每一层：每一层对应一分钟的腐烂扩散。
  ○ 处理当前层所有节点：将腐烂橘子的四个方向的新鲜橘子腐烂，并加入队列。
  ○ 更新计数：每腐烂一个新鲜橘子，count_fresh--。
5. 时间计算与结果判断
  ○ 总时间为处理的层数 count 减 1（因为初始层不算时间）。
  ○ 若 count_fresh == 0，返回 count-1；否则返回 -1。
```
代码
```java
class Solution {
    public int orangesRotting(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int rows = grid.length;
        int cols = grid[0].length;
        Queue<int[]> queue = new LinkedList<>();
        int freshCount = 0;
        // 记录腐烂的橘子到队列中
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 2) {
                    queue.offer(new int[] { i, j });
                } else if (grid[i][j] == 1) {
                    freshCount++;
                }
            }
        }
        // 如果没有新鲜橘子直接返回
        if (freshCount == 0) {
            return 0;
        }

        int count = 0;
        // 上下左右方向
        int[][] dirs = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
        // 处理队列所有腐烂的橘子进行传播，直到队列为空
        while (!queue.isEmpty()) {
            count++;
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] point = queue.poll();
                for (int dir[] : dirs) {
                    int x = point[0] + dir[0];
                    int y = point[1] + dir[1];
                    if (x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || grid[x][y] == 2)
                        continue;
                    grid[x][y] = 2;
                    queue.offer(new int[] { x, y });
                    freshCount--;
                }
            }
        }
        return freshCount == 0 ? count - 1 : -1;
    }
}
```
# 贪心算法

## [20241106](./202411/20241106.md) |[45. Jump Game II(贪心算法-跳跃游戏2)](https://leetcode.com/problems/jump-game-ii/)

```java
class Solution {
    public int jump(int[] nums) {
        int result = 0, curMax = 0, max = 0;
        for (int i = 0; i < nums.length - 1; i++) {
            max = Math.max(max, i + nums[i]);
            if(i == curMax){
                result ++;
                curMax = max;
            }
        }
        return result;
    }
}
```
## [20241107](./202411/20241107.md) |[55. Jump Game(跳跃游戏)](https://leetcode.com/problems/jump-game/)

```java
class Solution {
    public boolean canJump(int[] nums) {
        int last = nums.length-1;
        for(int i=last; i>=0; i--){
            if(nums[i] + i >= last){
                last = i;
            }
        }
        return last==0;
    }
}
```
## [20241108](./202411/20241108.md) |[121. Best Time to Buy and Sell Stock(买卖股票的最佳时机)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0){
            return 0;
        }
        int global = 0;
        int min = prices[0];
        for(int i = 1; i < prices.length; i++){
            min = Math.min(min, prices[i]);
            if(prices[i] > min){
                global = Math.max(global, prices[i] - min);
            }
        }
        return global;
    }
}
```
## [20241109](./202411/20241109.md) |[763. Partition Labels(划分区间)](https://leetcode.com/problems/partition-labels/description/)

```
将字符串分割为若干子串，使得同一字母‌只出现在一个子串中‌。要求分割后的子串数量尽可能多。
1. 预处理‌：记录每个字符最后一次出现的下标。
2. ‌动态扩展区间‌：遍历时维护当前区间的右边界，当遍历到右边界时分割区间。
一存最后位，二扩右边界，触边即分割。
```
代码
```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> list = new ArrayList<>();
        // 记录每个字符最后出现的下标
        int[] edge = new int[26];
        char[] chars = s.toCharArray();

        // Step 1: 预处理，记录字符最后出现的位置
        for (int i = 0; i < chars.length; i++) {
            edge[chars[i] - 'a'] = i;
        }

        // Step 2: 动态扩展区间
        int idx = 0; // 当前区间的右边界
        int last = -1; // 上一个区间的右边界（初始为-1）
        for (int i = 0; i < chars.length; i++) {
            // 扩展右边界
            idx = Math.max(idx, edge[chars[i] - 'a']);
            // 走到当前区间终点，触发分割
            if (i == idx) {
                // 区间长度 = 当前i - 上一个last
                list.add(i - last);
                // 更新last为当前区间的终点
                last = i;
            }
        }
        return list;
    }
}
```

# 堆
## [20241110](./202411/20241110.md) |[215. Kth Largest Element in an Array(数组中第K个最大元素)](https://leetcode.com/problems/kth-largest-element-in-an-array/)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int n = nums.length, low = 0, high = n-1;
        while(low<=high){
           int x = partition(nums, low, high);
           if(n-x == k){
               return nums[x];
           }else if(n-x < k){
               high = x-1;
           }else{
               low = x+1;
           }
        }
        return low;
    }

    private int partition(int[] nums, int low, int high){
        int i = low;
        int j = high;
        int povit = nums[i];
        while(i < j){
            while(i < j && povit < nums[j]){
                j--;
            }
            if(i < j){
                nums[i] = nums[j];
                nums[j] = povit;
                i++;
            }
            while(i < j && povit > nums[i]){
                i++;
            }
            if(i < j){
                nums[j] = nums[i];
                nums[i] = povit;
                j--;
            }
        }
        return i;
    }
}
```
最大堆简单版
```JAVA
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k);
        for(int item:nums) {
            minHeap.offer(item);
            if(minHeap.size()>k) {
                minHeap.poll();
            }
        }
        return minHeap.peek();
    }
}
```
最大堆复杂版
```Java
class Solution {
    private int size=0;
    public int findKthLargest(int[] nums, int k) {
        size = nums.length;

        heapify(nums);

        for(int i=0; i<k-1; i++)
            delete(nums);
        return nums[0];
    }

    void heapify(int[] nums){
        for(int i=size/2 -1; i>=0; i--){
            percolateDown(nums, i);
        }
    }

    void delete(int nums[]){
        nums[0] = nums[size-1];
        size--;
        percolateDown(nums, 0);
    }

    void percolateDown(int nums[], int index){
        while(index < size){
            int max = index;
            if(getLeft(index) != -1 && nums[getLeft(index)] > nums[max])
                max = getLeft(index);
            if(getRight(index) != -1 && nums[getRight(index)] > nums[max])
                max = getRight(index);

            if(max != index){
                swap(max, index, nums);
                index = max;
            }
            else break;
        }
    }
    void swap(int indexA, int indexB, int arr[]){
        int temp = arr[indexB];
        arr[indexB] = arr[indexA];
        arr[indexA] = temp;
    }
    int getLeft(int index){
        return (index*2 + 1) >= size ? -1 : (index*2 + 1);
    }
    int getRight(int index){
        return (index*2 + 2) >= size ? -1 : (index*2 + 2);
    }
}
```

## [20241111](./202411/20241111.md) |[295. Find Median from Data Stream(发现数据流中的中位数)](https://leetcode.com/problems/find-median-from-data-stream/)

```
目标：实时接收数据流，快速返回当前所有数字的中位数。
关键挑战：每次添加新数字后保持数据有序，并高效计算中位数。
```
代码
```java
class MedianFinder {
    private List<Integer> list; // 维护有序列表

    public MedianFinder() {
        list = new ArrayList<>();
    }

    // 插入数字并保持有序
    public void addNum(int num) {
        if (list.isEmpty()) {
            list.add(num);
        } else {
            int i = 0;
            // 找到第一个大于num的位置
            while (i < list.size() && list.get(i) < num) {
                i++;
            }
            list.add(i, num); // 在i位置插入num
        }
    }

    // 计算当前中位数
    public double findMedian() {
        int n = list.size();
        if (n % 2 == 1) {
            return list.get(n / 2); // 奇数长度，返回中间元素
        } else {
            // 偶数长度，返回中间两数的平均
            return (list.get(n / 2 - 1) + list.get(n / 2)) / 2.0;
        }
    }
}

class MedianFinder {
    private PriorityQueue<Integer> maxHeap; // 较小的一半（大顶堆）
    private PriorityQueue<Integer> minHeap; // 较大的一半（小顶堆）

    public MedianFinder() {
        maxHeap = new PriorityQueue<>((a, b) -> b - a);
        minHeap = new PriorityQueue<>();
    }

    public void addNum(int num) {
        maxHeap.offer(num);
        minHeap.offer(maxHeap.poll());
        // 平衡堆大小，确保大顶堆大小 >= 小顶堆
        if (maxHeap.size() < minHeap.size()) {
            maxHeap.offer(minHeap.poll());
        }
    }

    public double findMedian() {
        if (maxHeap.size() > minHeap.size()) {
            return maxHeap.peek();
        } else {
            return (maxHeap.peek() + minHeap.peek()) / 2.0;
        }
    }
}
```
## [20241112](./202411/20241112.md) |[347. Top K Frequent Elements(TopK个频率的元素)](https://leetcode.com/problems/top-k-frequent-elements/description)
```
● 哈希表统计频率。
● 桶数组的索引是频率，桶中的元素是该频率下的所有数字。
● 倒序遍历桶，优先取高频元素。
● 在加入每个桶元素时，检查是否已收集足够的元素，及时终止循环
```
代码
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        List<Integer>[] bucket = new List[nums.length + 1];
        Map<Integer, Integer> frequencyMap = new HashMap<Integer, Integer>();

        for (int n : nums) {
            frequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);
        }

        for (int key : frequencyMap.keySet()) {
            int frequency = frequencyMap.get(key);
            if (bucket[frequency] == null) {
                bucket[frequency] = new ArrayList<>();
            }
            bucket[frequency].add(key);
        }

        List<Integer> res = new ArrayList<>();
        for (int pos = bucket.length - 1; pos >= 0 && res.size() < k; pos--) {
            if (bucket[pos] != null) {
                res.addAll(bucket[pos]);
            }
        }

        int[] result = new int[res.size()];
        for(int i=0; i<res.size();i++){
            result[i] = res.get(i);
        }
        return result;
    }
}
```
# 矩阵
## [20241113](./202411/20241113.md) |[48. Rotate Image(旋转图像)](https://leetcode.com/problems/rotate-image/description/)

```java
class Solution {
    public void rotate(int[][] matrix) {
        // 矩阵转置
        // 1 4 7
        // 2 5 8
        // 3 6 9
        for (int i = 0; i < matrix.length; i++) {
            for (int j = i; j < matrix[0].length; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        // 每行对称反转
        // 7 4 1
        // 8 5 2
        // 9 6 3
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < (matrix[0].length / 2); j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][matrix[0].length - 1 - j];
                matrix[i][matrix[0].length - 1 - j] = temp;
            }
        }
    }
}

```
## [20241114](./202411/20241114.md) |[54. Spiral Matrix(螺旋矩阵)](https://leetcode.com/problems/spiral-matrix/description)

```
螺旋遍历四方向，右→下→左→上；
边界逐层向内缩，左右上下要检查。
或者更详细的步骤：
1. 右行顶到头，顶行下移；
2. 下列到最右，右列左移；
3. 左行底到左，底行上移（如果有行）；
4. 上行到顶左，左列右移（如果有列）。
```

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        if (matrix.length == 0) {
            return res;
        }
        int rowBegin = 0;
        int rowEnd = matrix.length - 1;
        int colBegin = 0;
        int colEnd = matrix[0].length - 1;
        while (rowBegin <= rowEnd && colBegin <= colEnd) {
            // 右
            for (int j = colBegin; j <= colEnd; j++) {
                res.add(matrix[rowBegin][j]);
            }
            rowBegin++;

            // 下
            for (int i = rowBegin; i <= rowEnd; i++) {
                res.add(matrix[i][colEnd]);
            }
            colEnd--;

            // 左
            if (rowBegin <= rowEnd) {
                for (int j = colEnd; j >= colBegin; j--) {
                    res.add(matrix[rowEnd][j]);
                }
            }
            rowEnd--;

            // 上
            if (colBegin <= colEnd) {
                for (int i = rowEnd; i >= rowBegin; i--) {
                    res.add(matrix[i][colBegin]);
                }
            }
            colBegin++;
        }
        return res;
    }
}
```
## [20241115](./202411/20241115.md) |[73. Set Matrix Zeroes(设置矩阵零)](https://leetcode.com/problems/set-matrix-zeroes/)

```
首行首列做标记，先查自身是否零；遍历矩阵标行首，扩散清零内外分；最后清理首行列，根据标记全置零
```
代码
```java
class Solution {
    public void setZeroes(int[][] matrix) {
         if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;
         int m = matrix.length, n = matrix[0].length;
        // 第一行和第一列是否存在0
         boolean row = false, col = false;
        // 设置开始的行和列是0，并且标记行列为true
         for (int i = 0; i < m; i++){
             for (int j = 0; j < n; j++){
                 if (matrix[i][j] == 0) {
                     matrix[0][j] = 0;
                     matrix[i][0] = 0;
                     if (i == 0) row = true;
                     if (j == 0) col = true;
                 }
             }
         }
         // 设置行为0
         for (int i = 1; i < m; i++){
             if (matrix[i][0] == 0){
                 for (int j = 1; j < n;j++)
                     matrix[i][j] = 0;
             }
         }
         // 设置列为0
         for (int j = 1; j < n; j++){
             if (matrix[0][j] == 0){
                 for (int i = 1; i < m; i++)
                     matrix[i][j] = 0;
             }
         }
         if (row){
             for (int j = 0; j < n; j++)
                 matrix[0][j] = 0;
         }
         if (col){
             for(int i = 0; i < m; i++)
                 matrix[i][0] = 0;
         }
    }
}
```
## [20241116](./202411/20241116.md) |[240. Search a 2D Matrix II(二维矩阵的查找)](https://leetcode.com/problems/search-a-2d-matrix-ii)

```
1. 检查矩阵是否为空，如果是，直接返回false。
2. 初始化指针到右上角：left=0，right=最后一列。
3. 在指针不越界的情况下循环：
a. 如果当前元素等于目标，返回true。
b. 如果当前元素小于目标，向下移动一行（left++）。
c. 如果当前元素大于目标，向左移动一列（right--）。
4. 如果循环结束还没找到，返回false。
```
代码
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0){
            return false;
        }
        int left = 0;
        int right = matrix[0].length - 1;
        while(left<matrix.length && right>=0){
            if(matrix[left][right] == target){
                return true;
            }else if(matrix[left][right] < target){
                left++;
            }else{
                right--;
            }
        }
        return false;
    }
}
```
# 滑动窗口
## [20241117](./202411/20241117.md) |[3. Longest Substring Without Repeating Characters(无重复字符的最长子串)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

```
滑动窗口双指针，哈希表记位置；遇重复，左跳右，更新长度取最大。
```
代码
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s==null||s.length()==0){
            return 0;
        }
        int max = 0;
        Map<Character, Integer> map = new HashMap<>();
        int j = 0;
        for(int i=0;i<s.length();i++){
            if(map.containsKey(s.charAt(i))){
                // 避免左边界 j 回退（例如 abba，当处理第二个 b 时，j 已到2，后续处理 a 时不能回到1）
                j = Math.max(j, map.get(s.charAt(i)) + 1);
            }
            map.put(s.charAt(i), i);
            // 窗口闭区间 [j, i] 的长度为 i-j+1
            max = Math.max(max, i-j+1);
        }
        return max;
    }
}
```
## [20241118](./202411/20241118.md) |[76. Minimum Window Substring(最小区间子串)](https://leetcode.com/problems/minimum-window-substring/description)

```
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
1. 需求哈希表：统计目标字符串 t 中每个字符的出现次数。
2. 滑动窗口双指针：右指针 j 扩展窗口直到满足所有字符需求，左指针 i 收缩窗口以寻找最小长度。
3. 有效窗口判断：通过 count 变量跟踪剩余需匹配的字符总数，当 count=0 时窗口有效。
4. 更新最小窗口：在收缩过程中记录最小窗口的起始位置和长度。
```
代码
```java
class Solution {
    public String minWindow(String s, String t) {
        if (s == null || t == null || s.length() < t.length()) return "";

        Map<Character, Integer> map = new HashMap<>();
        for (char c : t.toCharArray())
            map.put(c, map.getOrDefault(c, 0) + 1);

        int minLeft = 0, minRight = 0, minLen = Integer.MAX_VALUE;
        int count = t.length();
        boolean found = false;

        int i = 0; // 左指针
        for (int j = 0; j < s.length(); j++) { // 右指针扩展
            char c = s.charAt(j);
            if (map.containsKey(c)) {
                map.put(c, map.get(c) - 1);
                if (map.get(c) >= 0) count--; // 有效减少count
            }

            while (count == 0) { // 满足条件时收缩左指针
                found = true;
                int curLen = j - i + 1;
                if (curLen < minLen) {
                    minLeft = i;
                    minRight = j;
                    minLen = curLen;
                }

                char leftC = s.charAt(i);
                if (map.containsKey(leftC)) {
                    map.put(leftC, map.get(leftC) + 1);
                    if (map.get(leftC) > 0) count++; // 需求不满足，退出收缩
                }
                i++;
            }
        }

        return found ? s.substring(minLeft, minRight + 1) : "";
    }
}
```
## [20241119](./202411/20241119.md) |[239. Sliding Window Maximum(滑动窗口最大值)](https://leetcode.com/problems/sliding-window-maximum/)

```
1. 双端队列维护候选最大值：队列中按递减顺序存储可能成为窗口最大值的元素索引。
2. 清理无效元素：添加新元素时，移除队列尾部所有比当前元素小的值，确保队列递减。
3. 移除过期索引：检查队首索引是否超出窗口范围，若超出则移除。
4. 记录窗口最大值：当窗口形成时（达到大小k），队首元素即为当前窗口最大值。
```
代码
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
      if(nums == null || nums.length < 2) return nums;
        // 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序
        LinkedList<Integer> queue = new LinkedList();
        // 结果数组
        int[] result = new int[nums.length-k+1];
        // 遍历nums数组
        for(int i = 0;i < nums.length;i++){
            // 保证从大到小 如果前面数小则需要依次弹出，直至满足要求
            while(!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]){
                queue.pollLast();
            }
            // 添加当前值对应的数组下标
            queue.addLast(i);
            // 判断当前队列中队首的值是否有效
            if(queue.peek() <= i-k){
                queue.poll();   
            }
            // 当窗口长度为k时 保存当前窗口中最大值
            if(i+1 >= k){
                result[i+1-k] = nums[queue.peek()];
            }
        }
        return result;
    }
}
```
## [20241120](./202411/20241120.md) |[438. Find All Anagrams in a String(找出字符串中所有的变位词)](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

```
初始化阶段：统计p的字符频率到map数组中。
2. 窗口滑动：右指针每次移动，处理当前字符，如果该字符在p中存在且未被完全消耗，则减少count。
3. 当count为0时，说明找到一个有效窗口，记录左指针位置。
4. 当窗口大小等于p的长度时，必须移动左指针，并恢复该位置的字符计数，如果该字符属于p，则增加count。
固定窗口滑动走，右扩左缩字符数；计数归零即命中，左移恢复计数足。
```
代码
```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        if(s==null||p==null) return result;
        int[] map = new int[256]; // ASCII字符集
        for (char c : p.toCharArray()) map[c]++; // 统计p的字符频率
        int left = 0, right = 0, count = p.length(); // count表示待匹配字符数
        while (right < s.length()) {
            // 右指针移动，处理当前字符
            if (map[s.charAt(right++)]-- >= 1) count--;
            // 若count=0，说明当前窗口匹配成功
            if (count == 0) result.add(left);
            // 窗口大小等于p长度时，左指针移动
            if (right - left == p.length()) {
                if (map[s.charAt(left++)]++ >= 0) count++;
            }
        }
        return result;
    }
}
```
# 栈
## [20241121](./202411/20241121.md) |[20. Valid Parentheses(有效括号匹配)](https://leetcode.com/problems/valid-parentheses/)

```java
class Solution {
    public boolean isValid(String s) {
        if(s==null||s.length()==0){
            return true;
        }
        Stack<Character> stack = new Stack<>();
        for(char c: s.toCharArray()){
            if(c == '('){
                stack.push(')');
            }else if(c == '['){
                stack.push(']');
            }else if(c == '{'){
                stack.push('}');
            }else if(stack.isEmpty() || c != stack.pop()){
                return false;
            }
        }
        return stack.isEmpty();
    }
}
```
## [20241122](./202411/20241122.md) |[84. Largest Rectangle in Histogram(柱状图中的最大矩形)](https://leetcode.com/problems/largest-rectangle-in-histogram/)

```
1. 单调递增栈‌：维护栈内柱子高度递增，快速确定左右边界。
2. ‌左右边界确定‌：当前柱子是栈顶元素的右边界，栈顶下一个元素是左边界。
```
代码
```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        stack.push(-1); // 哨兵节点，简化边界处理
        int max = 0;
        for (int i = 0; i < heights.length; i++) {
            // 当前柱子高度 < 栈顶柱子高度时，计算栈顶柱子能形成的矩形面积
            while (stack.peek() != -1 && heights[i] < heights[stack.peek()]) {
                int h = heights[stack.pop()]; // 弹出栈顶，高度为h
                int w = i - stack.peek() - 1; // 宽度 = 右边界i - 左边界(新栈顶) -1
                max = Math.max(max, h * w);
            }
            stack.push(i); // 当前柱子入栈
        }
        // 处理栈中剩余柱子（右侧无更矮柱子）
        while (stack.peek() != -1) {
            int h = heights[stack.pop()];
            int w = heights.length - stack.peek() - 1; // 宽度 = 数组长度 - 左边界 -1
            max = Math.max(max, h * w);
        }
        return max;
    }
}
// for (遍历每个元素) {
//     while (栈非空且破坏单调性) {
//         弹出栈顶，计算结果;
//     }
//     当前元素入栈;
// }
// 处理栈中剩余元素;
```
## [20241123](./202411/20241123.md) |[155. Min Stack(最小栈)](https://leetcode.com/problems/min-stack/description/)

```
搞两个栈，一个存全部一个存最小
```
代码
```java
class MinStack {

    private Stack<Integer> stack = new Stack<>();
    private Stack<Integer> minStack = new Stack<>();

    /** initialize your data structure here. */
    public MinStack() {

    }

    public void push(int val) {
        if(minStack.isEmpty() || val<= minStack.peek()){
            minStack.push(val);
        }
        stack.push(val);
    }

    public void pop() {
       if(stack.peek().equals(minStack.peek())){
           minStack.pop();
       }
        stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```
## [20241124](./202411/20241124.md) |[394. Decode String(解码字符串)](https://leetcode.com/problems/decode-string/description/)

```
● 双栈结构‌：
  ○ ‌countStack‌：存储重复次数 k。
  ○ ‌resStack‌：存储遇到 [ 之前的结果。
● ‌操作步骤‌：
  a. 遇到数字 → 解析完整 k，压入 countStack。
  b. 遇到 [ → 压入当前结果到 resStack，重置结果。
  c. 遇到 ] → 弹出栈顶元素，拼接重复后的字符串。
  d. 普通字符 → 直接追加到当前结果。
```
代码
```java
class Solution {
    public String decodeString(String s) {
        String res = "";
        Stack<Integer> countStack = new Stack<>();
        Stack<String> resStack  = new Stack<>();
        int index = 0;
        while (index < s.length()) {
            if(Character.isDigit(s.charAt(index))){
                int count = 0;
                while(Character.isDigit(s.charAt(index))){
                    count = count * 10 + (s.charAt(index) - '0');
                    index++;
                }
                countStack.push(count);
            }else if(s.charAt(index) == '['){
                resStack.push(res);
                res = "";
                index++;
            }else if(s.charAt(index) == ']'){
                StringBuilder temp = new StringBuilder(resStack.pop());
                int repeatTimes = countStack.pop();
                while(repeatTimes-->0){
                    temp.append(res);
                }
                res = temp.toString();
                index++;
            }else{
                res += s.charAt(index++);
            }
        }
        return res;
    }
}
```
## [20241125](./202411/20241125.md) |[739. Daily Temperatures(每日温度)](https://leetcode.com/problems/daily-temperatures/description/)

```java
class Solution {
    public int[] dailyTemperatures(int[] T) {
        int[] result = new int[T.length];
        Stack<Integer> stack = new Stack<>();
        for(int i = 0 ; i<T.length; i++){
            while(!stack.isEmpty() && T[stack.peek()] < T[i]){
                result[stack.peek()] = i - stack.pop();
            }
            stack.push(i);
        }
        return result;
    }
}
```
# 双指针
## [20241126](./202411/20241126.md) |[11. Container With Most Water(盛满水的最大容器)](https://leetcode.com/problems/container-with-most-water/)

```
双指针，两头走；算面积，更最大；谁矮谁动，高者留。（在数组的两端设置指针，逐步向中间移动，寻找可能的最大面积。每次移动较矮的一侧指针，因为容器的容量由较矮的高度决定，移动较高的指针不会增加容量）
```
代码
```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int max = 0;
        while(left < right){
            int w = right - left;
            int h = Math.min(height[left], height[right]);
            int area = w * h;
            max = Math.max(area, max);
            if(height[left] < height[right]){
                left ++;
            }else if(height[left] > height[right]){
                right--;
            }else{
                left ++;
                right--;
            }
        }
        return max;
    }
}
```
## [20241127](./202411/20241127.md) |[15. 3Sum(三数之和)](https://leetcode.com/problems/3sum/)

```
1. 排序：这是解决三数之和问题的常见预处理步骤，排序后可以方便去重和使用双指针。
2. 遍历i：固定第一个数，然后后面的数用双指针处理。
3. 双指针j和k：初始时，j在i+1，k在末尾，根据三数之和调整指针。
4. 去重处理：i的去重，以及在找到解后跳过重复的j和k。
```
代码
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            // 重复元素不在计算
            if(i>0 && nums[i]==nums[i-1]){
                continue;
            }
            for(int j=i+1, k=nums.length-1;j<k;){
                if(nums[i]+nums[j]+nums[k]==0){
                    list.add(Arrays.asList(nums[i],nums[j],nums[k]));
                    j++;
                    k--;
                    while(j<k&&nums[j-1]==nums[j]){
                        j++;
                    }
                    while(j<k&&nums[k+1]==nums[k]){
                        k--;
                    }
                }else if(nums[i]+nums[j]+nums[k]<0){
                        j++;
                }else{
                        k--;
                }
            }
        }
        return list;
    }
}
```
## [20241128](./202411/20241128.md) |[42. Trapping Rain Water(接雨水)](https://leetcode.com/problems/trapping-rain-water/)
```
双指针从两侧向中间“扫描”，始终用已知的左右最大高度作为“堤坝”，计算低洼处的储水量。(双指针，两头走；左右最大，动态更) 时间复杂度 O(n)，空间复杂度 O(1)，逻辑简洁。
```
代码
```java
class Solution {
    public int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int res = 0, maxleft = 0, maxright = 0;
        while (left <= right) {
            if(height[left] <= height[right]){
                if(height[left] > maxleft){
                    maxleft = height[left];
                }else{
                    res += maxleft - height[left];
                }
                left++;
            }else{
                if(height[right] > maxright){
                    maxright = height[right];
                }else{
                    res += maxright - height[right];
                }
                right--;
            }
        }
        return res;
    }
}
```
## [20241129](./202411/20241129.md) |[283. Move Zeroes(移动零)](https://leetcode.com/problems/move-zeroes/)
```
滚雪球，零积累；非零前移，原位置零；末尾自然零填满
```
代码
```java
class Solution {
    public void moveZeroes(int[] nums) {
        int snowBallSize = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i] == 0){
                snowBallSize ++;
            }else{
                int temp = nums[i];
                nums[i-snowBallSize] = temp;
                nums[i] = 0;
            }
        }
    }
}
```
## [20241130](./202411/20241130.md) |[208. Implement Trie (Prefix Tree)(实现前缀树)](https://leetcode.com/problems/implement-trie-prefix-tree/)

```
● insert：向字典中添加一个新词条。
● search：查找一个词是否在字典中（必须完全匹配）。
● startsWith：查找字典中是否有以某个前缀开头的词。
root
└── a (end=false)
    └── p (end=false)
        └── p (end=true)  // "app" 的终点
            └── l (end=false)
                └── e (end=true)  // "apple" 的终点
```

```java
class Trie {
    // 记录该字母的下一位所有可能的字母坐标
    private Trie[] children;
    // 该字母是否为最后一个字母
    private boolean isEnd;

    public Trie() {
        // 初始化26个字母
        children = new Trie[26];
        // 默认为不是最后一个字母
        isEnd = false;
    }

    public void insert(String word) {
        // 得到字典树根节点
        Trie node = this;
        // 去遍历待插入单词的字符集合
        for (char c : word.toCharArray()) {
            // 得到该字符在数组中的坐标
            int index = c - 'a';
            // 如果正在遍历的该字母在上一个节点的数组坐标中没有记录，就新建一个字母节点在字典树中
            if (node.children[index] == null) {
                node.children[index] = new Trie();
            }
            // 每一次生成字母都移动指针到下一个字母节点
            node = node.children[index];
        }
        // 最后一个字母节点设置为最后一个字母
        node.isEnd = true;
    }

    public boolean search(String word) {
        // 返回检索到的最后一个字母节点
        Trie node = searchPrefix(word);
        // 只有当该单词在字典树中存在并且最后一个字母节点为最后一个字母，才返回true
        return node != null && node.isEnd;
    }

    public boolean startsWith(String prefix) {
        // 只要前缀匹配存在于字典树中就返回true
        return searchPrefix(prefix) != null;
    }

    // 前缀搜索 还是
    // 全文搜索都是调用此方法，区别在于前缀搜索只要前缀匹配就返回true，全文搜索则要匹配到最后一个字母才返回true，所以这里返回的是最后一个字母节点
    public Trie searchPrefix(String word) {
        // 得到字典树根节点
        Trie node = this;
        // 开始验证字符串在字典树中是否存在
        for (char c : word.toCharArray()) {
            // 得到该字符在数组中的坐标
            int index = c - 'a';
            // 如果该字符在数组中存在，就移动指针到下一个字母节点，直至到达最后一个待搜索的最后一个字母节点
            if (node.children[index] != null) {
                node = node.children[index];
            } else {
                // 如果在此过程中没有找到待搜索的其中一个字母节点，就返回null，代表该字母不存在于字典树中
                return null;
            }
        }
        // 没有问题，那就是到达了最后一个待搜索的最后一个字母节点，返回该节点(节点可能是最后一个字母节点也可能不是)
        return node;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```
# 其他
## [20241201](./202412/20241201.md) |[31. Next Permutation(下一个排列)](https://leetcode.com/problems/next-permutation/description/)

```
“一找二换三反转”
● 一找：找第一个降序点 i。
● 二换：找右侧比 nums[i] 大的最小 j，交换。
● 三反转：反转 i 右侧元素。
以 nums = [1,3,2] 为例：
1. 找 i：从后向前找到 i=0（1 < 3）。
2. 找 j：从后找到 j=2（nums[2]=2 > 1）。
3. 交换：[1,3,2] → [2,3,1]。
4. 反转右侧：反转 i+1 后的元素 [3,1] → [1,3]，得到结果 [2,1,3]。
● 全降序数组（如 [3,2,1]）：i 会为 -1，直接反转整个数组得到最小排列 [1,2,3]。
● 无重复元素：算法逻辑与有重复元素时一致，仍能正确找到下一个排列。
```
代码
```java
class Solution {
    public void nextPermutation(int[] nums) {
        if (nums == null || nums.length <= 1) return;
        int i = nums.length - 2;
        // 从后向前找第一个降序点 i
        while (i >= 0 && nums[i] >= nums[i + 1]) i--;
        if (i >= 0) {
            int j = nums.length - 1;
            // 找右侧比 nums[i] 大的最小 j
            while (nums[j] <= nums[i]) j--;
            swap(nums, i, j);
        }
        // 反转 i 右侧元素（若 i=-1，反转整个数组）
        reverse(nums, i + 1, nums.length - 1);
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    private void reverse(int[] nums, int start, int end) {
        while (start < end) swap(nums, start++, end--);
    }
}
```

## [20241202](./202412/20241202.md) |[41. First Missing Positive(发现第一个缺失的正数)](https://leetcode.com/problems/first-missing-positive/)

```
题目: 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
1. 原地哈希：将每个正整数 i 调整到数组的第 i-1 的位置。
2. 交换条件：若当前元素是正数且在数组长度范围内，且未在正确位置，则持续交换。
3. 扫描结果：遍历数组，第一个不满足 nums[i] == i+1 的位置即为缺失的最小正整数。
```
代码
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for(int i = 0; i < n; i++) {
            while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])
                swap(nums, i, nums[i] - 1);
        }
        for(int i = 0; i < n; i++)
            if(nums[i] != i + 1)
                return i + 1;
        return n + 1;
    }
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```
## [20241203](./202412/20241203.md) |[53. Maximum Subarray(最大子段和)](https://leetcode.com/problems/maximum-subarray/description/)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums==null||nums.length==0){
            return 0;
        }
        int sum = nums[0];
        int max = sum;
        for(int i = 1;i<nums.length;i++){
            if(sum + nums[i] < nums[i]){
                sum = nums[i];
            }else{
                sum += nums[i];
            }
            max = Math.max(max, sum);
        }
        return max;
    }
}
```
## [20241204](./202412/20241204.md) |[56. Merge Intervals(区间交集)](https://leetcode.com/problems/merge-intervals/description/)

```
排序起点 → 首区入列 → 逐个合并
```
代码
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length <=1){
            return intervals;
        }
        // 1. 按起点排序
        Arrays.sort(intervals, (a,b)->Integer.compare(a[0], b[0]));

        // 2. 初始基准区间
        List<int[]> result = new ArrayList<>();
        int[] newInterval = intervals[0];
        result.add(newInterval);

        for(int[] interval : intervals){
            if (interval[0] <= newInterval[1]) {
                // 3. 重叠则合并终点
                newInterval[1] = Math.max(newInterval[1], interval[1]);
            }else {
                // 4. 不重叠则更新基准
                newInterval = interval;
                result.add(newInterval);
            }
        }
        return result.toArray(new int[result.size()][]);
    }
}
```

## [20241205](./202412/20241205.md) |[75. Sort Colors(三色排序)](https://leetcode.com/problems/sort-colors/description/)

```
1. ‌left‌：指向下一个0应放置的位置（左边界）。
2. ‌right‌：指向下一个2应放置的位置（右边界）。
3. ‌current‌：遍历指针，检查当前元素。
```
代码
```java
class Solution {
    public void sortColors(int[] nums) {
        int len = nums.length;
        if(len < 2){
            return;
        }

        int left = 0;
        int right = len - 1;
        int current = 0;
        while(current <= right) {
            if(nums[current] == 0){
                swap(nums, left, current);
                left++;
                current++;
            }else if(nums[current] == 1) {
                current++;
            }else {
                swap(nums, right, current);
                right--;
            }
        }
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```
## [20241206](./202412/20241206.md) |[136. Single Number(单一数字)](https://leetcode.com/problems/single-number/)
```java
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for(int i=0; i<nums.length; i++){
            result ^= nums[i];
        }
        return result;
    }
}
```
## [20241207](./202412/20241207.md) |[169. Majority Element(主要元素)](https://leetcode.com/problems/majority-element)

```java
class Solution {

    public int majorityElement(int[] nums) {
        quickSort(nums, 0, nums.length-1);
        return nums[nums.length/2];
    }

    public int majorityElement3(int[] nums) {
        int count = 0;
        Integer candidate = null;
        for(int num : nums){
            if(count == 0){
                candidate = num;
            }
            count += (num==candidate) ? 1 : -1;
        }
        return candidate;
    }

    public int majorityElement2(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        int result = -1;
        for(int i=0;i<nums.length;i++){
            map.put(nums[i], map.containsKey(nums[i])? map.get(nums[i])+ 1 : 0);
            if(map.get(nums[i]) >= nums.length/2){
                return nums[i];
            }
        }
        return result;
    }

    public void quickSort(int[] nums, int begin, int end){
        if(begin < end){
            int pivot = nums[begin];
            int i = begin;
            int j = end;
            while(i < j){
                while(i<j && pivot < nums[j]){
                    j--;
                }
                if(i<j){
                    nums[i] = nums[j];
                    nums[j] = pivot;
                    i++;
                }
                while(i<j && nums[i] < pivot){
                    i++;
                }
                if(i<j){
                    nums[j] = nums[i];
                    nums[i] = pivot;
                    j--;
                }
            }
            quickSort(nums, begin, i-1);
            quickSort(nums, i+1, end);
        }
    }
}
```
## [20241208](./202412/20241208.md) |[189. Rotate Array(旋转数组)](https://leetcode.com/problems/rotate-array/description/)

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums, 0, nums.length-1);
        reverse(nums, 0, k-1);
        reverse(nums, k, nums.length-1);
    }

    private void reverse(int[] nums, int begin, int end){
        while(begin < end){
            int temp = nums[begin];
            nums[begin] = nums[end];
            nums[end] = temp;
            begin ++;
            end --;
        }
    }

}
```
## [20241209](./202412/20241209.md) |[238. Product of Array Except Self(除自身以外数组的乘积)](https://leetcode.com/problems/product-of-array-except-self)
```
左右乘积分两次，左到右来右到左；初始为1递推乘，合并结果即所求
- 计算每个元素的左边乘积，存储到left数组。
- 计算每个元素的右边乘积，存储到right数组。
- 结果数组是left和right对应元素的乘积。
```
代码
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] leftProducts = new int[n];
        int[] rightProducts = new int[n];
        int[] result = new int[n];

        // Calculate left products
        leftProducts[0] = 1;
        for (int i = 1; i < n; i++) {
            leftProducts[i] = leftProducts[i - 1] * nums[i - 1];
        }

        // Calculate right products
        rightProducts[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            rightProducts[i] = rightProducts[i + 1] * nums[i + 1];
        }

        // Calculate the final result
        for (int i = 0; i < n; i++) {
            result[i] = leftProducts[i] * rightProducts[i];
        }

        return result;
    }
}
```
## [20241210](./202412/20241210.md) |[287. Find the Duplicate Number(发现重复出现的元素)](https://leetcode.com/problems/find-the-duplicate-number/)
```java
class Solution {
    public int findDuplicate(int[] nums) {
        int[] duplicate = new int[nums.length];
        for(int i = 0; i< nums.length;i++){
            duplicate[nums[i]] ++;
        }
        for(int i = 0; i< duplicate.length;i++){
            if(duplicate[i] > 1){
                return i;
            }
        }
        return -1;
    }
}
```
