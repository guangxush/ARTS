## Algorithm

[862. Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/)

### Description

Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1.

A subarray is a contiguous part of an array.

Example 1:

```
Input: nums = [1], k = 1
Output: 1
```

Example 2:

```
Input: nums = [1,2], k = 4
Output: -1
```

Example 3:

```
Input: nums = [2,-1,2], k = 3
Output: 3
```

Constraints:

- 1 <= nums.length <= 105
- -105 <= nums[i] <= 105
- 1 <= k <= 109

### Solution

```java
class Solution {
    public int shortestSubarray(int[] nums, int k) {
        //create a prefix sum array
        long[] prefixSum = new long[nums.length+1];

        //populate it
        for(int i = 0; i< prefixSum.length-1; i++) {
            prefixSum[i+1] = prefixSum[i] + nums[i];
        }

        //store ans
        int ans = prefixSum.length;

        //create a dq for storing starting point of subarray and to push and pop from back and front
        Deque<Integer> startingIdx = new LinkedList<>();

        for(int i=0; i< prefixSum.length; i++) {

            while(startingIdx.size()>0 && prefixSum[i] - prefixSum[startingIdx.peek()] >= k) {
                ans = Math.min(ans, i-startingIdx.poll());
            }
            while(startingIdx.size()>0 && prefixSum[i] <= prefixSum[startingIdx.peekLast()]) {
                startingIdx.pollLast();
            }
            startingIdx.add(i);

        }

        return  ans <= nums.length? ans: -1;
    }
}
```

### Discuss

## Review


## Tip


## Share
