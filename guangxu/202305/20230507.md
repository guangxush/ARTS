## Algorithm

### Description

给你两个整数数组 present 和 future，其中 present[i] 是第 i 支股票当前的价格，future[i] 是第 i 支股票未来的价格。你还有一个整数 budget，表示你初始的预算金额。​

你可以买入任意数量的任意股票（前提是不超过预算），并且在未来以对应价格卖出你持有的所有股票。注意：你不能买入部分股票，只能整股买入；每支股票的买入数量可以是 0 或正整数。​

请你返回通过交易能获得的最大利润。


示例 1​

```
输入：present = [5,4,3,2,1], future = [8,5,4,3,5], budget = 10​
输出：6​
解释：买入第 0 支股票 2 股，花费 5*2=10，未来卖出得 8*2=16，利润 6；其他组合利润均低于 6。
```
​
示例 2​

```
输入：present = [2,2,2], future = [3,3,3], budget = 3​
输出：1​
解释：买入 1 股任意股票，花费 2，卖出得 3，利润 1。​
```

3. 约束条件​
- 1 <= present.length == future.length <= 1000​
- 1 <= present[i], future[i] <= 100​
- 1 <= budget <= 1000​


### Solution

```java 
class Solution {
    public int maximumProfit(int[] present, int[] future, int budget) {
        // 初始化dp数组
        int[] dp = new int[budget + 1];
        int n = present.length;
        
        for (int i = 0; i < n; i++) {
            int cost = present[i];
            int profit = future[i] - cost;
            // 仅收益为正才考虑
            if (profit > 0) {
                // 完全背包正序遍历
                for (int j = cost; j <= budget; j++) {
                    dp[j] = Math.max(dp[j], dp[j - cost] + profit);
                }
            }
        }
        
        return dp[budget];
    }

    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        // 示例1
        int[] present1 = {5,4,3,2,1};
        int[] future1 = {8,5,4,3,5};
        int budget1 = 10;
        System.out.println(solution.maximumProfit(present1, future1, budget1)); // 输出6
        
        // 示例2
        int[] present2 = {2,2,2};
        int[] future2 = {3,3,3};
        int budget2 = 3;
        System.out.println(solution.maximumProfit(present2, future2, budget2)); // 输出1
    }
}
```

### Discuss


该问题本质是 完全背包问题（每种物品可选择多次）的变种，核心思路如下：
​
1. 问题转化​
每支股票 = 一个 “物品”，买入成本 = present[i]，单股收益 = future[i] - present[i]（仅当收益为正时，买入才有意义）。​
背包容量 = budget，目标 = 选择若干股票（可重复选），总成本不超过预算，总收益最大。​

2. 动态规划定义​
定义 dp[j]：预算为 j 时能获得的最大利润。​
初始状态：dp[0] = 0（预算为 0 时利润为 0），其余 dp[j] = 0（初始无交易利润为 0）。​

3. 状态转移方程​
对于每支收益为正的股票 i，遍历预算从 present[i] 到 budget：​
dp[j]=max(dp[j],dp[j−present[i]]+(future[i]−present[i]))
含义：预算 j 时的最大利润，要么不买第 i 支股票（保持 dp[j]），要么买第 i 支股票（用 j - present[i] 预算的利润 + 单股收益）。


4. 复杂度分析
​
时间复杂度 O(n×budget) 空间复杂度 ​O(budget)
​
​

## Review


## Tip


## Share
