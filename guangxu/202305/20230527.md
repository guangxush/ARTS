## Algorithm

[最优账单平衡](https://leetcode.cn/problems/optimal-account-balancing/description/)

### Description

一群朋友在聚餐时会互相借钱，比如 A 借给 B 10 美元，记为 (A, B, 10)。请你计算结清所有债务所需的最少交易次数。
注意：
- 交易只能是两人之间的直接转账，每次转账可以是任意金额；
- 所有债务最终需完全结清（即每个人的收支总和为 0）；
- 输入是一个二维整数数组 transactions，其中 transactions[i] = [from, to, amount] 表示 from 借给 to 共计 amount 美元。

示例 1

```
输入：transactions = [[0,1,10],[2,0,5]]输出：2解释：
第一次交易：1 转给 0 10 美元（结清 0 借给 1 的债务）；
第二次交易：0 转给 2 5 美元（结清 2 借给 0 的债务）；
或更优方式：1 转给 0 5 美元，1 转给 2 5 美元（同样 2 次交易）。
```

示例 2

```
输入：transactions = [[0,1,10],[1,0,1],[1,2,5],[2,0,5]]输出：1解释：
最终收支：0 净收入 4 美元，1 净支出 4 美元，2 收支平衡；
仅需 1 次交易：1 转给 0 4 美元即可结清所有债务。
提示
1 <= transactions.length <= 8
0 <= from, to <= 12
1 <= amount <= 100
```

### Solution

```java
class Solution {
    private int minTransactions = Integer.MAX_VALUE;

    public int minTransfers(int[][] transactions) {
        // 步骤1：统计每个人的净收支
        Map<Integer, Integer> balanceMap = new HashMap<>();
        for (int[] t : transactions) {
            int from = t[0], to = t[1], amount = t[2];
            balanceMap.put(from, balanceMap.getOrDefault(from, 0) - amount);
            balanceMap.put(to, balanceMap.getOrDefault(to, 0) + amount);
        }

        // 步骤2：过滤出需要结算的债务（收支≠0）
        List<Integer> debts = new ArrayList<>();
        for (int val : balanceMap.values()) {
            if (val != 0) {
                debts.add(val);
            }
        }

        // 步骤3：回溯找最少交易次数
        backtrack(debts, 0, 0);
        return minTransactions;
    }

    // 回溯函数：处理第 index 个债务，当前已交易次数为 count
    private void backtrack(List<Integer> debts, int index, int count) {
        // 剪枝：当前次数已超过已知最小值，无需继续
        if (count >= minTransactions) {
            return;
        }

        // 跳过已结清的账户（净收支为0）
        while (index < debts.size() && debts.get(index) == 0) {
            index++;
        }

        // 所有账户已结清，更新最小交易次数
        if (index == debts.size()) {
            minTransactions = Math.min(minTransactions, count);
            return;
        }

        // 尝试将当前账户的债务与后续账户抵消
        int current = debts.get(index);
        for (int i = index + 1; i < debts.size(); i++) {
            int next = debts.get(i);
            // 收支符号相反，可抵消
            if (current * next < 0) {
                // 转账：将当前账户的债务转移给 next 账户
                debts.set(i, next + current);
                // 递归处理下一个账户，交易次数+1
                backtrack(debts, index + 1, count + 1);
                // 回溯：恢复状态
                debts.set(i, next);

                // 剪枝：若当前转账刚好完全抵消两个账户的债务，无需再尝试其他组合
                if (current + next == 0) {
                    break;
                }
            }
        }
    }
}
```

### Discuss

## Review


## Tip


## Share
