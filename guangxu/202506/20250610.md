## Algorithm

### 多线程交替打印0-100
(1) 方法一：使用volatile

```java
public class PrintOneTwo {

    private static volatile int num = 1;

    public static void main(String[] args) {
        Thread thread1 = new Thread(()->{
          while(true){
              if(num % 2 != 0) {
                  System.out.println("thread1: " + num);
                  num++;
              }
              if(num > 100){
                  break;
              }
          }
        });
        Thread thread2 = new Thread(()->{
            while(true){
                if(num % 2 == 0) {
                    System.out.println("thread2: " + num);
                    num++;
                }
                if(num > 100){
                    break;
                }
            }
        });
        thread1.start();
        thread2.start();
    }
}
```

（2）方法2使用synchronized

```Java
public class PrintOneTwo2 {
    private static Object object = new Object();
    private static int num = 0;

    public static void main(String[] args) {
        Thread thread1 = new Thread(()->{
            synchronized (object){
                while(num < 100){
                    object.notify();
                    System.out.println("thread1: " + num);
                    num++;
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        Thread thread2 = new Thread(()->{
            synchronized (object){
                while (num < 100){
                    object.notify();
                    System.out.println("thread2: " + num);
                    num++;
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        thread1.start();
        thread2.start();
    }
}
```

### 多线程交替打印"ABC"

```java
public class PrintABC {
    private static PrintABC abc = new PrintABC();
    private static volatile int i = 1;

    public static void main(String[] args) {
        Thread threadA = new Thread(() -> {
            while (i < 100) {
                synchronized (abc) {
                    while (i % 3 != 1) {
                        try {
                            abc.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                    }
                    System.out.println("threadA : A");
                    i++;
                    abc.notifyAll();
                }
            }
        });
        Thread threadB = new Thread(() -> {
            while (i < 100) {
                synchronized (abc) {
                    while (i % 3 != 2) {
                        try {
                            abc.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                    }
                    System.out.println("threadB : B");
                    i++;
                    abc.notifyAll();
                }
            }
        });
        Thread threadC = new Thread(() -> {
            while (i < 100) {
                synchronized (abc) {
                    while (i % 3 != 0) {
                        try {
                            abc.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    System.out.println("threadC : C");
                    i++;
                    abc.notifyAll();
                }
            }
        });
        threadA.start();
        threadB.start();
        threadC.start();
    }
}
```

### 多线程顺序打印ABC
（1）Join的方式

```Java
public class MyJoin {

    public static void main(String[] args) {
        Thread threadA = new Thread(()->{
            System.out.println("threadA : A");
        });
        Thread threadB = new Thread(()->{
            try {
                threadA.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("threadA : B");
        });
        Thread threadC = new Thread(()->{
            try {
                threadB.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("threadA : C");
        });
        threadC.start();
        threadB.start();
        threadA.start();
    }
}
```

(2) Semaphore方式
```JAVA
public class MySemaphore {

    private static Semaphore semaphore1 = new Semaphore(1);
    private static Semaphore semaphore2 = new Semaphore(0);

    public static void main(String[] args) {
        Thread threadA = new Thread(()->{
            try {
                semaphore1.acquire(); // 获取许可1
                System.out.println("threadA : A");
                semaphore2.release(); // 释放许可，允许2执行
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        Thread threadB = new Thread(()->{
            try {
                semaphore2.acquire(); // 获取许可2，确保1执行结束
                System.out.println("threadB : B");
                semaphore1.release(); // 释放许可1
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        Thread threadC = new Thread(()->{
            try {
                semaphore1.acquire(); // 获取许可1
                System.out.println("threadC : C");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        threadA.start();
        threadC.start();
        threadB.start();
    }
}
```

(3)CountDownLatch
```JAVA
public class MyCountDownLatch {

    private static CountDownLatch latch1 = new CountDownLatch(1);
    private static CountDownLatch latch2 = new CountDownLatch(1);

    public static void main(String[] args) {
        Thread threadA = new Thread(()->{
            System.out.println("threadA : A");
            latch1.countDown();//执行完成释放latch1
        });
        Thread threadB = new Thread(()->{
            try {
                latch1.await();// 等待latch1释放
                System.out.println("threadB : B");
                latch2.countDown();//执行完成释放latch2
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        Thread threadC = new Thread(()->{
            try {
                latch2.await();// 等待latch2释放
                System.out.println("threadC : C");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        threadC.start();
        threadB.start();
        threadA.start();
    }
}
```

### 单例模式doublecheck

```JAVA
public class SingletonTest {
    // 防止指令重排序，返回为赋值的对象
    private static volatile SingletonTest singletonTest;

    private SingletonTest(){}

    public static SingletonTest getSingleInstant(){
        if(null == singletonTest){
            // 防止创建对象的过程还没有结束，重新创建重复对象，因此加锁
            synchronized (SingletonTest.class){
                if(null == singletonTest){
                    // 1. 创建SingletonTest空白对象；2. 初始化SingletonTest对象；3. 复制给静态变量singletonTest
                    singletonTest = new SingletonTest();
                }
            }
        }
        return singletonTest;
    }

    public static void main(String[] args) {
        System.out.println("获取单例1:" + getSingleInstant());
        System.out.println("获取单例2:" + getSingleInstant());
    }
}
```

### Description

### Solution

```java

```

### Discuss

## Review


## Tip


## Share
