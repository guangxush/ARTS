## Algorithm

[3573. 买卖股票的最佳时机 V](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-v/description/)

### Description

给你一个整数数组 prices，其中 prices[i] 是第 i 天股票的价格（美元），以及一个整数 k。

你最多可以进行 k 笔交易，每笔交易可以是以下任一类型：

- 普通交易：在第 i 天买入，然后在之后的第 j 天卖出，其中 i < j。你的利润是 prices[j] - prices[i]。

- 做空交易：在第 i 天卖出，然后在之后的第 j 天买回，其中 i < j。你的利润是 prices[i] - prices[j]。

注意：你必须在开始下一笔交易之前完成当前交易。此外，你不能在已经进行买入或卖出操作的同一天再次进行买入或卖出操作。

通过进行 最多 k 笔交易，返回你可以获得的最大总利润。
 

示例 1:

```
输入: prices = [1,7,9,8,2], k = 2
输出: 14
解释:
- 我们可以通过 2 笔交易获得 14 美元的利润：
- 一笔普通交易：第 0 天以 1 美元买入，第 2 天以 9 美元卖出。
- 一笔做空交易：第 3 天以 8 美元卖出，第 4 天以 2 美元买回。
```

示例 2:

```
输入: prices = [12,16,19,19,8,1,19,13,9], k = 3
输出: 36

解释:
- 我们可以通过 3 笔交易获得 36 美元的利润：
- 一笔普通交易：第 0 天以 12 美元买入，第 2 天以 19 美元卖出。
- 一笔做空交易：第 3 天以 19 美元卖出，第 4 天以 8 美元买回。
- 一笔普通交易：第 5 天以 1 美元买入，第 6 天以 19 美元卖出。
```

提示:

- 2 <= prices.length <= 103
- 1 <= prices[i] <= 109
- 1 <= k <= prices.length / 2

### Solution

```java 
class Solution {
    private int[] prices;
    private long[][][] memo;

    public long maximumProfit(int[] prices, int k) {
        this.prices = prices;
        int n = prices.length;
        memo = new long[n][k + 1][3];
        for (long[][] mat : memo) {
            for (long[] row : mat) {
                 // -1 表示还没有计算过
                Arrays.fill(row, -1);
            }
        }
        return dfs(n - 1, k, 0);
    }

    // 在 [0,i] 中完成至多 j 笔交易，第 i 天结束时的状态为 endState 的情况下的最大收益
    private long dfs(int i, int j, int endState) {
        if (j < 0) {
            return Long.MIN_VALUE / 2; // 除 2 防止溢出
        }
        if (i < 0) {
            return endState > 0 ? Long.MIN_VALUE / 2 : 0;
        }
        if (memo[i][j][endState] != -1) { // 之前计算过
            return memo[i][j][endState];
        }
        int p = prices[i];
        if (endState == 0) {
            return memo[i][j][endState] = Math.max(dfs(i - 1, j, 0),
                    Math.max(dfs(i - 1, j, 1) + p, dfs(i - 1, j, 2) - p));
        }
        if (endState == 1) {
            return memo[i][j][endState] = Math.max(dfs(i - 1, j, 1), dfs(i - 1, j - 1, 0) - p);
        }
        return memo[i][j][endState] = Math.max(dfs(i - 1, j, 2), dfs(i - 1, j - 1, 0) + p);
    }
}
```

### Discuss

## Review


## Tip


## Share
