## Algorithm

[72. Edit Distance](https://leetcode.com/problems/edit-distance/)

### Description

Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

You have the following 3 operations permitted on a word:

Insert a character
Delete a character
Replace a character
Example 1:

Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
Example 2:

Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation:
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')

### Solution

```Java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        int[][] dp = new int[len1+1][len2+1];
        for(int i=0;i<=len1;i++){
          dp[i][0] = i;
        }
        for(int j=0;j<=len2;j++){
          dp[0][j] = j;
        }
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    //字符相等直接同时减小1个
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    //dp[i-1][j-1] 替换
                    //dp[i - 1][j] 删除第一个
                    //dp[i][j - 1] 删除第二个
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
            }
        }
        return dp[len1][len2];
    }
}
```


### 解题思路

```
if s1[i] == s2[j]:
 啥都别做（skip）
 i, j 同时向前移动
else:
 三选一：
 插入（insert）
 删除（delete）
 替换（replace）
```

```python
这里 dp(i, j) 函数的定义是这样的：
def dp(i, j) -> int
# 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离
记住这个定义之后，先来看这段代码：
if s1[i] == s2[j]:
 return dp(i - 1, j - 1) # 啥都不做
# 解释：
# 本来就相等，不需要任何操作
# s1[0..i] 和 s2[0..j] 的最小编辑距离等于
# s1[0..i-1] 和 s2[0..j-1] 的最小编辑距离
# 也就是说 dp(i, j) 等于 dp(i-1, j-1)
如果 s1[i]！=s2[j] ，就要对三个操作递归了，稍微需要点思考：
dp(i, j - 1) + 1, # 插入
# 解释：
# 我直接在 s1[i] 插入一个和 s2[j] 一样的字符
# 那么 s2[j] 就被匹配了，前移 j，继续跟 i 对比
# 别忘了操作数加一

dp(i - 1, j) + 1, # 删除
# 解释：
# 我直接把 s[i] 这个字符删掉
# 前移 i，继续跟 j 对比
# 操作数加一

dp(i - 1, j - 1) + 1 # 替换
# 解释：
# 我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了
# 同时前移 i，j 继续对比
# 操作数加一
```

```python
dp[i][j] 的含义和之前的 dp 函数类似：
def dp(i, j) -> int
# 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离
dp[i-1][j-1]
# 存储 s1[0..i] 和 s2[0..j] 的最小编辑距离
```

## Review



## Tip

### HashCode 真是根据对象内存地址生成的？

总的来说有 6 种生成 hashCode 的方式：
```
- 0: A randomly generated number
- 1: A function of memory address of the object
- 2: A hardcoded 1 (used for sensitivity testing.)
- 3: A sequence.
- 4: The memory address of the object, cast to int
- 5（else）: Thread state combined with xor-shift[1]
```

JDK1.8 中生成 hashCode 的方式是 5， 也就是走程序的 else 路径，即使用 Xorshift，并不是之前认为的对象内存地址「1」，以为老版本是采用对象内存地址的方式，所以继续查看其他版本

JDK1.6[2] 和 JDK1.7[3] 版本生成 hashCode 的方式「1」随机数的形式

hash 值是存在对象头中的，我们还知道对象头中还可能存储线程ID，所以他们在某些情形中还会存在冲突

### 对象头中 hashCode 和 偏向锁的冲突

jvm 启动时，可以使用 -XX:+UseBiasedLocking=true 开启偏向锁，（关于偏向锁，轻量级锁，重量级锁大家查阅 synchronized 相关文档就可以），这里引 OpenJDK Wiki[4] 里面的图片加以文字说明整个冲突过程

调用 Object 的 hashCode() 方法或者 System.identityHashCode() 方法会让对象不能使用偏向锁。到这里你也就应该知道了，如果你还想使用偏向锁，那最好重写 hashCode() 方法，避免使偏向锁失效.

### hashCode契约

Object.hashCode是一个native方法，看不到源码（Java代码，Oracle的JDK是看不到的，OpenJDK或其他开源JRE是可以找到对应的C/C++代码）。

Object.hashCode()在JRE（Java Runtime Library）中应该遵循的一些契约（contract）：

- 一致性（consistent），在程序的一次执行过程中，对同一个对象必须一致地返回同一个整数。

- 如果两个对象通过equals(Object)比较，结果相等，那么对这两个对象分别调用hashCode方法应该产生相同的整数结果。（PS：这里equals和hashCode说的都是Object类的）

- 如果两个对象通过java.lang.Object.equals(java.lang.Ojbect)比较，结果不相等，不必保证对这两个对象分别调用hashCode也返回两个不相同的整数。

实际上java.lang包里面的类，都是JRE必须的，属于运行时库（Runtime Library），这也是为什么很多JRE下该类的class文件被打包到rt.jar中的原因（应该是Runtime的简写）。

而这些运行时库一般都是跟JDK/JRE一起发布的；所以，对于不同的JRE环境，问题的答案未必相同。

### 参考文档

[1]
xor-shift算法: https://en.wikipedia.org/wiki/Xorshift
[2]
JDK1.6代码: http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/5cec449cc409/src/share/vm/runtime/globals.hpp#l1128
[3]
JDK1.7代码: http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/5b9a416a5632/src/share/vm/runtime/globals.hpp#l1100
[4]
OpenJDK Wiki: https://wiki.openjdk.java.net/display/HotSpot/Synchronization
[5]
默认hashCode生成方式: https://srvaroa.github.io/jvm/java/openjdk/biased-locking/2017/01/30/hashCode.html

## Share
