| 标题 | Algorithm |
| - | - |
| [20221004](./202210/20221004.md) |[88. Merge Sorted Array(数组和字符串:合并排序的数组)](https://leetcode.com/problems/merge-sorted-array/)|
| [20220718](./202207/20220718.md) |[27. Remove Element(移除元素)](https://leetcode.com/problems/remove-element/)|
| [20220708](./202207/20220708.md) |[26. Remove Duplicates from Sorted Array(移除数组中的重复元素)](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)|
| [20220709](./202207/20220709.md) |[80. Remove Duplicates from Sorted Array II(移除数组中的重复元素2)](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)|
| [20241207](./202412/20241207.md) |[169. Majority Element(主要元素)](https://leetcode.com/problems/majority-element)|
| [20241208](./202412/20241208.md) |[189. Rotate Array(旋转数组)](https://leetcode.com/problems/rotate-array/description/)|
| [20241108](./202411/20241108.md) |[121. Best Time to Buy and Sell Stock(买卖股票的最佳时机)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)|
| [20220408](./202204/20220408.md) |[122. Best Time to Buy and Sell Stock II(买卖股票最佳时间2)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)|
| [20220405](./202204/20220405.md) |[55. Jump Game(跳跃游戏)](https://leetcode.com/problems/jump-game/)|
| [20241106](./202411/20241106.md) |[45. Jump Game II(贪心算法-跳跃游戏2)](https://leetcode.com/problems/jump-game-ii/)|
| [20241209](./202412/20241209.md) |[238. Product of Array Except Self(除自身以外数组的乘积)](https://leetcode.com/problems/product-of-array-except-self)|
| [20211216](./202112/20211216.md) |[134. Gas Station(加油站)](https://leetcode.com/problems/gas-station/)|
| [20211217](./202112/20211217.md) |[135. Candy(糖果-贪心算法)](https://leetcode.com/problems/candy/)|
| [20241128](./202411/20241128.md) |[42. Trapping Rain Water(接雨水)](https://leetcode.com/problems/trapping-rain-water/)|
| [20220826](./202208/20220826.md) |[13. Roman to Integer(罗马转整数)](https://leetcode.com/problems/roman-to-integer/)|
| [20220825](./202208/20220825.md) |[12. Integer to Roman(整数转罗马)](https://leetcode.com/problems/integer-to-roman/)|
| [20220116](./202201/20220116.md) |[58. Length of Last Word(最后一个单词长度)](https://leetcode.com/problems/length-of-last-word/)|
| [20220109](./202201/20220109.md) |[14. Longest Common Prefix(最长公共前缀)](https://leetcode.com/problems/longest-common-prefix/)|
| [20210701](./202107/20210701.md) |[151. Reverse Words in a String(翻转字符串里的单词)](https://leetcode.com/problems/reverse-words-in-a-string/)|
| [20221204](./202212/20221204.md) |[6. Zigzag Conversion(之字形转换)](https://leetcode.com/problems/zigzag-conversion/)|
| [20220424](./202204/20220424.md) |[68. Text Justification(公平文本)](https://leetcode.com/problems/text-justification/)|
| [20220102](./202201/20220102.md) |[125. Valid Palindrome(双指针:有效回文串)](https://leetcode.com/problems/valid-palindrome/)|
| [20220611](./202206/20220611.md) |[392. Is Subsequence(是否是子串)](https://leetcode.com/problems/is-subsequence/)|
| [20241126](./202411/20241126.md) |[11. Container With Most Water(盛满水的最大容器)](https://leetcode.com/problems/container-with-most-water/)|
| [20241127](./202411/20241127.md) |[15. 3Sum(三数之和)](https://leetcode.com/problems/3sum/)|
| [20210703](./202107/20210703.md) |[209. Minimum Size Subarray Sum(滑动窗口:长度最小的子数组)](https://leetcode.com/problems/minimum-size-subarray-sum/)|
| [20241117](./202411/20241117.md) |[3. Longest Substring Without Repeating Characters(无重复字符的最长子串)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)|
| [20221129](./202211/20221129.md) |[30. Substring with Concatenation of All Words(串联所有单词的子串)](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)|
| [20220721](./202207/20220721.md) |[36. Valid Sudoku(矩阵:有效数独)](https://leetcode.com/problems/valid-sudoku/)|
| [20241114](./202411/20241114.md) |[54. Spiral Matrix(螺旋矩阵)](https://leetcode.com/problems/spiral-matrix/description)|
| [20211213](./202112/20211213.md) |[48. Rotate Image(旋转图像)](https://leetcode.com/problems/rotate-image/)|
| [20241115](./202411/20241115.md) |[73. Set Matrix Zeroes(设置矩阵零)](https://leetcode.com/problems/set-matrix-zeroes/)|
| [20241017](./202410/20241017.md) |[49. Group Anagrams(哈希-字母异位词分组)](https://leetcode.com/problems/group-anagrams/description)|
| [20241016](./202410/20241016.md) |[1. Two Sum(两数之和)](https://leetcode.com/problems/two-sum/description/)|
| [20211028](./202110/20211028.md) |[202. Happy Number(快乐数)](https://leetcode.com/problems/happy-number/)|
| [20241018](./202410/20241018.md) |[128. Longest Consecutive Sequence(最长连续子序列)](https://leetcode.com/problems/longest-consecutive-sequence/)|
| [20241204](./202412/20241204.md) |[56. Merge Intervals(区间-区间交集)](https://leetcode.com/problems/merge-intervals/description/)|
| [20221125](./202211/20221125.md) |[57. Insert Interval(插入区间)](https://leetcode.com/problems/insert-interval/)|
| [20220901](./202209/20220901.md) |[32. Longest Valid Parentheses(栈:最长有效括号)](https://leetcode.com/problems/longest-valid-parentheses/)|
| [20220829](./202208/20220829.md) |[71. Simplify Path(简化路径)](https://leetcode.com/problems/simplify-path/)|
| [20220121](./202201/20220121.md) |[150. Evaluate Reverse Polish Notation(计算逆波兰表达式)](https://leetcode.com/problems/evaluate-reverse-polish-notation/)|
| [20241123](./202411/20241123.md) |[155. Min Stack(最小栈)](https://leetcode.com/problems/min-stack/description/)|
| [20210926](./202109/20210926.md) |[224. Basic Calculator(基本计算器)](https://leetcode.com/problems/basic-calculator/)|
| [20241123](./202411/20241123.md) |[155. Min Stack(最小栈)](https://leetcode.com/problems/min-stack/description/)|
| [20241027](./202410/20241027.md) |[141. Linked List Cycle(链表:环形链表)](https://leetcode.com/problems/linked-list-cycle/description/)|
| [20241020](./202410/20241020.md) |[2. Add Two Numbers(链表-两数相加)](https://leetcode.com/problems/add-two-numbers)|
| [20241022](./202410/20241022.md) |[21. Merge Two Sorted Lists(合并两个排序链表)](https://leetcode.com/problems/merge-two-sorted-lists/)|
| [20241026](./202410/20241026.md) |[138. Copy List with Random Pointer(带随机指针Copy链表)](https://leetcode.com/problems/copy-list-with-random-pointer)|
| [20220803](./202208/20220803.md) |[92. Reverse Linked List II(反转链表2)](https://leetcode.com/problems/reverse-linked-list-ii/)|
| [20241021](./202410/20241021.md) |[19. Remove Nth Node From End of List(移除链表中倒数第N个元素)](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)|
| [20241025](./202410/20241025.md) |[25. Reverse Nodes in k-Group(K组反转链表)](https://leetcode.com/problems/reverse-nodes-in-k-group/)|
| [20211223](./202112/20211223.md) |[82. Remove Duplicates from Sorted List II(移除链表相同的元素2)](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/)|
| [20211224](./202112/20211224.md) |[61. Rotate List(旋转链表)](https://leetcode.com/problems/rotate-list/)|
| [20211221](./202112/20211221.md) |[86. Partition List(链表分区)](https://leetcode.com/problems/partition-list/)|
| [20241029](./202410/20241029.md) |[146. LRU Cache(LRU缓存)](https://leetcode.com/problems/lru-cache/description/)|
| [20240922](./202409/20240922.md) |[104. Maximum Depth of Binary Tree(二叉树:二叉树的最大深度)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description)|
| [20220913](./202209/20220913.md) |[100. Same Tree(相同的树)](https://leetcode.com/problems/same-tree/)|
| [20240926](./202409/20240926.md) |[226. Invert Binary Tree(旋转二叉树)](https://leetcode.com/problems/invert-binary-tree/description/)|
| [20240920](./202409/20240920.md) |[101. Symmetric Tree(对称树)](https://leetcode.com/problems/symmetric-tree/description)|
| [20240923](./202409/20240923.md) |[105. Construct Binary Tree from Preorder and Inorder Traversal(根据前序和中序构造二叉树)](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)|
| [20220204](./202202/20220204.md) |[106. Construct Binary Tree from Inorder and Postorder Traversal(中序和后序构造二叉树)](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)|
| [20220202](./202202/20220202.md) |[117. Populating Next Right Pointers in Each Node II(指向右侧节点)](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/)|
| [20240924](./202409/20240924.md) |[114. Flatten Binary Tree to Linked List(二叉树转换成单链表)](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)|
| [20210618](./202106/20210618.md) |[112. Path Sum(路径和)](https://leetcode.com/problems/path-sum/)|
| [20230310](./202303/20230310.md) |[129. Sum Root to Leaf Numbers(求根到叶子节点数字之和)](https://leetcode.com/problems/sum-root-to-leaf-numbers/)|
| [20240916](./202409/20240916.md) |[124. Binary Tree Maximum Path Sum(二叉树的最大路径和)](https://leetcode.com/problems/binary-tree-maximum-path-sum/description)|
| [20240925](./202409/20240925.md) |[199. Binary Tree Right Side View(二叉树:二叉树的右视图)](https://leetcode.com/problems/binary-tree-right-side-view/description)|
| [20211021](./202110/20211021.md) |[637. Average of Levels in Binary Tree(二叉树的层平均值)](https://leetcode.com/problems/average-of-levels-in-binary-tree/)|
| [20240921](./202409/20240921.md) |[102. Binary Tree Level Order Traversal(二叉树的层次遍历)](https://leetcode.com/problems/binary-tree-level-order-traversal/description)|
| [20210722](./202107/20210722.md) |[103. Binary Tree Zigzag Level Order Traversal(二叉树的锯齿形层次遍历)](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)|
| [20240919](./202409/20240919.md) |[98. Validate Binary Search Tree(有效的二叉搜索树)](https://leetcode.com/problems/validate-binary-search-tree)|
| [20240927](./202409/20240927.md) |[230. Kth Smallest Element in a BST(二叉搜索树的第K个最小元素)](https://leetcode.com/problems/kth-smallest-element-in-a-bst)|
| [20201217](./202012/20201217.md) |[530. Minimum Absolute Difference in BST(父子节点最小绝对值)](https://leetcode.com/problems/minimum-absolute-difference-in-bst/)|
| [20230118](./202301/20230118.md) |[98. Validate Binary Search Tree(验证是否是二叉树)](https://leetcode.com/problems/validate-binary-search-tree/)|
| [20241103](./202411/20241103.md) |[200. Number of Islands(图-岛屿的数量)](https://leetcode.com/problems/number-of-islands/)|
| [20221020](./202210/20221020.md) |[130. Surrounded Regions(被环绕的区域)](https://leetcode.com/problems/surrounded-regions/)|
| [20220411](./202204/20220411.md) |[133. Clone Graph(图复制)](https://leetcode.com/problems/clone-graph/)|
| [20241104](./202411/20241104.md) |[207. Course Schedule(课程计划)](https://leetcode.com/problems/course-schedule/)|
| [20220320](./202203/20220320.md) |[127. Word Ladder(词语阶梯-BFS)](https://leetcode.com/problems/word-ladder/)|
| [20241130](./202411/20241130.md) |[208. Implement Trie (Prefix Tree)(实现前缀树)](https://leetcode.com/problems/implement-trie-prefix-tree/)|
| [20240902](./202409/20240902.md) |[17. Letter Combinations of a Phone Number(回溯法-电话号码的字母组合)](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)|
| [20220318](./202203/20220318.md) |[77. Combinations(组合-暴力枚举)](https://leetcode.com/problems/combinations/)|
| [20240905](./202409/20240905.md) |[46. Permutations(排列)](https://leetcode.com/problems/permutations/description/)|
| [20240904](./202409/20240904.md) |[39. Combination Sum(组合总和)](https://leetcode.com/problems/combination-sum/description)|
| [20221025](./202210/20221025.md) |[52. N-Queens II(N皇后问题2)](https://leetcode.com/problems/n-queens-ii/)|
| [20240903](./202409/20240903.md) |[22. Generate Parentheses(生成括号)](https://leetcode.com/problems/generate-parentheses/)|
| [20240908](./202409/20240908.md) |[79. Word Search(单词查找)](https://leetcode.com/problems/word-search)|
| [20241211](./202412/20241211.md) |[108. Convert Sorted Array to Binary Search Tree(分治法:排序数组转换成二叉搜索树)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)|
| [20241030](./202410/20241030.md) |[148. Sort List(链表排序)](https://leetcode.com/problems/sort-list/)|
| [20241023](./202410/20241023.md) |[23. Merge k Sorted Lists(合并K个有序链表)](https://leetcode.com/problems/merge-k-sorted-lists/)|
| [20241203](./202412/20241203.md) |[53. Maximum Subarray(最大子段和)](https://leetcode.com/problems/maximum-subarray/description/)|
| [20240914](./202409/20240914.md) |[35. Search Insert Position(二分查找:寻找插入的位置)](https://leetcode.com/problems/search-insert-position/)|
| [20240915](./202409/20240915.md) |[74. Search a 2D Matrix(二维数组的查找)](https://leetcode.com/problems/search-a-2d-matrix/description/)|
| [20210908](./202109/20210908.md) |[162. Find Peak Element(发现山峰元素)](https://leetcode.com/problems/find-peak-element/)|
| [20240912](./202409/20240912.md) |[33. Search in Rotated Sorted Array(旋转数组二分查找)](https://leetcode.com/problems/search-in-rotated-sorted-array)|
| [20240913](./202409/20240913.md) |[34. Find First and Last Position of Element in Sorted Array(查找排序数组中元素的第一个和最后一个位置)](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)|
| [20240917](./202409/20240917.md) |[153. Find Minimum in Rotated Sorted Array(旋转排序数组中的最小值)](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)|
| [20240911](./202409/20240911.md) |[4. Median of Two Sorted Arrays(两个排序数组的中位数)](https://leetcode.com/problems/median-of-two-sorted-arrays/)|
| [20241110](./202411/20241110.md) |[215. Kth Largest Element in an Array(堆-数组中第K个最大元素)](https://leetcode.com/problems/kth-largest-element-in-an-array/)|
| [20241111](./202411/20241111.md) |[295. Find Median from Data Stream(发现数据流中的中位数)](https://leetcode.com/problems/find-median-from-data-stream/)|
| [20220819](./202208/20220819.md) |[67. Add Binary(位运算:二进制数字相加)](https://leetcode.com/problems/add-binary/)|
| [20201224](./202012/20201224.md) |[191. Number of 1 Bits(数字1的个数)](https://leetcode.com/problems/number-of-1-bits/)|
| [20241206](./202412/20241206.md) |[136. Single Number(单一数字)](https://leetcode.com/problems/single-number/)|
| [20220731](./202207/20220731.md) |[137. Single Number II(只出现一次的数字2)](https://leetcode.com/problems/single-number-ii/)|
| [20220413](./202204/20220413.md) |[9. Palindrome Number(数学:回文数)](https://leetcode.com/problems/palindrome-number/)|
| [20211212](./202112/20211212.md) |[66. Plus One(数组加一)](https://leetcode.com/problems/plus-one/)|
| [20210810](./202108/20210810.md) |[69. Sqrt(x)](https://leetcode.com/problems/sqrtx/)|
| [20221101](./202211/20221101.md) |[50. Pow(x, n)(求次幂)](https://leetcode.com/problems/powx-n/)|
| [20220425](./202204/20220425.md) |[149. Max Points on a Line(线上最多的点)](https://leetcode.com/problems/max-points-on-a-line/)|
| [20241005](./202410/20241005.md) |[70. Climbing Stairs(一维动态规划:爬梯子)](https://leetcode.com/problems/climbing-stairs/description/)|
| [20241010](./202410/20241010.md) |[198. House Robber(打家劫舍)](https://leetcode.com/problems/house-robber/description)|
| [20241008](./202410/20241008.md) |[139. Word Break(单词拆分)](https://leetcode.com/problems/word-break/)|
| [20241013](./202410/20241013.md) |[322. Coin Change(零钱兑换)](https://leetcode.com/problems/coin-change)|
| [20241012](./202410/20241012.md) |[300. Longest Increasing Subsequence(最长递增子序列)](https://leetcode.com/problems/longest-increasing-subsequence/)|
| [20241007](./202410/20241007.md) |[118. Pascal's Triangle(多维动态规划:杨辉三角)](https://leetcode.com/problems/pascals-triangle/description)|
| [20241004](./202410/20241004.md) |[64. Minimum Path Sum(最小路径和)](https://leetcode.com/problems/minimum-path-sum/description)|
| [20220326](./202203/20220326.md) |[63. Unique Paths II(不同的路径2)](https://leetcode.com/problems/unique-paths-ii/)|
| [20241001](./202410/20241001.md) |[5. Longest Palindromic Substring(最长回文子串)](https://leetcode.com/problems/longest-palindromic-substring/description)|
| [20211026](./202110/20211026.md) |[97. Interleaving String(DP交错字符串)](https://leetcode.com/problems/interleaving-string/)|
| [20241006](./202410/20241006.md) |[72. Edit Distance(编辑距离)](https://leetcode.com/problems/edit-distance/)|
| [20210505](./202105/20210505.md) |[123. Best Time to Buy and Sell Stock III(买卖股票的最佳时间3)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)|
| [20210831](./202108/20210831.md) |[221. Maximal Square(最大正方形)](https://leetcode.com/problems/maximal-square/)|

------

# 数组和字符串

## [20221004](./202210/20221004.md) |[88. Merge Sorted Array(合并排序的数组)](https://leetcode.com/problems/merge-sorted-array/)
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int tail1 = m - 1, tail2 = n - 1, icur = m + n - 1;
        while (tail1 >= 0 && tail2 >= 0) {
            nums1[icur--] = (nums1[tail1] > nums2[tail2]) ? nums1[tail1--] : nums2[tail2--];
        }

        while (tail2 >= 0) { //only need to combine with remaining nums2
            nums1[icur--] = nums2[tail2--];
        }
    }
}
```
## [20220718](./202207/20220718.md) |[27. Remove Element(移除元素)](https://leetcode.com/problems/remove-element/)
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int j = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i] != val){
                nums[j++] = nums[i];
            }
        }
        return j;
    }
}
```
## [20220708](./202207/20220708.md) |[26. Remove Duplicates from Sorted Array(移除数组中的重复元素)](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int j = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[j]!=nums[i]){
                nums[++j] = nums[i];
            }
        }
        return ++j;
    }
}
```
## [20220709](./202207/20220709.md) |[80. Remove Duplicates from Sorted Array II(移除数组中的重复元素2)](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)
```java
class Solution {
    public int removeDuplicates(int[] nums) {
       int j = 2;
       for (int i=2; i < nums.length;i++){
          if (nums[i] != nums[j-2])
             nums[j++] = nums[i];
       }
       return j;
    }
}
```
## [20241207](./202412/20241207.md) |[169. Majority Element(主要元素)](https://leetcode.com/problems/majority-element)
```java
class Solution {

    public int majorityElement(int[] nums) {
        quickSort(nums, 0, nums.length-1);
        return nums[nums.length/2];
    }

    public int majorityElement3(int[] nums) {
        int count = 0;
        Integer candidate = null;
        for(int num : nums){
            if(count == 0){
                candidate = num;
            }
            count += (num==candidate) ? 1 : -1;
        }
        return candidate;
    }

    public int majorityElement2(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        int result = -1;
        for(int i=0;i<nums.length;i++){
            map.put(nums[i], map.containsKey(nums[i])? map.get(nums[i])+ 1 : 0);
            if(map.get(nums[i]) >= nums.length/2){
                return nums[i];
            }
        }
        return result;
    }

    public void quickSort(int[] nums, int begin, int end){
        if(begin < end){
            int pivot = nums[begin];
            int i = begin;
            int j = end;
            while(i < j){
                while(i<j && pivot < nums[j]){
                    j--;
                }
                if(i<j){
                    nums[i] = nums[j];
                    nums[j] = pivot;
                    i++;
                }
                while(i<j && nums[i] < pivot){
                    i++;
                }
                if(i<j){
                    nums[j] = nums[i];
                    nums[i] = pivot;
                    j--;
                }
            }
            quickSort(nums, begin, i-1);
            quickSort(nums, i+1, end);
        }
    }
}
```
## [20241208](./202412/20241208.md) |[189. Rotate Array(旋转数组)](https://leetcode.com/problems/rotate-array/description/)

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums, 0, nums.length-1);
        reverse(nums, 0, k-1);
        reverse(nums, k, nums.length-1);
    }

    private void reverse(int[] nums, int begin, int end){
        while(begin < end){
            int temp = nums[begin];
            nums[begin] = nums[end];
            nums[end] = temp;
            begin ++;
            end --;
        }
    }

}
```
## [20241108](./202411/20241108.md) |[121. Best Time to Buy and Sell Stock(买卖股票的最佳时机)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0){
            return 0;
        }
        int global = 0;
        int min = prices[0];
        for(int i = 1; i < prices.length; i++){
            min = Math.min(min, prices[i]);
            if(prices[i] > min){
                global = Math.max(global, prices[i] - min);
            }
        }
        return global;
    }
}
```
## [20220408](./202204/20220408.md) |[122. Best Time to Buy and Sell Stock II(买卖股票最佳时间2)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)
```java
class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for(int i=0;i<prices.length-1;i++){
            if(prices[i+1]>prices[i]){
                profit += prices[i+1] - prices[i];
            }
        }
        return profit;
    }
}
```
## [20220405](./202204/20220405.md) |[55. Jump Game(跳跃游戏)](https://leetcode.com/problems/jump-game/)
```java
class Solution {
    public boolean canJump(int[] nums) {
        int last = nums.length-1;
        for(int i=last;i>=0;i--){
            if(nums[i]>=last-i){
                last = i;
            }
        }
        return last==0;
    }
}
```
## [20241106](./202411/20241106.md) |[45. Jump Game II(贪心算法-跳跃游戏2)](https://leetcode.com/problems/jump-game-ii/)

```java
class Solution {
    public int jump(int[] nums) {
        int result = 0, curMax = 0, max = 0;
        for (int i = 0; i < nums.length - 1; i++) {
            max = Math.max(max, i + nums[i]);
            if(i == curMax){
                result ++;
                curMax = max;
            }
        }
        return result;
    }
}
```
## [20241209](./202412/20241209.md) |[238. Product of Array Except Self(除自身以外数组的乘积)](https://leetcode.com/problems/product-of-array-except-self)
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] leftProducts = new int[n];
        int[] rightProducts = new int[n];
        int[] result = new int[n];

        // Calculate left products
        leftProducts[0] = 1;
        for (int i = 1; i < n; i++) {
            leftProducts[i] = leftProducts[i - 1] * nums[i - 1];
        }

        // Calculate right products
        rightProducts[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            rightProducts[i] = rightProducts[i + 1] * nums[i + 1];
        }

        // Calculate the final result
        for (int i = 0; i < n; i++) {
            result[i] = leftProducts[i] * rightProducts[i];
        }

        return result;
    }
}
```
## [20211216](./202112/20211216.md) |[134. Gas Station(加油站)](https://leetcode.com/problems/gas-station/)
```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int tank = 0;
        for(int i = 0; i < gas.length; i++){
            tank += gas[i] - cost[i];
        }
        if(tank < 0){
            return -1;
        }
        int start = 0;
        int accumulate = 0;
        for(int i=0;i<gas.length; i++){
            int curGain = gas[i] - cost[i];
            if(accumulate + curGain < 0){
                start = i + 1;
                accumulate = 0;
            }else{
                accumulate += curGain;
            }
        }
        return start;
    }
}
```
## [20211217](./202112/20211217.md) |[135. Candy(糖果-贪心算法)](https://leetcode.com/problems/candy/)
```java
class Solution {
    public int candy(int[] ratings) {
        int len=ratings.length;
        int [] candy=new int[len];
        // 1. 初始化糖果的数量为1
        for(int i=0;i<len;i++){
            candy[i]=1;
        }
        // 2. 从前往后:如果第i个小孩的等级>前面i-1个小孩的等级，那么糖果数+1
        for(int i=1;i<len;i++){
            if(ratings[i]>ratings[i-1]){
                candy[i]=candy[i-1]+1;
            }
        }
        // 3. 从后往前: 如果第i个小孩的等级>后面i+1个小孩的等级且糖果数少，那么糖果数+1
        for(int i=len-2;i>=0;i--){
            if((ratings[i]>ratings[i+1])&&(candy[i]<=candy[i+1])){
                candy[i]=candy[i+1]+1;   
            }
        }
        int num=0;
        for(int i=0;i<len;i++){
            num+=candy[i];
        }
        return num;
    }
}
```
## [20241128](./202411/20241128.md) |[42. Trapping Rain Water(接雨水)](https://leetcode.com/problems/trapping-rain-water/)
```java
class Solution {
    public int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int res = 0, maxleft = 0, maxright = 0;
        while (left <= right) {
            if(height[left] <= height[right]){
                if(height[left] > maxleft){
                    maxleft = height[left];
                }else{
                    res += maxleft - height[left];
                }
                left++;
            }else{
                if(height[right] > maxright){
                    maxright = height[right];
                }else{
                    res += maxright - height[right];
                }
                right--;
            }
        }
        return res;
    }
}
```
## [20220826](./202208/20220826.md) |[13. Roman to Integer(罗马转整数)](https://leetcode.com/problems/roman-to-integer/)
```java
class Solution {
    public int romanToInt(String s) {
        if (s == null || s.length() == 0)
		    return -1;
        HashMap<Character, Integer> map = new HashMap<Character, Integer>();
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        int len = s.length(), result = map.get(s.charAt(len - 1));
        for (int i = len - 2; i >= 0; i--) {
            if (map.get(s.charAt(i)) >= map.get(s.charAt(i + 1)))
                result += map.get(s.charAt(i));
            else
                result -= map.get(s.charAt(i));
        }
        return result;
    }
}
```
## [20220825](./202208/20220825.md) |[12. Integer to Roman(整数转罗马)](https://leetcode.com/problems/integer-to-roman/)

```java
class Solution {
    public String intToRoman(int num) {
        int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};
        String[] strs = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};

        StringBuilder sb = new StringBuilder();

        for(int i=0;i<values.length;i++) {
            while(num >= values[i]) {
                num -= values[i];
                sb.append(strs[i]);
            }
        }
        return sb.toString();
    }
}
```
## [20220116](./202201/20220116.md) |[58. Length of Last Word(最后一个单词长度)](https://leetcode.com/problems/length-of-last-word/)
```java
class Solution {
    public int lengthOfLastWord(String s) {
        return s.trim().length()-s.trim().lastIndexOf(" ")-1;
    }
}
```
## [20220109](./202201/20220109.md) |[14. Longest Common Prefix(最长公共前缀)](https://leetcode.com/problems/longest-common-prefix/)
```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs==null||strs.length==0){
            return "";
        }
        String pre = strs[0];
        for(String str:strs){
            while(str.indexOf(pre)!=0){
                pre = pre.substring(0,pre.length()-1);
            }
        }
        return pre;
    }
}
```
## [20210701](./202107/20210701.md) |[151. Reverse Words in a String(翻转字符串里的单词)](https://leetcode.com/problems/reverse-words-in-a-string/)

```java
class Solution {
    public String reverseWords(String s) {
        Stack<String> stack = new Stack<>();
        String temp = "";
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)==' '&&temp.length()!=0){
                stack.push(temp);
                temp = "";
            }else if(s.charAt(i)!=' '){
                temp += s.charAt(i);
            }
            if(i==s.length()-1){
                stack.push(temp.trim());
            }
        }
        String result = "";
        while(!stack.isEmpty()){
            result += stack.pop();
            result += " ";
        }
        return result.strip();
    }
}
```
## [20221204](./202212/20221204.md) |[6. Zigzag Conversion(之字形转换)](https://leetcode.com/problems/zigzag-conversion/)
```java
class Solution {
    public String convert(String s, int numRows) {
        if(s==null||s.length()==0) return "";
        char[] c = s.toCharArray();
        StringBuffer[] sb = new StringBuffer[numRows];
        for(int k =0;k<numRows;k++){
            sb[k] = new StringBuffer();
        }
        int i = 0;
        while(i<s.length()){
            for(int idx = 0;idx<numRows&&i<s.length();idx++){
                sb[idx].append(c[i++]);
            }
            for(int idx = numRows-2;idx>0&&i<s.length();idx--){
                sb[idx].append(c[i++]);
            }
        }
        for(int j=1;j<numRows;j++){
            sb[0].append(sb[j]);
        }
        return sb[0].toString();
    }
}
```
## [20220424](./202204/20220424.md) |[68. Text Justification(公平文本)](https://leetcode.com/problems/text-justification/)

```java
class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {
        int left = 0; List<String> result = new ArrayList<>();

        while (left < words.length) {
            int right = findRight(left, words, maxWidth);
            result.add(justify(left, right, words, maxWidth));
            left = right + 1;
        }

        return result;
    }

    private int findRight(int left, String[] words, int maxWidth) {
        int right = left;
        int sum = words[right++].length();

        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)
            sum += 1 + words[right++].length();

        return right - 1;
    }

    private String justify(int left, int right, String[] words, int maxWidth) {
        if (right - left == 0) return padResult(words[left], maxWidth);

        boolean isLastLine = right == words.length - 1;
        int numSpaces = right - left;
        int totalSpace = maxWidth - wordsLength(left, right, words);

        String space = isLastLine ? " " : blank(totalSpace / numSpaces);
        int remainder = isLastLine ? 0 : totalSpace % numSpaces;

        StringBuilder result = new StringBuilder();
        for (int i = left; i <= right; i++)
            result.append(words[i])
                .append(space)
                .append(remainder-- > 0 ? " " : "");

        return padResult(result.toString().trim(), maxWidth);
    }

    private int wordsLength(int left, int right, String[] words) {
        int wordsLength = 0;
        for (int i = left; i <= right; i++) wordsLength += words[i].length();
        return wordsLength;
    }

    private String padResult(String result, int maxWidth) {
        return result + blank(maxWidth - result.length());
    }

    private String blank(int length) {
        return new String(new char[length]).replace('\0', ' ');
    }
}
```
# 双指针

## [20220102](./202201/20220102.md) |[125. Valid Palindrome(有效回文串)](https://leetcode.com/problems/valid-palindrome/)
```java
class Solution {
    public boolean isPalindrome(String s) {
        if(s==null||s.isEmpty()){
            return true;
        }
        int i = 0;
        int j = s.length()-1;
        while(i<=j){
            while(i<j&&!isNumAlphanumeric(s.charAt(i))){
                i++;
            }
            while((i<j)&&(!isNumAlphanumeric(s.charAt(j)))) {
                j--;
            }
            if (toLower(s.charAt(i++)) != toLower(s.charAt(j--))) {
                return false;
            }
        }
        return true;
    }

    public char toLower(char c){
        if('A'<=c&&c<='Z'){
            return (char)('a'+c-'A');
        }
        return c;
    }
    public boolean isNumAlphanumeric(char c){
        if(('0'<=c&&c<='9')||('a'<=c&&c<='z')||('A'<=c&&c<='Z')) {
            return true;
        }
        return false;
    }
}
```
## [20220611](./202206/20220611.md) |[392. Is Subsequence(是否是子串)](https://leetcode.com/problems/is-subsequence/)
```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int i = 0;
        int j = 0;
        while(i<s.length() && j<t.length()){
            if(s.charAt(i) == t.charAt(j)){
                i++;
            }
            j++;
        }
        return i==s.length();
    }
}
```
## [20241126](./202411/20241126.md) |[11. Container With Most Water(盛满水的最大容器)](https://leetcode.com/problems/container-with-most-water/)

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int max = 0;
        while(left < right){
            int w = right - left;
            int h = Math.min(height[left], height[right]);
            int area = w * h;
            max = Math.max(area, max);
            if(height[left] < height[right]){
                left ++;
            }else if(height[left] > height[right]){
                right--;
            }else{
                left ++;
                right--;
            }
        }
        return max;
    }
}
```
## [20241127](./202411/20241127.md) |[15. 3Sum(三数之和)](https://leetcode.com/problems/3sum/)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> list = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            // 重复元素不在计算
            if(i>0 && nums[i]==nums[i-1]){
                continue;
            }
            for(int j=i+1, k=nums.length-1;j<k;){
                if(nums[i]+nums[j]+nums[k]==0){
                    list.add(Arrays.asList(nums[i],nums[j],nums[k]));
                    j++;
                    k--;
                    while(j<k&&nums[j-1]==nums[j]){
                        j++;
                    }
                    while(j<k&&nums[k+1]==nums[k]){
                        k--;
                    }
                }else if(nums[i]+nums[j]+nums[k]<0){
                        j++;
                }else{
                        k--;
                }
            }
        }
        return list;
    }
}
```
# 滑动窗口
## [20210703](./202107/20210703.md) |[209. Minimum Size Subarray Sum(长度最小的子数组)](https://leetcode.com/problems/minimum-size-subarray-sum/)
```java
class Solution {
   public int minSubArrayLen(int s, int[] nums) {
       int start = 0, end = 0;
       int min = Integer.MAX_VALUE, sum = 0;
       while(end<=nums.length){
           if(sum >= s){
              min = Math.min(min, end - start);
              sum -= nums[start++];
           }else{
              if(end==nums.length){
                  end++;
              }else{
                  sum += nums[end++];
              }
           }
       }
       return (min == Integer.MAX_VALUE) ? 0:min;
   }
}
```
## [20241117](./202411/20241117.md) |[3. Longest Substring Without Repeating Characters(无重复字符的最长子串)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s==null||s.length()==0){
            return 0;
        }
        int max = 0;
        Map<Character, Integer> map = new HashMap<>();
        int j = 0;
        for(int i=0;i<s.length();i++){
            if(map.containsKey(s.charAt(i))){
                j = Math.max(j, map.get(s.charAt(i)) + 1);
            }
            map.put(s.charAt(i), i);
            max = Math.max(max, i-j+1);
        }
        return max;
    }
}
```
## [20221129](./202211/20221129.md) |[30. Substring with Concatenation of All Words(串联所有单词的子串)](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        final Map<String, Integer> counts = new HashMap<>();
        for (final String word : words) {
            counts.put(word, counts.getOrDefault(word, 0) + 1);
        }
        final List<Integer> indexes = new ArrayList<>();
        final int n = s.length(), num = words.length, len = words[0].length();
        for (int i = 0; i < n - num * len + 1; i++) {
            final Map<String, Integer> seen = new HashMap<>();
            int j = 0;
            while (j < num) {
                final String word = s.substring(i + j * len, i + (j + 1) * len);
                if (counts.containsKey(word)) {
                    seen.put(word, seen.getOrDefault(word, 0) + 1);
                    if (seen.get(word) > counts.getOrDefault(word, 0)) {
                        break;
                    }
                } else {
                    break;
                }
                j++;
            }
            if (j == num) {
                indexes.add(i);
            }
        }
        return indexes;
    }
}
```
# 矩阵
## [20220721](./202207/20220721.md) |[36. Valid Sudoku(有效数独)](https://leetcode.com/problems/valid-sudoku/)
```java
public boolean isValidSudoku(char[][] board) {
    Set seen = new HashSet();
    for (int i=0; i<9; ++i) {
        for (int j=0; j<9; ++j) {
            char number = board[i][j];
            if (number != '.')
                if (!seen.add(number + " in row " + i) ||
                    !seen.add(number + " in column " + j) ||
                    !seen.add(number + " in block " + i/3 + "-" + j/3))
                    return false;
        }
    }
    return true;
}
```
## [20241114](./202411/20241114.md) |[54. Spiral Matrix(螺旋矩阵)](https://leetcode.com/problems/spiral-matrix/description)

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<Integer>();
        if(matrix.length==0){
            return res;
        }
        int rowBegin = 0;
        int rowEnd = matrix.length-1;
        int colBegin = 0;
        int colEnd = matrix[0].length - 1;
        while (rowBegin <= rowEnd && colBegin <= colEnd){
            // Traverse Right
            for (int j = colBegin; j <= colEnd; j ++) {
                res.add(matrix[rowBegin][j]);
            }
            rowBegin++;

            // Traverse Down
            for (int j = rowBegin; j <= rowEnd; j ++) {
                res.add(matrix[j][colEnd]);
            }
            colEnd--;

            if (rowBegin <= rowEnd) {
                // Traverse Left
                for (int j = colEnd; j >= colBegin; j --) {
                    res.add(matrix[rowEnd][j]);
                }
            }
            rowEnd--;

            if (colBegin <= colEnd) {
                // Traver Up
                for (int j = rowEnd; j >= rowBegin; j --) {
                    res.add(matrix[j][colBegin]);
                }
            }
            colBegin++;
        }
        return res;
    }
}
```
## [20211213](./202112/20211213.md) |[48. Rotate Image(旋转图像)](https://leetcode.com/problems/rotate-image/)
```java
public class Solution {
    public void rotate(int[][] matrix) {
        for(int i = 0; i<matrix.length; i++){
            for(int j = i; j<matrix[0].length; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        for(int i =0 ; i<matrix.length; i++){
            for(int j = 0; j<matrix.length/2; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.length-1-j];
                matrix[i][matrix.length-1-j] = temp;
            }
        }
    }
}
```
## [20241115](./202411/20241115.md) |[73. Set Matrix Zeroes(设置矩阵零)](https://leetcode.com/problems/set-matrix-zeroes/)

```java
class Solution {
    public void setZeroes(int[][] matrix) {
         if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;
         int m = matrix.length, n = matrix[0].length;
        // 第一行和第一列是否存在0
         boolean row = false, col = false;
        // 设置开始的行和列是0，并且标记行列为true
         for (int i = 0; i < m; i++){
             for (int j = 0; j < n; j++){
                 if (matrix[i][j] == 0) {
                     matrix[0][j] = 0;
                     matrix[i][0] = 0;
                     if (i == 0) row = true;
                     if (j == 0) col = true;
                 }
             }
         }
         // 设置行为0
         for (int i = 1; i < m; i++){
             if (matrix[i][0] == 0){
                 for (int j = 1; j < n;j++)
                     matrix[i][j] = 0;
             }
         }
         // 设置列为0
         for (int j = 1; j < n; j++){
             if (matrix[0][j] == 0){
                 for (int i = 1; i < m; i++)
                     matrix[i][j] = 0;
             }
         }
         if (row){
             for (int j = 0; j < n; j++)
                 matrix[0][j] = 0;
         }
         if (col){
             for(int i = 0; i < m; i++)
                 matrix[i][0] = 0;
         }
    }
}
```
# 哈希
## [20241017](./202410/20241017.md) |[49. Group Anagrams(字母异位词分组)](https://leetcode.com/problems/group-anagrams/description)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        if (strs == null || strs.length == 0) {
            return new ArrayList<>();
        }
        Map<String, List<String>> map = new HashMap<>();
        for (S s : strs) {
            char[] ca = new char[26];
            for (char c : s.toCharArray()){
                ca[c - 'a']++;
            }
            String keyStr = String.valueOf(ca);
            if (!map.containsKey(keyStr)) {
                map.put(keyStr, new ArrayList<>());
            }
            map.get(keyStr).add(s);
        }
        return new ArrayList<>(map.values());
    }
}
```
## [20241016](./202410/20241016.md) |[1. Two Sum(两数之和)](https://leetcode.com/problems/two-sum/description/)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0; i<nums.length; i++){
            if(map.containsKey(target-nums[i])){
                return new int[]{map.get(target-nums[i]), i};
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("no solution!");
    }
}
```
## [20211028](./202110/2021028.md) |[202. Happy Number(快乐数)](https://leetcode.com/problems/happy-number/)
```java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> inLoop = new HashSet<Integer>();
        int squareSum,remain;
        while (inLoop.add(n)) {
            squareSum = 0;
            while(n > 0){
                remain = n % 10;
                squareSum = squareSum + remain * remain;
                n /= 10;
            }
            if(squareSum == 1){
                return true;
            }
            n = squareSum;
        }
        return false;
    }
}
```
## [20241018](./202410/20241018.md) |[128. Longest Consecutive Sequence(最长连续子序列)](https://leetcode.com/problems/longest-consecutive-sequence/)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        int res = 0;
        // 使用map存储当前元素n的最大序列长度sum
        Map<Integer, Integer> map = new HashMap<>();
        for (int n : nums) {
            // 重复元素直接跳过
            if(map.containsKey(n)){
                continue;
            }
            // 相邻左侧节点计算左侧的最大长度(没有相邻左侧节点直接设置为0)
            int left = map.getOrDefault(n-1, 0);
            // 相邻右侧节点计算右侧最大长度
            int right = map.getOrDefault(n+1, 0);
            // 计算当前左右节点累加之后的长度sum，并保存到n中
            int sum = left + right + 1;
            map.put(n, sum);

            // 求res当前最大值
            res = Math.max(res, sum);

            // 扩大n两侧的数字范围
            // n左侧left个节点，更新为sum
            map.put(n-left, sum);
            // n右侧right个节点，更新为sum
            map.put(n+right, sum);
        }
        return res;
    }
}
```
# 间隔/区间
## [20241204](./202412/20241204.md) |[56. Merge Intervals(区间交集)](https://leetcode.com/problems/merge-intervals/description/)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length <= 1)
			return intervals;

		// Sort by ascending starting point
		Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));

		List<int[]> result = new ArrayList<>();
		int[] newInterval = intervals[0];
		result.add(newInterval);
		for (int[] interval : intervals) {
			if (interval[0] <= newInterval[1]) // Overlapping intervals, move the end if needed
				newInterval[1] = Math.max(newInterval[1], interval[1]);
			else {                             // Disjoint intervals, add the new interval to the list
				newInterval = interval;
				result.add(newInterval);
			}
		}

		return result.toArray(new int[result.size()][]);
    }
}
```
## [20221125](./202211/20221125.md) |[57. Insert Interval(插入区间)](https://leetcode.com/problems/insert-interval/)
```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> result = new ArrayList<>();

         for(int[] i : intervals){
             if(newInterval == null || i[1] < newInterval[0]){
                 result.add(i);
             }else if(i[0] > newInterval[1]){
                // be carefult the sequence here
                 result.add(newInterval);
                 result.add(i);
                 newInterval = null;
             }else{
                 newInterval[0] = Math.min(newInterval[0], i[0]);//get min
                 newInterval[1] = Math.max(newInterval[1], i[1]);//get max
             }
         }

        if(newInterval != null)
            result.add(newInterval);

        return result.toArray(new int[result.size()][]);
    }
}
```
# 栈
## [20220901](./202209/20220901.md) |[32. Longest Valid Parentheses(最长有效括号)](https://leetcode.com/problems/longest-valid-parentheses/)
```java
class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        int maxLen = 0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='('){
                stack.push(i);
            }else{
                stack.pop();
                if(stack.isEmpty()){
                    stack.push(i);
                }
                maxLen = Math.max(maxLen, i - stack.peek());
            }
        }
        return maxLen;
    }
}
```
## [20220829](./202208/20220829.md) |[71. Simplify Path(简化路径)](https://leetcode.com/problems/simplify-path/)
```java
class Solution {
    public String simplifyPath(String path) {
        Deque<String> stack = new LinkedList<>();
        for(String s: path.split("/")){
            if(s.equals("..") ){
                stack.poll();
            }else if(!s.equals("") && !s.equals(".")){
                stack.push(s);
            }
        }
        StringBuilder sb = new StringBuilder();
        if(stack.size() == 0){
            return "/";
        }
        while(stack.size() != 0){
           sb.append("/").append(stack.pollLast());   
        }
        return sb.toString();
    }
}
```
## [20220121](./202201/20220121.md) |[150. Evaluate Reverse Polish Notation(计算逆波兰表达式)](https://leetcode.com/problems/evaluate-reverse-polish-notation/)
```java
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> stack = new Stack<>();
        for(int i=0;i<tokens.length;i++){
            if(tokens[i].equals("+")){
                stack.push(stack.pop() + stack.pop());
            }else if(tokens[i].equals("-")){
                stack.push(-stack.pop() + stack.pop());
            }else if(tokens[i].equals("*")){
                stack.push(stack.pop()*stack.pop());
            }else if(tokens[i].equals("/")){
                int temp= stack.pop();
                stack.push(stack.pop()/temp);
            }else{
                stack.push(Integer.parseInt(tokens[i]));
            }
        }
        return stack.pop();
    }
}
```
## [20241123](./202411/20241123.md) |[155. Min Stack(最小栈)](https://leetcode.com/problems/min-stack/description/)

```java
class MinStack {

    private Stack<Integer> stack = new Stack<>();
    private Stack<Integer> minStack = new Stack<>();

    /** initialize your data structure here. */
    public MinStack() {

    }

    public void push(int val) {
        if(minStack.isEmpty() || val<= minStack.peek()){
            minStack.push(val);
        }
        stack.push(val);
    }

    public void pop() {
       if(stack.peek().equals(minStack.peek())){
           minStack.pop();
       }
        stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```
## [20210926](./202109/20210926.md) |[224. Basic Calculator(基本计算器)](https://leetcode.com/problems/basic-calculator/)

```java
class Solution {
    public int calculate(String s) {
        if(s==null){
            return 0;
        }
        int result = 0;
        int sign = 1;
        int num = 0;

        Stack<Integer> stack = new Stack<Integer>();
        stack.push(sign);

        for(int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if(c >= '0' && c <= '9') {
                num = num * 10 + (c - '0');
            }else if(c == '+' || c == '-') {
                result += sign * num;
                sign = stack.peek() * (c == '+' ? 1: -1);
                num = 0;
            }else if(c == '(') {
                stack.push(sign);
            }else if(c == ')') {
                stack.pop();
            }
        }

        result += sign * num;
        return result;
    }
}
```
# 链表
## [20241027](./202410/20241027.md) |[141. Linked List Cycle(环形链表)](https://leetcode.com/problems/linked-list-cycle/description/)

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head ==null || head.next==null){
            return false;
        }
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow){
                return true;
            }
        }
        return false;
    }
}
```
## [20241020](./202410/20241020.md) |[2. Add Two Numbers(链表-两数相加)](https://leetcode.com/problems/add-two-numbers)

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1==null||l2==null) return null;
        int value1,value2=0;
        ListNode pre = new ListNode(0);
        ListNode result = pre;
        while(l1!=null&&l2!=null){
            value1 = (l1.val+l2.val+value2)%10;
            value2 = (l1.val+l2.val+value2)/10;
            pre.next = new ListNode(value1);
            pre = pre.next;
            l1 = l1.next;
            l2 = l2.next;
            if(l1 == null && l2 == null){
                break;
            }
            if(l1 == null && l2 != null){
                l1 = new ListNode(0);
            }
            if(l1 != null && l2 == null){
                l2 = new ListNode(0);
            }
        }
        if(value2>0){
            pre.next = new ListNode(value2);
        }
        return result.next;
    }
}
```
## [20241022](./202410/20241022.md) |[21. Merge Two Sorted Lists(合并两个排序链表)](https://leetcode.com/problems/merge-two-sorted-lists/)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null){
            return l2;
        }else if(l2 == null){
            return l1;
        }else if(l1.val < l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```

## [20241026](./202410/20241026.md) |[138. Copy List with Random Pointer(带随机指针Copy链表)](https://leetcode.com/problems/copy-list-with-random-pointer)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null){
            return null;
        }
        Map<Node, Node> clone = new HashMap<>();
        Node current = head;
        while(current != null){
            Node temp = new Node(current.val);
            clone.put(current, temp);
            current = current.next;
        }
        current = head;
        while(current != null){
            Node temp = clone.get(current);
            temp.next = clone.get(current.next);
            temp.random = clone.get(current.random);
            current = current.next;
        }
        return clone.get(head);
    }
}
```
## [20220803](./202208/20220803.md) |[92. Reverse Linked List II(反转链表2)](https://leetcode.com/problems/reverse-linked-list-ii/)
```JAVA
class Solution {
    private ListNode successor = null;
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if(left == 1){
            return reverseN(head, right);
        }
        head.next = reverseBetween(head.next, left - 1, right - 1);
        return head;
    }

    public ListNode reverseN(ListNode head, int n){
        if(n==1){
            successor = head.next;
            return head;
        }
        ListNode last = reverseN(head.next, n-1);
        head.next.next = head;
        head.next = successor;
        return last;
    }
}
```
## [20241021](./202410/20241021.md) |[19. Remove Nth Node From End of List(移除链表中倒数第N个元素)](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head;
        ListNode res = new ListNode(0);
        res.next = head;
        ListNode slow = res;
        while (fast != null) {
            fast = fast.next;
            if (n-- <= 0) {
                slow = slow.next;
            }
        }
        slow.next = slow.next.next;
        return res.next;
    }
}
```
## [20241025](./202410/20241025.md) |[25. Reverse Nodes in k-Group(K组反转链表)](https://leetcode.com/problems/reverse-nodes-in-k-group/)

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode pre = dummy;
        ListNode now = head;
        int count = 0;
        while(now != null){
            ListNode next = now.next;
            count++;
            if(count == k){
                pre = reverse(pre, next);
                count = 0;
            }
            now = next;
        }
        return dummy.next;
    }

    private ListNode reverse(ListNode pre, ListNode end){
        if(pre == null || pre.next == null){
            return pre;
        }
        ListNode head = pre.next;
        ListNode now = pre.next.next;
        while(now != end){
            ListNode next = now.next;
            now.next = pre.next;
            pre.next = now;
            now = next;
        }
        head.next = end;
        return head;
    }
}
```
## [20211223](./202112/20211223.md) |[82. Remove Duplicates from Sorted List II(移除链表相同的元素2)](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/)
```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(0), fast = head, slow = dummy;
        slow.next = fast;
        while(fast != null) {
            while (fast.next != null && fast.val == fast.next.val) {
                //while loop to find the last node of the dups.
     		    fast = fast.next;    
    	    }
            if (slow.next != fast) { //duplicates detected.
    		    slow.next = fast.next; //remove the dups.
    		    fast = slow.next;     //reposition the fast pointer.
    	    }else {
                //no dup, move down both pointer.
    		    slow = slow.next;
    		    fast = fast.next;
    	    }
        }
        return dummy.next;
    }
}
```
## [20211224](./202112/20211224.md) |[61. Rotate List(旋转链表)](https://leetcode.com/problems/rotate-list/)
```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head == null || head.next == null || k == 0){
            return head;
        }
        ListNode end = head;
        ListNode newhead = head;
        ListNode newend = head;
        int listLength = 1;
        while(end.next != null){
            end = end.next;
            listLength++;
        }
        end.next = head; // make it a circle here
        for(int i = 0; i < listLength - (k % listLength); i++){
            newend = newhead;
            newhead = newhead.next;   
        }
        //end.next = head; when i put it here rather than the place above, it cannot pass, i don't know why. can you help me? why should we make a circle?
        newend.next = null;
        return newhead;
    }
}
```

## [20211221](./202112/20211221.md) |[86. Partition List(链表分区)](https://leetcode.com/problems/partition-list/)
```java
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode less = new ListNode(0);
        ListNode greater = new ListNode(0);
        ListNode curr1 = less, curr2 = greater;

        while (head!=null) {
            if (head.val<x) {
                curr1.next = new ListNode(head.val);
                curr1 = curr1.next;
            }else {
                curr2.next = new ListNode(head.val);
                curr2 = curr2.next;
            }
            head = head.next;
        }
        curr1.next = greater.next;
        return less.next;
    }
}
```
## [20241029](./202410/20241029.md) |[146. LRU Cache(LRU缓存)](https://leetcode.com/problems/lru-cache/description/)

```java
import java.util.Hashtable;
class LRUCache {

    // 定义一个内部类，存储LRU节点
    class DLinkedNode {
      // key
      int key;
      // value
      int value;
      // 前一个节点
      DLinkedNode pre;
      // 后一个节点
      DLinkedNode post;
    }

    /**
     * Always add the new node right after head;
     */
    private void addNode(DLinkedNode node) {
       node.pre = head;
       node.post = head.post;
       head.post.pre = node;
       head.post = node;
    }

    /**
     * Remove an existing node from the linked list.
     */
    private void removeNode(DLinkedNode node){
       DLinkedNode pre = node.pre;
       DLinkedNode post = node.post;
       pre.post = post;
       post.pre = pre;
    }

    /**
     * Move certain node in between to the head.
     */
    private void moveToHead(DLinkedNode node){
      this.removeNode(node);
      this.addNode(node);
    }

    // pop the current tail.
    private DLinkedNode popTail(){
       DLinkedNode res = tail.pre;
       this.removeNode(res);
       return res;
    }

    private Hashtable<Integer, DLinkedNode> cache = new Hashtable<Integer, DLinkedNode>();
    private int count;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.count = 0;
        this.capacity = capacity;

        head = new DLinkedNode();
        head.pre = null;

        tail = new DLinkedNode();
        tail.post = null;

        head.post = tail;
        tail.pre = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if(node == null){
            // should raise exception here.
            return -1;
        }
        // move the accessed node to the head;
        this.moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if(node == null){
          DLinkedNode newNode = new DLinkedNode();
          newNode.key = key;
          newNode.value = value;
          this.cache.put(key, newNode);
          this.addNode(newNode);
          ++count;

          if(count > capacity){
            // pop the tail
            DLinkedNode tail = this.popTail();
            this.cache.remove(tail.key);
            --count;
          }
       }else{
          // update the value.
          node.value = value;
          this.moveToHead(node);
       }
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```
# 二叉树
## [20240922](./202409/20240922.md) |[104. Maximum Depth of Binary Tree(二叉树的最大深度)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description)
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) +1;
    }
}
```
## [20220913](./202209/20220913.md) |[100. Same Tree(相同的树)](https://leetcode.com/problems/same-tree/)
```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q!=null||p!=null&&q==null) return false;
        if(p==null&&q==null) return true;
        if(p.val!=q.val) return false;
        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
    }
}
```
## [20240926](./202409/20240926.md) |[226. Invert Binary Tree(旋转二叉树)](https://leetcode.com/problems/invert-binary-tree/description/)

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null){
            return root;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```
## [20240920](./202409/20240920.md) |[101. Symmetric Tree(对称树)](https://leetcode.com/problems/symmetric-tree/description)
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null){
            return true;
        }
        if(root.left==null && root.right==null){
            return true;
        }
        return isSamed(root.left, root.right);
    }
    public boolean isSamed(TreeNode left, TreeNode right){
        if(left == null && right == null){
            return true;
        }
        if(left == null && right != null){
            return false;
        }
        if(left != null && right == null){
            return false;
        }
        if(left.val != right.val){
            return false;
        }
        return isSamed(left.left, right.right) && isSamed(left.right, right.left);
    }
}
```
## [20240923](./202409/20240923.md) |[105. Construct Binary Tree from Preorder and Inorder Traversal(根据前序和中序构造二叉树)](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)
```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || inorder == null || preorder.length == 0 || inorder.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[0]);
        for (int i = 0; i < inorder.length; i++) {
            if (preorder[0] == inorder[i]) {
                root.left = buildTree(Arrays.copyOfRange(preorder, 1, i + 1),
                        Arrays.copyOfRange(inorder, 0, i));
                root.right = buildTree(Arrays.copyOfRange(preorder, i + 1, preorder.length),
                        Arrays.copyOfRange(inorder, i + 1, inorder.length));
            }
        }
        return root;
    }
}
```
## [20220204](./202202/20220204.md) |[106. Construct Binary Tree from Inorder and Postorder Traversal(中序和后序构造二叉树)](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```Java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if(inorder==null||postorder==null||inorder.length==0||postorder.length==0){
            return null;
        }
        TreeNode treeNode = new TreeNode(postorder[postorder.length-1]);
        for(int i = 0; i<inorder.length; i++){
            if(inorder[i] == postorder[postorder.length-1]){
                treeNode.left = buildTree(Arrays.copyOfRange(inorder, 0, i), Arrays.copyOfRange(postorder, 0, i));
                treeNode.right = buildTree(Arrays.copyOfRange(inorder, i+1, inorder.length), Arrays.copyOfRange(postorder, i, postorder.length-1));
            }
        }
        return treeNode;
    }
}
```
## [20220202](./202202/20220202.md) |[117. Populating Next Right Pointers in Each Node II(指向右侧节点)](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/)

```java
public void connect(TreeLinkNode root) {
    TreeLinkNode dummyHead = new TreeLinkNode(0);
    TreeLinkNode pre = dummyHead;
    while (root != null) {
	    if (root.left != null) {
		    pre.next = root.left;
		    pre = pre.next;
	    }
	    if (root.right != null) {
		    pre.next = root.right;
		    pre = pre.next;
	    }
	    root = root.next;
	    if (root == null) {
		    pre = dummyHead;
		    root = dummyHead.next;
		    dummyHead.next = null;
	    }
    }
}
```
## [20240924](./202409/20240924.md) |[114. Flatten Binary Tree to Linked List(二叉树转换成单链表)](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)

```java
class Solution {
    public void flatten(TreeNode root) {
        while(root!=null){
            if(root.left!=null){
                TreeNode cur = root.left;
                while(cur.right!=null){
                    cur = cur.right;
                }
                cur.right = root.right;
                root.right = root.left;
                root.left = null;
            }
            root = root.right;
        }
    }
}
```
## [20210618](./202106/20210618.md) |[112. Path Sum(路径和)](https://leetcode.com/problems/path-sum/)

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root==null){
            return false;
        }
        if(root.left==null&&root.right==null){
            return root.val==sum;
        }
        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);
    }
}
```
## [20230310](./202303/20230310.md) |[129. Sum Root to Leaf Numbers(求根到叶子节点数字之和)](https://leetcode.com/problems/sum-root-to-leaf-numbers/)
```java
class Solution {
    public int sumNumbers(TreeNode root) {
        return sum(root, 0);
    }
    public int sum(TreeNode root, int s){
        if(root==null){
            return 0;
        }
        if(root.left == null || root.right == null){
            return 10*s+root.val;
        }
        return sum(root.left, 10*s+root.val)+sum(root.right, 10*s+root.val);
    }
}
```
## [20240916](./202409/20240916.md) |[124. Binary Tree Maximum Path Sum(二叉树的最大路径和)](https://leetcode.com/problems/binary-tree-maximum-path-sum/description)
```java
class Solution {

    private int maxValue = Integer.MIN_VALUE;;

    public int maxPathSum(TreeNode root){
        maxPathDown(root);
        return maxValue;
    }

    private int maxPathDown(TreeNode node) {
        if(node == null){
            return 0;
        }
        int left = Math.max(0, maxPathDown(node.left));
        int right = Math.max(0, maxPathDown(node.right));
        maxValue = Math.max(maxValue, left + right + node.val);
        return Math.max(left, right) + node.val;
    }
}
```
# 二叉树BFS
## [20240925](./202409/20240925.md) |[199. Binary Tree Right Side View(二叉树:二叉树的右视图)](https://leetcode.com/problems/binary-tree-right-side-view/description)
```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null){
          return list;
        }
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i=0; i<size; i++){
                TreeNode node = queue.poll();
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                if(i == size-1){
                    list.add(node.val);
                }
            }
        }
        return list;
    }
}
```
## [20211021](./202110/2021021.md) |[637. Average of Levels in Binary Tree(二叉树的层平均值)](https://leetcode.com/problems/average-of-levels-in-binary-tree/)
```java
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root==null){
            return result;
        }
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            double sum = 0;
            for(int i=0;i<size;i++){
                TreeNode temp = queue.poll();
                sum+=temp.val;
                if(temp.left!=null){
                    queue.add(temp.left);
                }
                if(temp.right!=null){
                    queue.add(temp.right);
                }
            }
            result.add(sum/size);
        }
        return result;
    }
}
```
## [20240921](./202409/20240921.md) |[102. Binary Tree Level Order Traversal(二叉树的层次遍历)](https://leetcode.com/problems/binary-tree-level-order-traversal/description)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> lists = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList();
        if(root==null){
            return lists;
        }
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i=0;i<size;i++){
                root = queue.poll();
                if(root.left != null){
                    queue.add(root.left);
                }
                if(root.right != null){
                    queue.add(root.right);
                }
                list.add(root.val);
            }
            lists.add(list);
        }
        return lists;
    }
}
```
## [20210722](./202107/20210722.md) |[103. Binary Tree Zigzag Level Order Traversal(二叉树的锯齿形层次遍历)](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> listNode = new LinkedList<>();
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        if(root == null){
            return listNode;
        }
        int flag = 0;
        stack1.push(root);
        while(!stack1.isEmpty()||!stack2.isEmpty()){
            List<Integer> subList = new LinkedList<>();
            if(flag%2==0){
                while(!stack1.isEmpty()){
                    TreeNode node = stack1.pop();
                    if(node!=null){
                        subList.add(node.val);
                        stack2.push(node.left);
                        stack2.push(node.right);
                    }
                }
            }else{
                while(!stack2.isEmpty()){
                    TreeNode node = stack2.pop();
                    if(node!=null){
                        subList.add(node.val);
                        stack1.push(node.right);
                        stack1.push(node.left);
                    }
                }
            }
            if(!subList.isEmpty()){
                listNode.add(subList);
            }
            flag++;
        }
        return listNode;
    }
}
```
## [20240919](./202409/20240919.md) |[98. Validate Binary Search Tree(有效的二叉搜索树)](https://leetcode.com/problems/validate-binary-search-tree)

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null){
            return true;
        }
        return dfs(root,Long.MIN_VALUE,Long.MAX_VALUE);
    }

    boolean dfs(TreeNode root,long min,long max){
        // 当前节点为空直接返回true
        if(root == null){
            return true;
        }
        // 当前节点比min或者left节点小，或者当前节点比right节点大，返回false
        if(root.val<=min||root.val>=max){
            return false;
        }
        // 递归执行(left，min, 根结点) &&(right，根结点, max)
        return dfs(root.left,min,(int)root.val)&&
            dfs(root.right,(int)root.val,max);
    }
}
```

# 二叉搜索树
## [20240927](./202409/20240927.md) |[230. Kth Smallest Element in a BST(二叉搜索树的第K个最小元素)](https://leetcode.com/problems/kth-smallest-element-in-a-bst)

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        while(true){
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            if(stack.isEmpty()){
                break;
            }
            root = stack.pop();
            if(--k==0){
                return root.val;
            }
            root = root.right;
        }
        return 0;
    }
}
```

中序遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            while(root != null){
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            result.add(root.val);
            root = root.right;
        }
        return result;
    }

    public void inorder(TreeNode root, List<Integer> result){
        if(root == null){
            return;
        }
        inorder(root.left, result);
        result.add(root.val);
        inorder(root.right, result);
    }
}
```
## [20201217](./202012/20201217.md) |[530. Minimum Absolute Difference in BST(父子节点最小绝对值)](https://leetcode.com/problems/minimum-absolute-difference-in-bst/)

```java
class Solution {
    TreeNode prev = null;
    int minDiff = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        if(root == null || (root.left == null && root.right == null)) {
            return 0;
        }
        helper(root);
        return minDiff;
    }

    private void helper(TreeNode root) {
      if(root != null) {
          helper(root.left);

          if(prev != null) {
              minDiff = Math.min(minDiff, Math.abs(prev.val - root.val));
          }
          prev = root;

          helper(root.right);
      }
  }
}
```
# 图
## [20241103](./202411/20241103.md) |[200. Number of Islands(图-岛屿的数量)](https://leetcode.com/problems/number-of-islands/)

```java
class Solution {
    private final char LAND = '1';
    private final char WATER = '0';
    private char[][] arr;
    public int numIslands(char[][] grid) {
        arr = grid;
        int nums = 0;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == LAND){
                    nums++;
                    dfs(i,j);
                }
            }
        }
        return nums;
    }
    private void dfs(int rows, int cols){
        // check if current rows is out of bound
        if(rows<0||rows>arr.length-1){
            return;
        }
        // check if current cols is out of bound
        if(cols<0||cols>arr[0].length-1){
            return;
        }
        // WATER or LAND
        if(arr[rows][cols]==WATER){
            return;
        }
        arr[rows][cols] = WATER;
        dfs(rows+1, cols);
        dfs(rows-1, cols);
        dfs(rows, cols+1);
        dfs(rows, cols-1);
    }
}
```
## [20221020](./202210/20221020.md) |[130. Surrounded Regions(被环绕的区域)](https://leetcode.com/problems/surrounded-regions/)

```java
class Solution {
    public void solve(char[][] board) {
        int m = board.length;
        int n = board[0].length;
        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O') {
                queue.add(new int[] {i, 0});
            }
            if (board[i][n - 1] == 'O') {
                queue.add(new int[] {i, n - 1});
            }
        }
        for (int j = 1; j < n - 1; j++) {
            if (board[0][j] == 'O') {
                queue.add(new int[] {0, j});
            }
            if (board[m - 1][j] == 'O') {
                queue.add(new int[] {m - 1, j});
            }
        }
        while(!queue.isEmpty()) {
            int[] curr = queue.poll();
            board[curr[0]][curr[1]] = '1';
            for (int[] dir : dirs) {
                if (curr[0] + dir[0] > 0 &&
                    curr[0] + dir[0] < m &&
                    curr[1] + dir[1] > 0 &&
                    curr[1] + dir[1] < n &&
                    board[curr[0] + dir[0]][curr[1] + dir[1]] == 'O') {
                    board[curr[0] + dir[0]][curr[1] + dir[1]] = '1';
                    queue.add(new int[]{curr[0] + dir[0], curr[1] + dir[1]});
                }
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == '1') {
                    board[i][j] = 'O';
                } else {
                    board[i][j] = 'X';
                }
            }
        }

    }
}
```
## [20220411](./202204/20220411.md) |[133. Clone Graph(图复制)](https://leetcode.com/problems/clone-graph/)

```java
class Solution {
    public HashMap<Integer, Node> map = new HashMap<>();

    public Node cloneGraph(Node node) {
        return clone(node);
    }

    public Node clone(Node node) {
        if (node == null) return null;

        if (map.containsKey(node.val))
            return map.get(node.val);

        Node newNode = new Node(node.val, new ArrayList<Node>());
        map.put(newNode.val, newNode);
        for (Node neighbor : node.neighbors)
            newNode.neighbors.add(clone(neighbor));
        return newNode;
    }
}
```
## [20241104](./202411/20241104.md) |[207. Course Schedule(课程计划)](https://leetcode.com/problems/course-schedule/)

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if(numCourses <= 0)
        	return false;
        Queue<Integer> queue = new LinkedList<Integer>();
        int[] inDegree = new int[numCourses];
        for(int i = 0; i < prerequisites.length; i++) inDegree[prerequisites[i][0]]++;
        for(int i = 0; i < numCourses; i++){
        	if(inDegree[i] == 0){
        		queue.offer(i); // find the start courses
        	}
        }
        // begin traverse
        while(!queue.isEmpty()){
        	int startCourse = queue.poll();
        	for(int i = 0; i < prerequisites.length; i++){
        		if(startCourse == prerequisites[i][1]){
        			if(--inDegree[prerequisites[i][0]] == 0){
        				queue.offer(prerequisites[i][0]);
        			}
        		}
        	}
        }
        for(int i =0; i < numCourses; i++){
        	if(inDegree[i] !=0) return false;
        }
        return true;
    }
}
```
# 图-BFS
## [20220320](./202203/20220320.md) |[127. Word Ladder(词语阶梯-BFS)](https://leetcode.com/problems/word-ladder/)

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> reached = new HashSet<String>();
        reached.add(beginWord);
        wordList.add(endWord);
        int distance = 1;
        while (!reached.contains(endWord)) {
            Set<String> toAdd = new HashSet<String>();
            for (String each : reached) {
                for (int i = 0; i < each.length(); i++) {
                    char[] chars = each.toCharArray();
                    for (char ch = 'a'; ch <= 'z'; ch++) {
                        chars[i] = ch;
                        String word = new String(chars);
                        if (wordList.contains(word)) {
                            toAdd.add(word);
                            wordList.remove(word);
                        }
                    }
                }
            }
            distance++;
            if (toAdd.size() == 0) return 0;
            reached = toAdd;
        }
        return distance;
    }
}
```

# Trie
## [20241130](./202411/20241130.md) |[208. Implement Trie (Prefix Tree)(实现前缀树)](https://leetcode.com/problems/implement-trie-prefix-tree/)

```java
class Trie {

    TrieNode root;

    /** Initialize your data structure here. */
    public Trie() {
        root = new TrieNode();
    }

    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode temp = root;
        for(char c:word.toCharArray()){
            int i = c-'a';
            if(temp.children[i]==null){
                TrieNode newNode=new TrieNode();
                temp.children[i]=newNode;
            }
            temp=temp.children[i];
        }
        temp.end=true;
    }

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode temp= root;
        for(char c: word.toCharArray()){
             int i=c-'a';
             if(temp.children[i]==null){
                 return false;
             }
             temp=temp.children[i];       
        }
        return temp.end;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        TrieNode temp= root;
        for(char c: prefix.toCharArray()){
             int i=c-'a';
             if(temp.children[i]==null){
                 return false;
             }
             temp=temp.children[i];   
        }
        return temp!=null;
    }

    static class TrieNode{
        TrieNode[] children=new TrieNode[26];
        boolean end = false;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```
# 回溯法
## [20240902](./202409/20240902.md) |[17. Letter Combinations of a Phone Number(电话号码的字母组合)](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> list = new LinkedList<>();
        if(digits == null || digits.length() == 0) {
            return list;
        }
        char[][] map = {{},{},{'a','b','c'},{'d','e','f'},{'g','h','i'},{'j','k','l'},{'m','n','o'},{'p','q','r','s'},{'t','u','v'},{'w','x','y','z'}};
        backtrack(digits,list,map,new StringBuilder(),0);
        return list;
    }
    private void backtrack(String digits, List<String> list, char[][] map, StringBuilder result, int start){
        if(start == digits.length()){
            list.add(new String(result));
            return;
        }
        int num = digits.charAt(start) - '0';
        for(int i = 0;i< map[num].length;i++){
            result.append(map[num][i]);
            backtrack(digits, list, map, result, start+1);
            result.deleteCharAt(result.length() - 1);
        }
    }
}
```
## [20220318](./202203/20220318.md) |[77. Combinations(组合-暴力枚举)](https://leetcode.com/problems/combinations/)

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        backtrack(res, new ArrayList(), n, k,1);
        return res;
    }
    private void backtrack(List<List<Integer>> res, List<Integer> tempList, int n, int k,int start){
        if(tempList.size()==k){
            res.add(new ArrayList(tempList));
            return;
        }
        for(int i=start; i<=n; i++){
           tempList.add(i);
           backtrack(res,tempList,n,k,i+1);
           tempList.remove(tempList.size()-1);
        }
    }
}
```
## [20240905](./202409/20240905.md) |[46. Permutations(排列)](https://leetcode.com/problems/permutations/description/)

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> lists = new ArrayList<List<Integer>>();
        backtrack(nums, 0, lists);
        return lists;
    }

    public void backtrack(int[] nums, int start, List<List<Integer>> lists){
        if(start == nums.length){
            List<Integer> temp = new ArrayList<>();
            for(int i = 0; i<nums.length; i++){
                temp.add(nums[i]);
            }
            lists.add(temp);
        }else{
            for(int i=start; i<nums.length; i++){
                swap(nums, i, start);
                backtrack(nums, start + 1, lists);
                swap(nums, i, start);
            }
        }
    }

    public static void swap(int[] nums, int start, int end){
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
    }
}
```
## [20240904](./202409/20240904.md) |[39. Combination Sum(组合总和)](https://leetcode.com/problems/combination-sum/description)

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(candidates);
        backtrack(list, new ArrayList<>(), candidates, target, 0);
        return list;
    }

    public void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int remain, int start){
        if(remain < 0){
            return;
        }else if(remain == 0){
            list.add(new ArrayList<>(tempList));
            return;
        }else{
            for(int i = start; i<nums.length; i++){
                tempList.add(nums[i]);
                backtrack(list, tempList, nums, remain-nums[i], i);
                tempList.remove(tempList.size() - 1);
            }
        }
    }
}
```
## [20221025](./202210/20221025.md) |[52. N-Queens II(N皇后问题2)](https://leetcode.com/problems/n-queens-ii/)

```java
class Solution {
    int count = 0;
    public int totalNQueens(int n) {
        boolean[] cols = new boolean[n];     // columns   |
        boolean[] d1 = new boolean[2 * n];   // diagonals \
        boolean[] d2 = new boolean[2 * n];   // diagonals /
        backtracking(0, cols, d1, d2, n);
        return count;
    }

    public void backtracking(int row, boolean[] cols, boolean[] d1, boolean []d2, int n) {
        if(row == n) count++;

        for(int col = 0; col < n; col++) {
            int id1 = col - row + n;
            int id2 = col + row;
            if(cols[col] || d1[id1] || d2[id2]) continue;

            cols[col] = true; d1[id1] = true; d2[id2] = true;
            backtracking(row + 1, cols, d1, d2, n);
            cols[col] = false; d1[id1] = false; d2[id2] = false;
        }
    }
}
```
## [20240903](./202409/20240903.md) |[22. Generate Parentheses(生成括号)](https://leetcode.com/problems/generate-parentheses/)

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> list = new ArrayList<>();
        backtrack(list,"",0,0,n);
        return list;
    }
    public void backtrack(List<String> list, String result, int left, int right, int n){
        if(result.length() == n * 2){
            list.add(result);
            return;
        }
        if(left < n){
            backtrack(list,result+"(",left+1,right,n);
        }
        if(right < left){
            backtrack(list,result+")",left,right+1,n);
        }
    }
}
```

## [20240908](./202409/20240908.md) |[79. Word Search(单词查找)](https://leetcode.com/problems/word-search)

```java
class Solution {
    int[][] dirs={{1,0},{-1,0},{0,1},{0,-1}};
    public boolean exist(char[][] board, String word) {
        if (board==null ||board.length==0||board[0].length==0) return false;
        int m=board.length,n=board[0].length;
        boolean[][] visited=new boolean[m][n];
        for (int i=0;i< m;i++){
            for (int j=0;j<n;j++){               
                if (dfs(board,visited,i,j,0,word)){
                    return true;
                }              
            }
        }
        return false;
    }
    private boolean dfs(char[][] board, boolean[][] visited, int x, int y, int i, String word){         
        int m=board.length,n=board[0].length;   
        if (i==word.length()) return true;

        if(x<0||x>=m||y<0||y>=n) return false;
        if(visited[x][y]) return false;
        if(board[x][y]!=word.charAt(i)) return false;

        visited[x][y]=true;
        for (int[] dir: dirs){
            int x1=x+dir[0], y1=y+dir[1];
            if (dfs(board, visited, x1, y1, i+1, word)){
                return true;
            }
        }
        visited[x][y]=false;
        return false;                                                                          
    }
}
```
# 分治法
## [20241211](./202412/20241211.md) |[108. Convert Sorted Array to Binary Search Tree(排序数组转换成二叉搜索树)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
         return buildTree(nums, 0 , nums.length-1);
    }
    public TreeNode buildTree(int[] nums, int low, int high){
        if(low > high){
            return null;
        }
        int mid = low + (high-low)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildTree(nums, low, mid-1);
        root.right = buildTree(nums, mid+1, high);
        return root;
    }
}
```
## [20241030](./202410/20241030.md) |[148. Sort List(链表排序)](https://leetcode.com/problems/sort-list/)

```java
import java.util.Collections;

class Solution {
    public ListNode sortList(ListNode head) {
        ListNode sorted = null;
        ListNode   = null;
        List<ListNode> list = new ArrayList<>();
        while(head!=null){
            list.add(new ListNode(head.val));
            head = head.next;
        }

        Collections.sort(list, new Comparator<ListNode>(){
            @Override
            public int compare(ListNode o1, ListNode o2){
                return o1.val-o2.val;
            }
        });

        for(ListNode node:list){
            if(sorted==null){
                sorted = node;
                sRef = sorted;
            }else{
                sRef.next = node;
                sRef = sRef.next;
            }
        }
        return sorted;
    }
}
```
## [20241023](./202410/20241023.md) |[23. Merge k Sorted Lists(合并K个有序链表)](https://leetcode.com/problems/merge-k-sorted-lists/)

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return partition(lists,0,lists.length-1);
    }
    public ListNode partition(ListNode[] lists, int s ,int e){
        if(s==e){
            return lists[s];
        }
        if(s<e){
            int q = (s+e)/2;
            ListNode l1 = partition(lists, s ,q);
            ListNode l2 = partition(lists, q+1, e);
            return merge(l1,l2);
        }else{
            return null;
        }
    }
    public static ListNode merge(ListNode l1, ListNode l2){
        if(l1==null) return l2;
        if(l2==null) return l1;
        if(l1.val<l2.val){
            l1.next = merge(l1.next,l2);
            return l1;
        }else{
            l2.next = merge(l1,l2.next);
            return l2;
        }
    }
}
```
## [20241203](./202412/20241203.md) |[53. Maximum Subarray(最大子段和)](https://leetcode.com/problems/maximum-subarray/description/)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums==null||nums.length==0){
            return 0;
        }
        int sum = nums[0];
        int max = sum;
        for(int i = 1;i<nums.length;i++){
            if(sum + nums[i] < nums[i]){
                sum = nums[i];
            }else{
                sum += nums[i];
            }
            max = Math.max(max, sum);
        }
        return max;
    }
}
```
# 二分查找
## [20240914](./202409/20240914.md) |[35. Search Insert Position(寻找插入的位置)](https://leetcode.com/problems/search-insert-position/)

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length-1;
        while(left<=right){
             int mid = left + (right - left)/2;
             if(nums[mid] == target){
                 right = mid -1;
             }else if(nums[mid] < target){
                 left = mid +1;
             }else{
                 right = mid -1;
             }
        }
        return left;
    }
}
```
## [20240915](./202409/20240915.md) |[74. Search a 2D Matrix(二维数组的查找)](https://leetcode.com/problems/search-a-2d-matrix/description/)

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int i = 0;
        int j = matrix[0].length-1;
        while(i>=0 && i<matrix.length && j>=0 && j<matrix[0].length){
            if(matrix[i][j] == target){
                return true;
            }else if(matrix[i][j] < target){
                i++;
            }else if(matrix[i][j] > target){
                j--;
            }
        }
        return false;
    }
}
```
## [20210908](./202109/20210908.md) |[162. Find Peak Element(发现山峰元素)](https://leetcode.com/problems/find-peak-element/)

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int low = 0;
        int high = nums.length-1;
        while(low<high){
            int mid1 = (low+high)/2;
            int mid2 = mid1+1;
            if(nums[mid1] < nums[mid2]){
                low = mid2;
            }else{
                high = mid1;
            }    
        }
        return low;
    }
}
```
## [20240912](./202409/20240912.md) |[33. Search in Rotated Sorted Array(旋转数组二分查找)](https://leetcode.com/problems/search-in-rotated-sorted-array)

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right-left)/2;
            if(nums[mid] == target){
                return mid;
            }
            if(nums[mid] < nums[right]){
                if(nums[mid] < target && target <= nums[right]){
                    left = mid + 1;
                }else{
                    right = mid - 1;
                }
            }else{
                if(nums[left] <= target && target < nums[mid]){
                    right = mid -1;
                }else{
                    left = mid + 1;
                }
            }
        }
        return -1;
    }
}
```
## [20240913](./202409/20240913.md) |[34. Find First and Last Position of Element in Sorted Array(查找排序数组中元素的第一个和最后一个位置)](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] res = new int[] { -1, -1 };
        if (nums == null || nums.length == 0) {
            return res;
        }
        int start = 0, end = nums.length - 1;
        while (nums[start] < nums[end]) {
            int mid = start + (end - start) / 2;
            if (nums[mid] < target) {
                start = mid + 1;
            } else if (nums[mid] > target) {
                end = mid - 1;
            } else {
                if (nums[start] < target) {
                    start++;
                }
                if (nums[end] > target) {
                    end--;
                }
            }
        }
        if (nums[start] == target) {
            res[0] = start;
            res[1] = end;
        }
        return res;
    }
}
```
## [20240917](./202409/20240917.md) |[153. Find Minimum in Rotated Sorted Array(旋转排序数组中的最小值)](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

```java
class Solution {
    public int findMin(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        int left = 0, right = nums.length - 1;
        if (nums[right] > nums[0]) {
            return nums[0];
        }
        while (right >= left) {
            int mid = left + (right - left)/2;
            if(nums[mid] > nums[mid+1]){
                return nums[mid+1];
            }
            if(nums[mid-1] > nums[mid]){
                return nums[mid];
            }
            if(nums[0] < nums[mid]){
                left = mid + 1;
            }else{
                right = mid -1;
            }
        }
        return Integer.MAX_VALUE;
    }
}
```

## [20240911](./202409/20240911.md) |[4. Median of Two Sorted Arrays(两个排序数组的中位数)](https://leetcode.com/problems/median-of-two-sorted-arrays/)

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        int l = (m+n+1)/2;
        int r = (m+n+2)/2;
        return (getKth(nums1,0,nums2,0,l)+getKth(nums1,0,nums2,0,r))/2.0;
    }

    public double getKth(int[] A, int aStart, int[] B, int bStart, int k){
        if(aStart>A.length-1){
            return B[bStart+k-1];
        }
        if(bStart>B.length-1){
            return A[aStart+k-1];
        }
        if(k==1){
            return Math.min(A[aStart],B[bStart]);
        }
        int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE;
        if(aStart+k/2-1<A.length){
            aMid = A[aStart+k/2-1];
        }
        if(bStart+k/2-1<B.length){
            bMid = B[bStart+k/2-1];   
        }
        if(aMid<bMid){
            return getKth(A, aStart+k/2,B,bStart,k-k/2);
        }else{
            return getKth(A,aStart,B,bStart+k/2, k-k/2);
        }
    }
}
```
# 堆
## [20241110](./202411/20241110.md) |[215. Kth Largest Element in an Array(数组中第K个最大元素)](https://leetcode.com/problems/kth-largest-element-in-an-array/)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int n = nums.length, low = 0, high = n-1;
        while(low<=high){
           int x = partition(nums, low, high);
           if(n-x == k){
               return nums[x];
           }else if(n-x < k){
               high = x-1;
           }else{
               low = x+1;
           }
        }
        return low;
    }

    private int partition(int[] nums, int low, int high){
        int i = low;
        int j = high;
        int povit = nums[i];
        while(i < j){
            while(i < j && povit < nums[j]){
                j--;
            }
            if(i < j){
                nums[i] = nums[j];
                nums[j] = povit;
                i++;
            }
            while(i < j && povit > nums[i]){
                i++;
            }
            if(i < j){
                nums[j] = nums[i];
                nums[i] = povit;
                j--;
            }
        }
        return i;
    }
}
```
## [20241111](./202411/20241111.md) |[295. Find Median from Data Stream(发现数据流中的中位数)](https://leetcode.com/problems/find-median-from-data-stream/)

```java
class MedianFinder {

    List<Integer> list;

    public MedianFinder() {
        this.list = new ArrayList<Integer>();
    }

    public void addNum(int num) {
        if(list.size() == 0){
            list.add(0, num);  
        }else{
            int i=0;
            while(list.get(i) <= num && i<list.size()-1) i++;
            //*****The reason why I didn't traversed till the last index was to escape from IndexOutOfBounds Error*****
            if(list.get(i) <= num){
                list.add(i+1, num);
            }else{
                list.add(i, num);
            }
        }
    }

    public double findMedian() {
        int n = list.size();
        if(n == 0) return 0;
        if(n%2 == 1) return list.get(n/2);
        return (double)((list.get(n/2) + list.get(n/2 - 1)))/2;
    }
}
```
# 位运算
## [20220819](./202208/20220819.md) |[67. Add Binary(二进制数字相加)](https://leetcode.com/problems/add-binary/)

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuffer sb = new StringBuffer();
        int i = a.length()-1;
        int j = b.length()-1;
        int temp = 0;
        while(i>=0||j>=0){
            int x=0,y=0;
            if(i>=0) x=a.charAt(i--)-'0';
            if(j>=0) y=b.charAt(j--)-'0';
            if(x+y+temp<2){
                sb.append(x+y+temp);
                temp = 0;
            }else{
                sb.append(x+y+temp-2);
                temp =1;
            }
        }
        if(temp!=0){
            sb.append(temp);
        }
        return sb.reverse().toString();
    }
}
```
## [20201224](./202012/20201224.md) |[191. Number of 1 Bits(数字1的个数)](https://leetcode.com/problems/number-of-1-bits/)

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count=0;
        String s=Integer.toBinaryString(n);
        for(char c:s.toCharArray()){
            if(c=='1'){
                count ++;
            }
        }
        return count;
    }
}
```
## [20241206](./202412/20241206.md) |[136. Single Number(单一数字)](https://leetcode.com/problems/single-number/)

```java
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for(int i=0; i<nums.length; i++){
            result ^= nums[i];
        }
        return result;
    }
}
```
## [20220731](./202207/20220731.md) |[137. Single Number II(只出现一次的数字2)](https://leetcode.com/problems/single-number-ii/)

```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for(int i = 0; i < 32; i++) {
            int sum = 0;
            for(int j = 0; j < nums.length; j++) {
                if(((nums[j] >> i) & 1) == 1) {
                    sum++;
                    sum %= 3;
                }
            }
            if(sum != 0) {
                ans |= sum << i;
            }
        }
        return ans;
    }
}
```
# 数学
## [20220413](./202204/20220413.md) |[9. Palindrome Number(回文数)](https://leetcode.com/problems/palindrome-number/)

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x<0){
            return false;
        }
        int origin = x;
        int sum = 0;
        while(x!=0){
            sum = sum*10 + x%10;
            x /= 10;
        }
        return sum==origin;
    }
}
```
## [20211212](./202112/20211212.md) |[66. Plus One(数组加一)](https://leetcode.com/problems/plus-one/)

```java
class Solution {
    public int[] plusOne(int[] digits) {
        for(int i=digits.length-1;i>=0;i--){
            if(digits[i]+1==10){
                digits[i] = 0;
            }else{
                digits[i]++;
                return digits;
            }
        }
        int[] newArray = new int[digits.length+1];
        newArray[0] = 1;
        return newArray;
    }
}
```
## [20210810](./202108/20210810.md) |[69. Sqrt(x)](https://leetcode.com/problems/sqrtx/)

```java
class Solution {
    public int mySqrt(int x) {
        if (0 == x) return 0;
        int left = 1, right = x, ans=0;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (mid <= x / mid) {
                left = mid + 1;
                ans = mid;
            } else {
                right = mid - 1;
            }
        }
        return ans;
    }
}
```
## [20221101](./202211/20221101.md) |[50. Pow(x, n)(求次幂)](https://leetcode.com/problems/powx-n/)

```java
class Solution {
    public double myPow(double x, int n) {
        if(n == 0)
            return 1;
        if(n<0){
            return 1/x * myPow(1/x, -(n + 1));
        }
        return (n%2 == 0) ? myPow(x*x, n/2) : x*myPow(x*x, n/2);
    }
}
```
## [20220425](./202204/20220425.md) |[149. Max Points on a Line(线上最多的点)](https://leetcode.com/problems/max-points-on-a-line/)

```java
class Solution {
    public int maxPoints(int[][] points) {
        if(points.length <= 0) return 0;
        if(points.length <= 2) return points.length;
        int result = 0;
        for(int i = 0; i < points.length; i++){
            HashMap<Double, Integer> hm = new HashMap<Double, Integer>();
            int samex = 1;
            int samep = 0;
            for(int j = 0; j < points.length; j++){
                if(j != i){
                    if((points[j].x == points[i].x) && (points[j].y == points[i].y)){
                        samep++;
                    }
                    if(points[j].x == points[i].x){
                        samex++;
                        continue;
                    }
                    double k = (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x);
                    if(hm.containsKey(k)){
                        hm.put(k,hm.get(k) + 1);
                    }else{
                        hm.put(k, 2);
                    }
                    result = Math.max(result, hm.get(k) + samep);
                }
            }
            result = Math.max(result, samex);
        }
        return result;
    }
}
```
# 一维动态规划
## [20241005](./202410/20241005.md) |[70. Climbing Stairs(爬梯子)](https://leetcode.com/problems/climbing-stairs/description/)

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 1) {
            return 1;
        }
        int[] dp = new int[n];
        dp[0] = 1;
        dp[1] = 2;
        for(int i=2; i<n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n-1];
    }
}
```
## [20241010](./202410/20241010.md) |[198. House Robber(打家劫舍)](https://leetcode.com/problems/house-robber/description)

```java
class Solution {
    public int rob(int[] nums) {
        if(nums==null || nums.length==0){
            return 0;
        }
        int[] dp = new int[nums.length+1];
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i=1;i<nums.length;i++){
            // 下一家可以偷，dp[i-1]+nums[i]
            // 下一家不可以偷，dp[i]
            dp[i+1] = Math.max(dp[i], nums[i]+dp[i-1]);
        }
        return dp[nums.length];
    }
}
```
## [20241008](./202410/20241008.md) |[139. Word Break(单词拆分)](https://leetcode.com/problems/word-break/)

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] T = new boolean[s.length() + 1];
        Set<String> set = new HashSet<>();
        for (String word : wordDict) {
            set.add(word);
        }
        T[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if(T[j] && set.contains(s.substring(j, i))) {
                    T[i] = true;
                    break;
                }
            }
        }
        return T[s.length()];
    }
}
```
## [20241013](./202410/20241013.md) |[322. Coin Change(零钱兑换)](https://leetcode.com/problems/coin-change)

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if (coins == null || coins.length == 0 || amount <= 0) {
            return 0;
        }
        int[] dp = new int[amount + 1];
        for (int i = 1; i <= amount; i++) {
            dp[i] = Integer.MAX_VALUE;
            for (int coin : coins) {
                if (i >= coin && dp[i - coin] != Integer.MAX_VALUE) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```
## [20241012](./202410/20241012.md) |[300. Longest Increasing Subsequence(最长递增子序列)](https://leetcode.com/problems/longest-increasing-subsequence/)
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int maxLen = 1;
        int[] dp = new int[nums.length];
        for(int i=0; i< nums.length;i++){
            dp[i] = 1;
            for(int j=0;j<i;j++){
                if(nums[j] < nums[i]){
                    dp[i] = Math.max(dp[j]+1, dp[i]);
                }
            }
            if(dp[i] > maxLen){
                maxLen = dp[i];
            }
        }
        return maxLen;
    }
}
```
# 多维动态规划
## [20241007](./202410/20241007.md) |[118. Pascal's Triangle(杨辉三角)](https://leetcode.com/problems/pascals-triangle/description)

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> lists= new ArrayList<>();
        if(numRows==0) {
            return lists;
        }
        if(numRows>=1) {
            List<Integer> list = new ArrayList<>();
            list.add(1);
            lists.add(list);
        }
        if(numRows>=2) {
            List<Integer> list = new ArrayList<>();
            list.add(1);
            list.add(1);
            lists.add(list);
        }
        if(numRows>=3){
            for(int j =3;j<=numRows;j++){
                List<Integer> list = new ArrayList<>();
                List<Integer> pre = lists.get(lists.size()-1);
                list.add(1);
                for(int i=0; i<pre.size()-1; i++){
                    int num = pre.get(i) + pre.get(i+1);
                    list.add(num);
                }
                list.add(1);
                lists.add(list);
            }
        }
        return lists;
    }
}
```

## [20241004](./202410/20241004.md) |[64. Minimum Path Sum(最小路径和)](https://leetcode.com/problems/minimum-path-sum/description)

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 1; i < m; i++) {
            grid[i][0] += grid[i - 1][0];
        }
        for (int j = 1; j < n; j++) {
            grid[0][j] += grid[0][j - 1];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                grid[i][j] += Math.min(grid[i][j - 1], grid[i - 1][j]);
            }
        }
        return grid[m - 1][n - 1];
    }
}
```
## [20220326](./202203/20220326.md) |[63. Unique Paths II(不同的路径2)](https://leetcode.com/problems/unique-paths-ii/)

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        if (m == 0) {
            return 0;
        }
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = obstacleGrid[0][0] == 1 ? 0 : 1;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i + j == 0) {
                    continue;
                }
                if (i == 0) {
                    dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i][j - 1];
                } else if (j == 0) {
                    dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i - 1][j];
                } else {
                    dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
```
## [20241001](./202410/20241001.md) |[5. Longest Palindromic Substring(最长回文子串)](https://leetcode.com/problems/longest-palindromic-substring/description)

```java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }
        int len = s.length();
        String ans = "";
        int max = 0;
        boolean[][] dp = new boolean[len][len];
        for (int j = 0; j < len; j++) {
            for (int i = 0; i < len; i++) {
                boolean judge = s.charAt(i) == s.charAt(j);
                dp[i][j] = j - i > 2 ? dp[i + 1][j - 1] && judge : judge;
                if (dp[i][j] && j - i + 1> max) {
                    ans = s.substring(i, j + 1);
                    max = j - i + 1;
                }
            }
        }
        return ans;
    }
}
```
## [20211026](./202110/2021026.md) |[97. Interleaving String(DP交错字符串)](https://leetcode.com/problems/interleaving-string/)

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int len1 = s1.length();
    	int len2 = s2.length();
    	int len3 = s3.length();

    	if(len1 + len2 != len3){
    		return false;
    	}

    	boolean[][] f = new boolean[len1+1][len2+1];
    	f[0][0] = true;//第一个设置为true
    	for(int i = 0; i <= len1; i++){
    		for(int j = 0; j <= len2; j++){
    			//i>0,j>0的条件是去掉i=0j=0的值
    			if(j > 0){
    				f[i][j] = f[i][j-1]&&(s3.charAt(i+j-1) == s2.charAt(j-1));
    			}
    			if(i > 0){
    				f[i][j] = f[i][j] || ( f[i-1][j]&&(s3.charAt(i+j-1) == s1.charAt(i-1)));
    			}
    		}
    	}
    	return f[len1][len2];
    }
}
```
## [20241006](./202410/20241006.md) |[72. Edit Distance(编辑距离)](https://leetcode.com/problems/edit-distance/)

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        int[][] dp = new int[len1+1][len2+1];
        for(int i=0;i<=len1;i++){
            dp[i][0] = i;
        }
        for(int j=0;j<=len2;j++){
            dp[0][j] = j;
        }
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                if(word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]))+1;
                }
            }
        }
        return dp[len1][len2];
    }
}
```
## [20210505](./202105/20210505.md) |[123. Best Time to Buy and Sell Stock III(买卖股票的最佳时间3)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length==0){
            return 0;
        }
        int b1 = Integer.MAX_VALUE;
        int b2 = Integer.MAX_VALUE;
        int p1=0, p2=0;
        for(int i=0;i<prices.length;i++){
            // 最低价格 = 找出最低的价格
            b1 = Math.min(b1,prices[i]);
            // 最大收益 = 当前价格-最低的价格
            p1 = Math.max(p1,prices[i]-b1);
            // 当前价格-以往最高的收益
            b2 = Math.min(b2,prices[i]-p1);
            // 当前价格 + 以往最高收益
            p2 = Math.max(p2,prices[i]-b2);
        }
        return p2;
    }
}
```
## [20210831](./202108/20210831.md) |[221. Maximal Square(最大正方形)](https://leetcode.com/problems/maximal-square/)

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){
            return 0;
        }
        int max = 0, n = matrix.length, m = matrix[0].length;
        // dp(i, j) represents the length of the square
        // whose lower-right corner is located at (i, j)
        // dp(i, j) = min{ dp(i-1, j-1), dp(i-1, j), dp(i, j-1) }
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (matrix[i - 1][j - 1] == '1') {
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
                    max = Math.max(max, dp[i][j]);
                }
            }
        }
        // return the area
        return max * max;
    }
}
```
